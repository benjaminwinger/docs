{
    "docs": [
        {
            "location": "/",
            "text": "WARG Docs\n\n\nThe official source of all your WARG needs. Joking, there's only documentation and GIFs here. Enjoy!\n\n\n\n\n\n\n\nCompetition\n\n\n\n\nUAS 2017 Competition Homepage\n\n\nCompetition Canops\n\n\n\n\nBootcamps\n\n\n\n\nMechanical Bootcamp\n\n\nElectrical Bootcamp\n\n\nGroundstation Bootcamp\n\n\nComputer Vision Bootcamp\n\n\nEmbedded Software Bootcamp\n\n\n\n\nProjects Documentation\n\n\n\n\nPicPilot Documentation\n\n\nGroundstation Documentation\n\n\nNetwork Documentation\n\n\nComputer Vision Documentation\n\n\nMechanical Documentation\n\n\n\n\nTutorials\n\n\n\n\nGit Tutorial\n\n\nCommand Line Tutorial\n\n\n\n\nAPI Documentation\n\n\n\n\nComputer Vision API Docs\n\n\nGround Station API Docs",
            "title": "Home"
        },
        {
            "location": "/#warg-docs",
            "text": "The official source of all your WARG needs. Joking, there's only documentation and GIFs here. Enjoy!",
            "title": "WARG Docs"
        },
        {
            "location": "/#competition",
            "text": "UAS 2017 Competition Homepage  Competition Canops",
            "title": "Competition"
        },
        {
            "location": "/#bootcamps",
            "text": "Mechanical Bootcamp  Electrical Bootcamp  Groundstation Bootcamp  Computer Vision Bootcamp  Embedded Software Bootcamp",
            "title": "Bootcamps"
        },
        {
            "location": "/#projects-documentation",
            "text": "PicPilot Documentation  Groundstation Documentation  Network Documentation  Computer Vision Documentation  Mechanical Documentation",
            "title": "Projects Documentation"
        },
        {
            "location": "/#tutorials",
            "text": "Git Tutorial  Command Line Tutorial",
            "title": "Tutorials"
        },
        {
            "location": "/#api-documentation",
            "text": "Computer Vision API Docs  Ground Station API Docs",
            "title": "API Documentation"
        },
        {
            "location": "/bootcamp/mechanical/",
            "text": "WARG Mechanical Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nMake justified mechanical design decisions based on project constraints and criteria\n\n\nLearn to take accurate measurements of parts using vernier callipers\n\n\nLearn CAD design in SolidWorks\n\n\nLearn how to make assemblies in SolidWorks\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Two-Axis Camera Gimbal:\n\n\nBackground\n\n\nA camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.\n\n\nTask\n\n\nYou are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of \nmm and g\n. If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed \npart files and assembly file\n to a Team Lead for evaluation.\n\n\nProject Checklist\n\n\n\n\nParts made in SolidWorks using dimensions of mm and g\n\n\nGoPro Case measured with power button exposed\n\n\nMounting method using 4 M4 bolts to the flat board\n\n\nMotors / Servos selected and modeled (if required)\n\n\nAssembly created with the gimbal able to rotate 360 degrees in both axis\n\n\n\n\nUsing Solidworks\n\n\nThere are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Mechanical"
        },
        {
            "location": "/bootcamp/mechanical/#warg-mechanical-bootcamp",
            "text": "",
            "title": "WARG Mechanical Bootcamp"
        },
        {
            "location": "/bootcamp/mechanical/#introduction",
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.",
            "title": "Introduction"
        },
        {
            "location": "/bootcamp/mechanical/#bootcamp-objectives",
            "text": "Make justified mechanical design decisions based on project constraints and criteria  Learn to take accurate measurements of parts using vernier callipers  Learn CAD design in SolidWorks  Learn how to make assemblies in SolidWorks",
            "title": "Bootcamp Objectives"
        },
        {
            "location": "/bootcamp/mechanical/#bootcamp-outline",
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.",
            "title": "Bootcamp Outline"
        },
        {
            "location": "/bootcamp/mechanical/#1-two-axis-camera-gimbal",
            "text": "",
            "title": "1. Two-Axis Camera Gimbal:"
        },
        {
            "location": "/bootcamp/mechanical/#background",
            "text": "A camera gimbal is an electromechanical device used to stabilize and direct a camera in a desired direction. On our aircraft the camera is a crucial component which provides us with the information allowing us to locate targets using our computer vision software. The camera gimbal houses the camera used to obtain these images. During flight it is vital to keep the camera as still as possible while always pointing towards the ground no matter what orientation the aircraft is in.",
            "title": "Background"
        },
        {
            "location": "/bootcamp/mechanical/#task",
            "text": "You are tasked with designing a two-axis gimbal (mechanical or electromechanical) to house a GoPro Hero 3 camera. This gimbal design needs to be lightweight, minimize drag and have a 360 degree range of motion in both axis. The gimbal will be attached to a flat rigid board using four M4 bolts. The design does not need to include the board but needs to have proper holes for the bolts to attach the gimbal to the board. You will need to come into the WARG bay (E5 2001) and take all necessary measurements of the GoPro in METRIC UNITS using our Vernier Callipers. You need to design a case to hold the GoPro and the case must make the power button easily accessible through the case. All parts must be made in SolidWorks using units of  mm and g . If your design uses servos and/or motors you will need to model these in SolidWorks as well. Once all of the parts are made you will make an assembly with the proper mating to demonstrate the 360 degree range of motion in both axis. Once all of these tasks are completed you can bring your completed  part files and assembly file  to a Team Lead for evaluation.",
            "title": "Task"
        },
        {
            "location": "/bootcamp/mechanical/#project-checklist",
            "text": "Parts made in SolidWorks using dimensions of mm and g  GoPro Case measured with power button exposed  Mounting method using 4 M4 bolts to the flat board  Motors / Servos selected and modeled (if required)  Assembly created with the gimbal able to rotate 360 degrees in both axis",
            "title": "Project Checklist"
        },
        {
            "location": "/bootcamp/mechanical/#using-solidworks",
            "text": "There are many options for you to use SolidWorks (SW) for this Bootcamp. First, SW has a free 30 day trial which can be downloaded from their website. Second, if you are an MME student you should already have a version downloaded from your ME 100 class. Third, all the engineering computer labs have SW on the computers. Fourth, the WARG Bay has a version of SW on our desktop computer. One of these methods should be used to complete the Bootcamp. Therefore, you all should have access to the SW software.",
            "title": "Using Solidworks"
        },
        {
            "location": "/bootcamp/mechanical/#2-previous-team-contribution",
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp. An example of a project that would be exempted: 3D modeling of our VTOL aircraft in SolidWorks.",
            "title": "2. Previous Team Contribution"
        },
        {
            "location": "/bootcamp/mechanical/#completion-of-bootcamp",
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Completion of Bootcamp"
        },
        {
            "location": "/bootcamp/computer-vision/",
            "text": "Computer-Vision Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\n1. Fork and Setup Local Project\n\n\nForks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).\n\n\nClone your fork with either:\n\n\ngit clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nif you want to use ssh\nor\n\n\ngit clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git\n\n\n\n\nfor https\n\n\nNote that you will need to have CMake installed so that you can build your module once you've written it.\n\n\n2. Code\n\n\nYour task is to implement \nmerge sort\n (or indeed a different sorting algorithm if you wish).\n\n\nYour code must be implemented in a module (see the included core module for an example) and must:\n\n\n\n\nFollow our \nstyle guide\n\n\nBuild using CMake\n\n\nBe well documented using doxygen-formatted comments\n\n\nBe tested using \nBoost Test\n\n\n\n\nSee \ncontributing\n for an example and more information.\n\n\nYou are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.\n\n\n3. Submit\n\n\nTo submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.\n\n\nOnce your pull request has been merged you are ready to work on the Computer Vision project.",
            "title": "Computer Vision"
        },
        {
            "location": "/bootcamp/computer-vision/#computer-vision-bootcamp",
            "text": "",
            "title": "Computer-Vision Bootcamp"
        },
        {
            "location": "/bootcamp/computer-vision/#introduction",
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve and to familiarize you with our system and conventions. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with the main software project! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.",
            "title": "Introduction"
        },
        {
            "location": "/bootcamp/computer-vision/#1-fork-and-setup-local-project",
            "text": "Forks can be created using the fork button in the top right of the Github Interface (you need to be signed into a Github account).  Clone your fork with either:  git clone git@github.com:YOUR_USERNAME_HERE/computer-vision-bootcamp.git  if you want to use ssh\nor  git clone https://github.com/YOUR_USERNAME_HERE/computer-vision-bootcamp.git  for https  Note that you will need to have CMake installed so that you can build your module once you've written it.",
            "title": "1. Fork and Setup Local Project"
        },
        {
            "location": "/bootcamp/computer-vision/#2-code",
            "text": "Your task is to implement  merge sort  (or indeed a different sorting algorithm if you wish).  Your code must be implemented in a module (see the included core module for an example) and must:   Follow our  style guide  Build using CMake  Be well documented using doxygen-formatted comments  Be tested using  Boost Test   See  contributing  for an example and more information.  You are also welcome to implement something different if you want, but please run your idea by a computer-vision lead first.",
            "title": "2. Code"
        },
        {
            "location": "/bootcamp/computer-vision/#3-submit",
            "text": "To submit your bootcamp project you should create a pull request. Note that this does not mean you are done, we will review your pull request and give you feedback and you will be expected to update it so that if meets all requirements.  Once your pull request has been merged you are ready to work on the Computer Vision project.",
            "title": "3. Submit"
        },
        {
            "location": "/bootcamp/electrical/",
            "text": "\ufeff\n\n\nWARG Electrical Bootcamp\n\n\nIntroduction\n\n\nWelcome to the WARG's electrical bootcamp!\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\nIn this bootcamp you will learn how to do the following in KiCad:\n\n\n\n\nSearch digikey and select a component\n\n\nManage bill of materials (BOM) and the WARG component library\n\n\nMake a symbol or find symbol libraries\n\n\nEdit a schematic\n\n\nFind a footprint and map it to the part\n\n\nPlace and route a PCB\n\n\nExport gerbers\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. ZeroPilot DC/DC Buck Regulator\n\n\nBackground\n\n\nIn 2017 WARG started work on the new autopilot PCB, called ZeroPilot. With the new board comes a lot of tasks involving designing new circuits, converting circuits from Diptrace (our old software) to KiCad, and fixing bugs in various circuits. ZeroPilot is based off of STM microprocessors. It has a main processor called the autopilot controller which is a Cortex-M7 processor which handles most of our calculations. The board also has a secondary processor as a failsafe, which is called the safety controller. It allows us to confidently test new autopilot code since we can always switch into safety mode if there is an autopilot software error.\n\n\nThe ZeroPilot requires multiple voltages to power its various systems. There is the main battery which ranges from 7V-16V, and it has to be converted into 5V and 3.3V for different circuits.\n\n\nTask\n\n\nYour task is to replace the 3.3V regulator to power the main processors. Currently we use a linear regulator (commonly called an LDO) to convert 5V to 3.3V, but this is a very inefficient process, since input current = output current. Replacing the LDO with a buck regulator will save power by more efficiently converting voltage to 3.3V. It\u2019s helpful to know how buck regulators work but not required for the bootcamp\n\n\nReplace the LDO (WARG #REGU-002) with a buck regulator that you can find on digikey. The requirements for the buck regulator are listed below.\n\n\nRequirements\n\n\nBelow is a list of requirements for the buck regulator circuit:\n\n\n\n\nConvert Battery voltage (7V-16V) to 3.3V\n\n\nMust be able to supply at least 1A of current\n\n\nMust be cost effective\n\n\n\n\nSteps\n\n\nHere are the steps you are expected to take to complete this task.\n\n\n\n\n\n\nDownload and setup KiCad, Github, and the ZeroPilot repo. Fork and create a bootcamp branch of both github repos (ZeroPilot and WARG-KiCad).\n\n\n\n\n\n\nOpen the circuit editor and anaylze the current circuit. Identify the 3.3V regulator.\n\n\n\n\n\n\nFind a replacement buck regulator that meets the requirements above. Highly recommend using digikey to find the part.\n\n\n\n\n\n\nAdd the part to the compoent_library.csv in the WARG-KiCad repo and add an appropriate part number, digikey number, and other information to the csv.\n\n\n\n\n\n\nEither create or find a part symbol for the part you chose. Make sure the part is either in the default KiCad library or in WARG's symbol library (WARG-KiCad).\n\n\n\n\n\n\nRemove the 3.3V LDO from the schematic and replace it with the symbol you created. Add the necessary components (hint: there will likely be an inductor needed). Run a design rule check to make sure you don't have any errors.\n\n\n\n\n\n\nMake sure that the parameters of the parts are correct. Make sure every part has a WARG part number field.\n\n\n\n\n\n\nIf needed, create a footprint for the part. Most likely you will be able to find the footprint in KiCad's large library of footprints, but if you do have to create one make sure to save it to the WARG-KiCad repo. Map the footprint to the part you added in step 7.\n\n\n\n\n\n\nExport the netlist and import it into the PCB editor. Feel free to change the board outline to fit the bigger part, as we don't expect you to re-route the whole board to fit the component.\n\n\n\n\n\n\nAdd tracks to connect the components together. Look at the datasheet for a recommended layout pattern. Ensure that your traces are thick enough to handle the current that will be flowing through it. Also, make sure to update the copper pours to fit the new component and board outline.\n\n\n\n\n\n\nExport the gerbers into a zip file. These files are what are sent to the manufacturer to print the boards and stencils.\n\n\n\n\n\n\nSubmitting the bootcamp\n\n\nCreate a pull request (PR) to WARG github. Make sure to title your bootcamp PR in the format, \"Bootcamp: {name here}\". There should be 2 PRs, one for each repo (ZeroPilot and WARG-KiCad). The ZeroPilot PR should also include a zip file containing the manufacturing files. A team lead will review the PR within a few days and reply with approval or with some comments. The team lead will close the PR and not merge it when it is complete.\n\n\nResources\n\n\n\n\nZeroPilot repo\n\n\nKiCad library repo\n\n\nDigikey to find components\n\n\nKiCad Software\n\n\nKiCad Documentation\n\n\nKiCad getting started guide\n\n\nBootcamp channel on  \nslack\n to ask questions to team leads\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Electrical"
        },
        {
            "location": "/bootcamp/electrical/#warg-electrical-bootcamp",
            "text": "",
            "title": "WARG Electrical Bootcamp"
        },
        {
            "location": "/bootcamp/electrical/#introduction",
            "text": "Welcome to the WARG's electrical bootcamp!  WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.",
            "title": "Introduction"
        },
        {
            "location": "/bootcamp/electrical/#bootcamp-objectives",
            "text": "In this bootcamp you will learn how to do the following in KiCad:   Search digikey and select a component  Manage bill of materials (BOM) and the WARG component library  Make a symbol or find symbol libraries  Edit a schematic  Find a footprint and map it to the part  Place and route a PCB  Export gerbers",
            "title": "Bootcamp Objectives"
        },
        {
            "location": "/bootcamp/electrical/#bootcamp-outline",
            "text": "This Bootcamp has two options, both of which require a Team Leads approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.",
            "title": "Bootcamp Outline"
        },
        {
            "location": "/bootcamp/electrical/#1-zeropilot-dcdc-buck-regulator",
            "text": "",
            "title": "1. ZeroPilot DC/DC Buck Regulator"
        },
        {
            "location": "/bootcamp/electrical/#background",
            "text": "In 2017 WARG started work on the new autopilot PCB, called ZeroPilot. With the new board comes a lot of tasks involving designing new circuits, converting circuits from Diptrace (our old software) to KiCad, and fixing bugs in various circuits. ZeroPilot is based off of STM microprocessors. It has a main processor called the autopilot controller which is a Cortex-M7 processor which handles most of our calculations. The board also has a secondary processor as a failsafe, which is called the safety controller. It allows us to confidently test new autopilot code since we can always switch into safety mode if there is an autopilot software error.  The ZeroPilot requires multiple voltages to power its various systems. There is the main battery which ranges from 7V-16V, and it has to be converted into 5V and 3.3V for different circuits.",
            "title": "Background"
        },
        {
            "location": "/bootcamp/electrical/#task",
            "text": "Your task is to replace the 3.3V regulator to power the main processors. Currently we use a linear regulator (commonly called an LDO) to convert 5V to 3.3V, but this is a very inefficient process, since input current = output current. Replacing the LDO with a buck regulator will save power by more efficiently converting voltage to 3.3V. It\u2019s helpful to know how buck regulators work but not required for the bootcamp  Replace the LDO (WARG #REGU-002) with a buck regulator that you can find on digikey. The requirements for the buck regulator are listed below.",
            "title": "Task"
        },
        {
            "location": "/bootcamp/electrical/#requirements",
            "text": "Below is a list of requirements for the buck regulator circuit:   Convert Battery voltage (7V-16V) to 3.3V  Must be able to supply at least 1A of current  Must be cost effective",
            "title": "Requirements"
        },
        {
            "location": "/bootcamp/electrical/#steps",
            "text": "Here are the steps you are expected to take to complete this task.    Download and setup KiCad, Github, and the ZeroPilot repo. Fork and create a bootcamp branch of both github repos (ZeroPilot and WARG-KiCad).    Open the circuit editor and anaylze the current circuit. Identify the 3.3V regulator.    Find a replacement buck regulator that meets the requirements above. Highly recommend using digikey to find the part.    Add the part to the compoent_library.csv in the WARG-KiCad repo and add an appropriate part number, digikey number, and other information to the csv.    Either create or find a part symbol for the part you chose. Make sure the part is either in the default KiCad library or in WARG's symbol library (WARG-KiCad).    Remove the 3.3V LDO from the schematic and replace it with the symbol you created. Add the necessary components (hint: there will likely be an inductor needed). Run a design rule check to make sure you don't have any errors.    Make sure that the parameters of the parts are correct. Make sure every part has a WARG part number field.    If needed, create a footprint for the part. Most likely you will be able to find the footprint in KiCad's large library of footprints, but if you do have to create one make sure to save it to the WARG-KiCad repo. Map the footprint to the part you added in step 7.    Export the netlist and import it into the PCB editor. Feel free to change the board outline to fit the bigger part, as we don't expect you to re-route the whole board to fit the component.    Add tracks to connect the components together. Look at the datasheet for a recommended layout pattern. Ensure that your traces are thick enough to handle the current that will be flowing through it. Also, make sure to update the copper pours to fit the new component and board outline.    Export the gerbers into a zip file. These files are what are sent to the manufacturer to print the boards and stencils.",
            "title": "Steps"
        },
        {
            "location": "/bootcamp/electrical/#submitting-the-bootcamp",
            "text": "Create a pull request (PR) to WARG github. Make sure to title your bootcamp PR in the format, \"Bootcamp: {name here}\". There should be 2 PRs, one for each repo (ZeroPilot and WARG-KiCad). The ZeroPilot PR should also include a zip file containing the manufacturing files. A team lead will review the PR within a few days and reply with approval or with some comments. The team lead will close the PR and not merge it when it is complete.",
            "title": "Submitting the bootcamp"
        },
        {
            "location": "/bootcamp/electrical/#resources",
            "text": "ZeroPilot repo  KiCad library repo  Digikey to find components  KiCad Software  KiCad Documentation  KiCad getting started guide  Bootcamp channel on   slack  to ask questions to team leads",
            "title": "Resources"
        },
        {
            "location": "/bootcamp/electrical/#2-previous-team-contribution",
            "text": "If you have been on the team and feel that you have made a contribution significant to be exempt from the option 1 you can contact a Team Lead to explain, and preferably show the project you have done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.",
            "title": "2. Previous Team Contribution"
        },
        {
            "location": "/bootcamp/electrical/#completion-of-bootcamp",
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks with the team! If you have any feedback you would like to give to make this Bootcamp better please let a Team Lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Completion of Bootcamp"
        },
        {
            "location": "/bootcamp/groundstation/",
            "text": "WARG Groundstation Bootcamp\n\n\nIntroduction\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nBecome familiar with the Groundstation's underlying architecture\n\n\nLearn Javascript, Node.js,and NW.js\n\n\nGain a general understanding of web development\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\n1. Add an altitude dial to the groundstation:\n\n\nBackground\n\n\nThe groundstation receives telemetry data from the plane in real time. To do this, is creates a socket connection to the data relay\nstation, and listens to any data it sends. The point of the groundstation is to allow the ground control team to view the aircraft's\ncurrent position and orientation in real time, all the time. Raw data is hard to follow and track, and some forms of data are better\nrepresented visually.\n\n\nTask\n\n\nYou are tasked creating an altitude dial for the groundstation. This will involve adding a menu item to the application, which in turn\nwill open up a window that displays 2 things:\n\n\n\n\nThe text value of the altitude in meters (ie. 85.63m)\n\n\nA rectangular dial that changes its height based on the altitude of the aircraft\n\n\n\n\nRequirements\n\n\n\n\nThe rectangular dial's maximum height will correspond to the maximum height of the aircraft during the flight\n\n\nThe rectangular dial's color will change from red, to yellow, to green. These will be at 33% intervals of the maximum height. \nSo if for example, throughout the flight, the maximum height of the aircraft was 100m, then if the current height of the aircraft\nis less than 33m, the dial would be red. If its less than 66m it would be yellow, and if its greater it would be green.\n\n\nA maximum of 2 decimal places should be shown in the text of the altitude\n\n\n\n\nChecklist\n\n\n\n\nThere is new menu item under the ground station's Window menu\n\n\nThe menu item opens up a new window, that uses a custom view to display the aircraft's altitude\n\n\nThere is a sensible amount of comments in the code\n\n\nAny custom functions and modules were documented using JSDOC syntax. Read \nhere\n for more info.\n\n\n\n\nNote: It is \nHIGHLY\n reccommended that you read the \ngroundstation tutorial\n.\n\n\nHints\n\n\n\n\nThe \nTelemetryData\n module is the module responsible for sending out telemetry data about the plane\n\n\nThe datalink documentation (the data the groundstation received) can be found \nhere\n\n\nThe \nAltitudeView.js\n file is the view responbile for displaying the circular altitude dial in the groundstation. Its a very good\nreference\n\n\nThe groundstation does nothing until it starts receiving data. To have it receive data, open up the Simulation window and start a simulation\n\n\nWhen you an element under the \nui\n property of the view, \nthis.ui.element_name\n is a jquery wrapper for that element, \nso you can use jquery methods on it to manipulate it (say for example changing its color or height)\n\n\nAdditional resources on the groundstation, including its documentation can be found \nhere\n\n\n\n\nNOTE:\n Don't worry if you're unfamiliar with javascript or if these hints made no sense to you. If you read the \ngroundstation documentation\n and just dive right in, you'll get the hang of it eventually.\n\n\nGit\n\n\nWe suggest making a seperate branch on git to do your bootcamp. Making a pull request is not necessary after the completion of your bootcamp, simply show your work the responsible team lead.\n\n\nExample:\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have worked on the Groundstation before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the groundstation. If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Groundstation"
        },
        {
            "location": "/bootcamp/groundstation/#warg-groundstation-bootcamp",
            "text": "",
            "title": "WARG Groundstation Bootcamp"
        },
        {
            "location": "/bootcamp/groundstation/#introduction",
            "text": "WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.",
            "title": "Introduction"
        },
        {
            "location": "/bootcamp/groundstation/#bootcamp-objectives",
            "text": "Become familiar with the Groundstation's underlying architecture  Learn Javascript, Node.js,and NW.js  Gain a general understanding of web development",
            "title": "Bootcamp Objectives"
        },
        {
            "location": "/bootcamp/groundstation/#bootcamp-outline",
            "text": "This Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.",
            "title": "Bootcamp Outline"
        },
        {
            "location": "/bootcamp/groundstation/#1-add-an-altitude-dial-to-the-groundstation",
            "text": "",
            "title": "1. Add an altitude dial to the groundstation:"
        },
        {
            "location": "/bootcamp/groundstation/#background",
            "text": "The groundstation receives telemetry data from the plane in real time. To do this, is creates a socket connection to the data relay\nstation, and listens to any data it sends. The point of the groundstation is to allow the ground control team to view the aircraft's\ncurrent position and orientation in real time, all the time. Raw data is hard to follow and track, and some forms of data are better\nrepresented visually.",
            "title": "Background"
        },
        {
            "location": "/bootcamp/groundstation/#task",
            "text": "You are tasked creating an altitude dial for the groundstation. This will involve adding a menu item to the application, which in turn\nwill open up a window that displays 2 things:   The text value of the altitude in meters (ie. 85.63m)  A rectangular dial that changes its height based on the altitude of the aircraft",
            "title": "Task"
        },
        {
            "location": "/bootcamp/groundstation/#requirements",
            "text": "The rectangular dial's maximum height will correspond to the maximum height of the aircraft during the flight  The rectangular dial's color will change from red, to yellow, to green. These will be at 33% intervals of the maximum height. \nSo if for example, throughout the flight, the maximum height of the aircraft was 100m, then if the current height of the aircraft\nis less than 33m, the dial would be red. If its less than 66m it would be yellow, and if its greater it would be green.  A maximum of 2 decimal places should be shown in the text of the altitude",
            "title": "Requirements"
        },
        {
            "location": "/bootcamp/groundstation/#checklist",
            "text": "There is new menu item under the ground station's Window menu  The menu item opens up a new window, that uses a custom view to display the aircraft's altitude  There is a sensible amount of comments in the code  Any custom functions and modules were documented using JSDOC syntax. Read  here  for more info.   Note: It is  HIGHLY  reccommended that you read the  groundstation tutorial .",
            "title": "Checklist"
        },
        {
            "location": "/bootcamp/groundstation/#hints",
            "text": "The  TelemetryData  module is the module responsible for sending out telemetry data about the plane  The datalink documentation (the data the groundstation received) can be found  here  The  AltitudeView.js  file is the view responbile for displaying the circular altitude dial in the groundstation. Its a very good\nreference  The groundstation does nothing until it starts receiving data. To have it receive data, open up the Simulation window and start a simulation  When you an element under the  ui  property of the view,  this.ui.element_name  is a jquery wrapper for that element, \nso you can use jquery methods on it to manipulate it (say for example changing its color or height)  Additional resources on the groundstation, including its documentation can be found  here   NOTE:  Don't worry if you're unfamiliar with javascript or if these hints made no sense to you. If you read the  groundstation documentation  and just dive right in, you'll get the hang of it eventually.",
            "title": "Hints"
        },
        {
            "location": "/bootcamp/groundstation/#git",
            "text": "We suggest making a seperate branch on git to do your bootcamp. Making a pull request is not necessary after the completion of your bootcamp, simply show your work the responsible team lead.",
            "title": "Git"
        },
        {
            "location": "/bootcamp/groundstation/#example",
            "text": "",
            "title": "Example:"
        },
        {
            "location": "/bootcamp/groundstation/#2-previous-team-contribution",
            "text": "If you have worked on the Groundstation before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.",
            "title": "2. Previous Team Contribution"
        },
        {
            "location": "/bootcamp/groundstation/#completion-of-bootcamp",
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the groundstation. If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Completion of Bootcamp"
        },
        {
            "location": "/bootcamp/embedded/",
            "text": "WARG Embedded Software Bootcamp\n\n\nIntroduction\n\n\nWelcome to the Embedded Software Bootcamp!\n\n\nWARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.\n\n\nBootcamp Objectives\n\n\n\n\nLearn C, and become familiar with some of the concepts in embedded programming\n\n\nLearn the underlying PicPilot(autopilot) code structure\n\n\nLearn how to track code revisions and perform code reviews via Git\n\n\n\n\nBootcamp Outline\n\n\nThis Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.\n\n\nNote\n: \nThis will vary depending on your expirience level in programming. This is a rough estimate and don't get discouraged if it takes you longer!\n\n\n1. Add a drop and snap command to the picpilot:\n\n\nBackground\n\n\nThe groundstation is the main line of communication between the aircraft and the ground control crew. Even though the aircraft is completely autonomous, someone's got to tell it what to do and where to go.\n\n\nThe aircraft's autopilot (called the PicPilot) is what manages the communication to the groundstation from the aircraft. The groundstation communicates with the plane by sending it integer-based commmands, through the XBee data link. The autopilot interprets the command, and can choose to perform a certain action in response.\n\n\nThe aircraft is also equipped with 2 modules for the purposes of the competition. A go pro camera attached the front of the aircraft for taking aerial photos, and a probe drop module that's capable of dropping its payload.\n\n\nTask\n\n\nThe groundstation operator has to be able to send a command to drop the probe, which involves actuating a servo using PWM. There are 3 probe drops, so you will have to write some code to manage the 3 separate servos.\n\n\nThe command will be a multi-part command. The first part will tell the autopilot which servo to operate (1,2, or 3), and the second part will tell the autopilot what position the servo should be in (opened or closed). All servos should be closed on startup.\n\n\nYou are tasked with implementing this feature for the autopilot.\n\n\nHints\n\n\n\n\nBecause of resource constraints, you will not have the ability to actually test the code. Just make sure it compiles\n\n\nUse the PWM.c file to actuate the servo. Set reasonable constants for minimum and maximum PWM for the probe drop servo.\n\n\nMake sure you use a PWM channel that is currently not in use, and make sure to initialize it when the vehicle arms.\n\n\nYou can name the command whatever you want, but it has to be sensible and match the already existing command naming convention\n\n\nFeel free to use the existing code as reference\n\n\nThe datalink documentation (the data the groundstation received) can be found \nhere\n\n\n\n\nInstallation\n\n\nTo install the IDE and compiler, go to the \nPICPilot documentation\n. \n\n\nTo get the codebase, fork the repository from Github from \nGithub\n. You will have to fork the repository to make your changes. Also its recommended that you make your own branch. If you don't know what git or github is, or how to use it, please read this \ngit and github tutorial\n that we wrote.\n\n\nSubmission\n\n\nTo submit your work, create a pull request of your fork against the main PicPilot repository. Name your pull request \nBootcamp by YOURNAME\n. Tell the responsible team lead that you've completed the bootcamp and they will review your submission. You may be asked to revise some things.\n\n\nNote\n: \nIf you would really like to test out the code, come to one of the work days and we'll show  you how to program the picpilot and actually test it out\n\n\nAdditional Resources\n\n\n\n\nYour most valuable resource will be our \npicpilot documentation\n\n\nOur Git Tutorial\n\n\nDatalink Documentation\n\n\nSparkfun Embedded Electronics Tutorial\n\n\n\n\n2. Previous Team Contribution\n\n\nIf you have worked on the PicPilot before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.\n\n\nCompletion of Bootcamp\n\n\nUpon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the picpilot! If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Embedded Software"
        },
        {
            "location": "/bootcamp/embedded/#warg-embedded-software-bootcamp",
            "text": "",
            "title": "WARG Embedded Software Bootcamp"
        },
        {
            "location": "/bootcamp/embedded/#introduction",
            "text": "Welcome to the Embedded Software Bootcamp!  WARG members often find that joining this team requires more knowledge and has a larger learning curve than other student teams. Once members have acquired this knowledge they gain a lot of confidence and are able to make large contributions to the team. Therefore, this Bootcamp is designed as a first task to be completed to both help you through the learning curve, while giving you a project that is fully your own. The hope is that once you complete this Bootcamp you will feel confident and hopefully have acquired enough skills such that you are ready to take on tasks with our aircraft! Just a quick disclaimer, this Bootcamp will help accelerate and minimize the learning curve but it will not give you all knowledge. The remaining knowledge will be acquired through completing other tasks with the team.",
            "title": "Introduction"
        },
        {
            "location": "/bootcamp/embedded/#bootcamp-objectives",
            "text": "Learn C, and become familiar with some of the concepts in embedded programming  Learn the underlying PicPilot(autopilot) code structure  Learn how to track code revisions and perform code reviews via Git",
            "title": "Bootcamp Objectives"
        },
        {
            "location": "/bootcamp/embedded/#bootcamp-outline",
            "text": "This Bootcamp has two options, both of which require a team lead's approval of completion in order to move onto working on other tasks. The estimated time of completion for this Bootcamp is 1 week.  Note :  This will vary depending on your expirience level in programming. This is a rough estimate and don't get discouraged if it takes you longer!",
            "title": "Bootcamp Outline"
        },
        {
            "location": "/bootcamp/embedded/#1-add-a-drop-and-snap-command-to-the-picpilot",
            "text": "",
            "title": "1. Add a drop and snap command to the picpilot:"
        },
        {
            "location": "/bootcamp/embedded/#background",
            "text": "The groundstation is the main line of communication between the aircraft and the ground control crew. Even though the aircraft is completely autonomous, someone's got to tell it what to do and where to go.  The aircraft's autopilot (called the PicPilot) is what manages the communication to the groundstation from the aircraft. The groundstation communicates with the plane by sending it integer-based commmands, through the XBee data link. The autopilot interprets the command, and can choose to perform a certain action in response.  The aircraft is also equipped with 2 modules for the purposes of the competition. A go pro camera attached the front of the aircraft for taking aerial photos, and a probe drop module that's capable of dropping its payload.",
            "title": "Background"
        },
        {
            "location": "/bootcamp/embedded/#task",
            "text": "The groundstation operator has to be able to send a command to drop the probe, which involves actuating a servo using PWM. There are 3 probe drops, so you will have to write some code to manage the 3 separate servos.  The command will be a multi-part command. The first part will tell the autopilot which servo to operate (1,2, or 3), and the second part will tell the autopilot what position the servo should be in (opened or closed). All servos should be closed on startup.  You are tasked with implementing this feature for the autopilot.",
            "title": "Task"
        },
        {
            "location": "/bootcamp/embedded/#hints",
            "text": "Because of resource constraints, you will not have the ability to actually test the code. Just make sure it compiles  Use the PWM.c file to actuate the servo. Set reasonable constants for minimum and maximum PWM for the probe drop servo.  Make sure you use a PWM channel that is currently not in use, and make sure to initialize it when the vehicle arms.  You can name the command whatever you want, but it has to be sensible and match the already existing command naming convention  Feel free to use the existing code as reference  The datalink documentation (the data the groundstation received) can be found  here",
            "title": "Hints"
        },
        {
            "location": "/bootcamp/embedded/#installation",
            "text": "To install the IDE and compiler, go to the  PICPilot documentation .   To get the codebase, fork the repository from Github from  Github . You will have to fork the repository to make your changes. Also its recommended that you make your own branch. If you don't know what git or github is, or how to use it, please read this  git and github tutorial  that we wrote.",
            "title": "Installation"
        },
        {
            "location": "/bootcamp/embedded/#submission",
            "text": "To submit your work, create a pull request of your fork against the main PicPilot repository. Name your pull request  Bootcamp by YOURNAME . Tell the responsible team lead that you've completed the bootcamp and they will review your submission. You may be asked to revise some things.  Note :  If you would really like to test out the code, come to one of the work days and we'll show  you how to program the picpilot and actually test it out",
            "title": "Submission"
        },
        {
            "location": "/bootcamp/embedded/#additional-resources",
            "text": "Your most valuable resource will be our  picpilot documentation  Our Git Tutorial  Datalink Documentation  Sparkfun Embedded Electronics Tutorial",
            "title": "Additional Resources"
        },
        {
            "location": "/bootcamp/embedded/#2-previous-team-contribution",
            "text": "If you have worked on the PicPilot before, and feel that you've made a significant enough contribution to be exempt from option 1, you can contact the responsible team lead to explain, and preferably show what you've done. It will be up to the Team Lead\u2019s discretion whether you qualify to be exempt from the Bootcamp. If the Team Lead feels that you should still complete option 1 it is because they think you can learn and gain skills from the completion of the Bootcamp.",
            "title": "2. Previous Team Contribution"
        },
        {
            "location": "/bootcamp/embedded/#completion-of-bootcamp",
            "text": "Upon the approved completion of the Bootcamp by a Team Lead you are now eligible to work on other tasks related to the picpilot! If you have any feedback you would like to give to make this Bootcamp better please let a team lead know as we want this to be the best and most informative introduction to the team as possible.",
            "title": "Completion of Bootcamp"
        },
        {
            "location": "/bootcamp/rccompetition/",
            "text": "RC Car Competition\n\n\nDesigned by Students, For Students\n\n\n\n\nCompetition Sign Up Deadline\n : Continuous\u2026. Come Join!\n\n\nCompetition Showcase Date:\n Saturday March 21\n\n\nst\n\n\n2014 (Tentative)\n\n\nThe Waterloo Aerial Robotics Group \u2013 RC Car Competition\n\n\nBackground\n\n\nThe goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.\n\n\nThis competition has been developed by WARG as a tool to teach students about the following:\n\n\n\n\n\uf0b7\uf0b7Basic Programming Skills\n\n\n\uf0b7\uf0b7Control Theory\n\n\n\uf0b7\uf0b7Problem Solving\n\n\n\uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)\n\n\n\uf0b7\uf0b7Path Following and Path Planning\n\n\n\n\nAt the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.\n\n\nFurthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.\n\n\nThe end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.\n\n\nRegistration Fee\n\n\n*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.\n\n\nThe Competition\n\n\nIn teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.\n\n\n* Note that individual sign up is more than welcome, and teams of individuals will be generated\n\n\nThe competition will be graded as follows:\n\n\n\n\n\n\n\n\nPhase\n\n\nTask\n\n\nSkills Acquired\n\n\nWeighting\n\n\n\n\n\n\n\n\n\n\nl\n\n\n-Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec\n\n\nCan you \ncall\n a function?Can you make a loop?\n\n\n2.5% each(10% total)\n\n\n\n\n\n\nll\n\n\n-Drive Forward 10m-Drive Backward 10m\n\n\nCan you \nmake\n a function?\n\n\n5% each(10% total)\n\n\n\n\n\n\nlll\n\n\n-Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees\n\n\nCan you think in terms of Heading?\n\n\n15%\n\n\n\n\n\n\nlV\n\n\n-Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m\n\n\nCan you put everything together and create a Control Program?\n\n\n15%\n\n\n\n\n\n\nV\n\n\n-Drive from Point A to Point B   Stop within a _(5)_m Radius\n\n\n15%\n\n\n\n\n\n\n\n\nVl\n\n\nFollow _(10)_ Waypoints\n\n\n35%\n\n\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\n--Basic programming concepts will be explained to new recruits in order to help them succeed\n\n\n--Values given in the _(Value)_ form are tentative and subject to change\n\n\n--Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)\n\n\n--Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams\n\n\n--The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)\n\n\n\n\nTerminology:\n\n\n\n\n--Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)\n\n\n--Waypoint: a GPS coordinate described by a Latitude and a Longitude\n\n\n\n\nWhat You Need To Know\n\n\nThere are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.\n\n\nWhat to Download\n\n\nWARG has created presentational step-by-step presentations to help you setup the programs needed:\n\n\nMPLAB X:  (required)\n\n\nhttps://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing\n\n\nThis is the IDE used to program the chip on the RC Car\n\n\nGithub:\n  \n(optional)\n\n\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\n*Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.\n\n\n*If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.\n\n\nWhere to Get the Code (GitHub)\n\n\nThe following link is where you can download the base project for the RC Car Competition:\n\n\nhttps://github.com/UWARG/RC-Car-Bootstrap-Competition\n\n\nOn the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.\n\n\n*Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build & Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.\n\n\nFunctionality Developed by WARG for You to Use\n\n\nWARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.\n\n\nWARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:\n\n\nsetSteering(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.\n\n\nsetThrottle(int percent);\n\n\nThis function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.\n\n\ngetTime();\n\n\nThis function returns the time in milliseconds as type \nlong int\n, the function takes no inputs.\n\n\nYou are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:\n\n\nGPS.latitude;     // the current latitude as type \nlong double\n\n\nGPS.longitude;     // the current latitude as type \nlong double\n\n\nGPS.speed;           // the current ground speed as type \nfloat\n\n\nGPS.heading;       // the current heading as type \nint\n\n\nGPS.satellites;     // the current number of satellites as type \nchar\n\n\nGPS.positionFix;  // if there is a position fix or not as type \nchar\n\n\nGPS.altitude;        // the current altitude as type \nint\n\n\nWhere You Program in the Code\n\n\nWhen you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.\n\n\n\n\nYou will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.\n\n\nThe code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.\n\n\nAspects of Programming (Super Simplified)\n\n\n***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.\n\n\nFor any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!\n\n\nProgramming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple\n\n\nYou will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.\n\n\nMoving on, here is a REALLY REALLY simplified generalization of some programming concepts.\n\n\nVariables\n\n\nYou can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:\n\n\n\"Let x be the number of apples Brian has on Monday\"\n\n\nVariables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable \ntypes\n:\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nint\n\n\nCan be thought of as a \nwhole\n number, or a number \nwithout\n decimals\n\n\n1,  16,  3054\n\n\n\n\n\n\nfloat\n\n\nCan be thought of as a number \nwith\n decimals\n\n\n1.02,  506.23579\n\n\n\n\n\n\n\n\nYou totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an \nArray\n. An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.\n\n\nIn order to initialize your variables in your program, you would do as such:\n\n\nint x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0\n\n\nfloat myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34\n\n\nint myArray[5];  //Declaration of an array (un-initialized)\u2026\n\n\n\u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything\n\n\nYou would then later access individual members of the array by doing the following:\n\n\nmyArray[0] = 8; //This sets the first member in the list to hold a value of 8\n\n\nPiece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.\n\n\n*** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"\n\n\nYou'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n  -- Specifically:\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson2.html\n  // if statements\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson3.html\n  // looping\n\n\nhttp://www.cprogramming.com/tutorial/c/lesson4.html\n  // functions\n\n\nOr more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you: \nhttp://lmgtfy.com/?q=c+tutorial\n\n\nPhase Definitions\n\n\nThis section of the document is meant to further define what is required, and expected for each Phase of the competition.\n\n\nPhase I\n\n\nPurpose:\n\n\nAllow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward for 10 seconds\n\n\n\uf0b7\uf0b7Drive Backward for 10 seconds\n\n\n\uf0b7\uf0b7Turn Right for 10 seconds\n\n\n\uf0b7\uf0b7Turn Left for 10 seconds\n\n\n\n\nExplanation:\n\n\nThis phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n2.5% will be given per each of the 4 tasks\n\n\nIt is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nPhase II\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 10 meters\n\n\n\uf0b7\uf0b7Drive Backward 10 meters\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).\n\n\nYour function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:\n\n\nhttp://www.movable-type.co.uk/scripts/latlong.html\n\n\n\n\nAbove is the formula you must program into your function.\n\n\nBelow is how the created such a function with Java Script. *** Your function should return a float of \"d\"\n\n\n\n\nvar R =6371;// km\n\n\nvar\u03c61= lat1.toRadians();\n\n\nvar\u03c62= lat2.toRadians();\n\n\nvar\u0394\u03c6=(lat2-lat1).toRadians();\n\n\nvar\u0394\u03bb=(lon2-lon1).toRadians();\n\n\nvar a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+\n\n\n    Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);\n\n\n\nvar c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));\n\n\nvar d = R * c;\n\n\n\n\nThe only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.\n\n\nEvaluation and Weighting:  \n 10% in total for the phase\n\n\n5% will be given per each of the 2 tasks\n\n\nInitially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.\n\n\nFurthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).\n\n\nPlease note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.\n\n\nPhase III\n\n\nPurpose:\n\n\nThe initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive Forward 5 meters, then\n\n\nooTurn Right 90 degrees, then\n\n\nooTurn Left 90 degrees\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.\n\n\nAt no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\n12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.\n\n\nInitially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.\n\n\nPhase IV\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive a straight line\n\n\nooWhile maintaining heading\n\n\nooStop after _(100)_m\n\n\n\n\nExplanation:\n\n\nIn this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).\n\n\nYou will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must \nconverge\n towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the \ncontrol loop\n, and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).\n\n\nPlease refer to the \nControl Theory\n section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.\n\n\nEvaluation and Weighting:  \n 15% in total for the phase\n\n\nConsidering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.\n\n\nWith this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.\n\n\nPhase V\n\n\nPurpose:\n\n\nThe purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Drive from Point A to Point B\n\n\nooStop within a _(5)_m radius\n\n\n\n\nExplanation:\n\n\nThe functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.\n\n\nYou'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.\n\n\nOn competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.\n\n\nWARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.\n\n\n*Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.\n\n\nEvaluation and Weighting:\n   15% in total for the phase\n\n\n10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.\n\n\nPhase VI\n\n\nPurpose:\n\n\nThe purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).\n\n\nRequired Tasks:\n\n\n\n\n\uf0b7\uf0b7Follow a set of _(10)_ Waypoints\n\n\n\n\nExplanation:\n\n\nAt this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.\n\n\nWaypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.\n\n\nEvaluation and Weighting:  \n 35% in total for the phase\n\n\n34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.\n\n\nThe additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.\n\n\nOnce again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.",
            "title": "RC Car Competition"
        },
        {
            "location": "/bootcamp/rccompetition/#rc-car-competition",
            "text": "",
            "title": "RC Car Competition"
        },
        {
            "location": "/bootcamp/rccompetition/#designed-by-students-for-students",
            "text": "Competition Sign Up Deadline  : Continuous\u2026. Come Join!  Competition Showcase Date:  Saturday March 21",
            "title": "Designed by Students, For Students"
        },
        {
            "location": "/bootcamp/rccompetition/#st",
            "text": "2014 (Tentative)  The Waterloo Aerial Robotics Group \u2013 RC Car Competition",
            "title": "st"
        },
        {
            "location": "/bootcamp/rccompetition/#background",
            "text": "The goal of the RC Car competition is to motivate potential recruits to participate in the normal activities of the Waterloo Aerial Robotics Group (WARG). The team leads of WARG have come to realize that it can be difficult for recruits to immediately jump into the day-to-day activities of WARG without having any prior knowledge or experience with the technology. It's a very common occurrence for new recruits to come to the team with very little to no knowledge of the skills needed to immediately contribute, but WARG has a fundamental goal of teaching any student the skills, if they wish to learn.  This competition has been developed by WARG as a tool to teach students about the following:   \uf0b7\uf0b7Basic Programming Skills  \uf0b7\uf0b7Control Theory  \uf0b7\uf0b7Problem Solving  \uf0b7\uf0b7Gain Tuning (Stabilizing a Controlled System)  \uf0b7\uf0b7Path Following and Path Planning   At the end of the competition, it is WARG's goal that each participating student has learned how to perform a majority of the topics listed above. The competition has been designed to guide the recruits through the process, and for this reason, each phase of the competition relies on the previous phase to a certain extent. In other words, as the recruit proceeds through each phase of the competition, they are in fact building further upon their control program. Once the last phase is reached, the recruit should have a fully functional control program. How well this program functions will be based on the recruits time, effort, and general understanding of the skills WARG is trying to teach over the course of the competition.  Furthermore, the skills that students develop while participating in this competition can be immediately transferred to the normal activities of WARG. As well, these newly acquired skills can be advertised by the students during interviews, where they can inform the employer on what they've accomplished while participating in the competition.  The end goal of the competition is to develop a program that will make the RC Car autonomously follow a predetermined path. This is in fact exactly what is done by our airplane (SPIKE) in order to complete its competition. Our aircraft can always be improved upon, and it is our hope that students become interested in assisting the team with the skills they acquire through this competition.",
            "title": "Background"
        },
        {
            "location": "/bootcamp/rccompetition/#registration-fee",
            "text": "*** There will be a $5 fee in order to sign up for the competition, but the amount of money gathered by WARG will simply be put back to the participating students registered in the competition. To be an \"official\" member of WARG, the constitution of the team states that each member must pay an initial $5 fee. In order to incorporate this fee, as well as make the competition day a little more enticing, WARG is using this collection for the sole purpose of buying items such as pizza, pop, snacks, etc. for the final Competition Showcase Day.",
            "title": "Registration Fee"
        },
        {
            "location": "/bootcamp/rccompetition/#the-competition",
            "text": "In teams of 3 or 4 (ideally), students will compete to control a remote control (RC) car that has been outfitted by WARG to have autonomous capabilities. Each team will be competing against the others for a prize pool (prizes to be determined and announced based on participation), where the top 3 teams will be rewarded respectively.  * Note that individual sign up is more than welcome, and teams of individuals will be generated  The competition will be graded as follows:     Phase  Task  Skills Acquired  Weighting      l  -Drive Forward 10sec-Drive Backward 10sec-Turn Right 10sec-Turn Left 10sec  Can you  call  a function?Can you make a loop?  2.5% each(10% total)    ll  -Drive Forward 10m-Drive Backward 10m  Can you  make  a function?  5% each(10% total)    lll  -Drive Forward 5m,   then Turn Right 90 degrees   then Turn Left 90 degrees  Can you think in terms of Heading?  15%    lV  -Drive a Straight Line   while Maintaining Heading   Stop after _(100)_m  Can you put everything together and create a Control Program?  15%    V  -Drive from Point A to Point B   Stop within a _(5)_m Radius  15%     Vl  Follow _(10)_ Waypoints  35%      Notes:   --Basic programming concepts will be explained to new recruits in order to help them succeed  --Values given in the _(Value)_ form are tentative and subject to change  --Phases 1 and 3: marks are awarded based on performance of the described task, not preciseness to the defined values (i.e. if you turn further than 90deg we will not punish you, but you must turn at least 90deg)  --Phases 2, 4, 5, 6, 7, 8: will be marked based on your team's error, relative to the other teams  --The system has been set up to relay GPS information back to WARG, we will use this information to determine your error in accordance to the given task. This eliminates discrepancy with regards to GPS drift (i.e. if we were to mark a GPS coordinate on the ground and say \"go here,\" the GPS may think that spot is in two different locations based on the number of satellites it has at that given time)   Terminology:   --Heading: a 360 degree value of the direction to North (basically like a compass with N = 0deg and 360deg, E = 90deg, S = 180deg, and W = 270deg)  --Waypoint: a GPS coordinate described by a Latitude and a Longitude",
            "title": "The Competition"
        },
        {
            "location": "/bootcamp/rccompetition/#what-you-need-to-know",
            "text": "There are a few things you'll need to know and understand (other than basic programming concepts) in order to control the RC Car.",
            "title": "What You Need To Know"
        },
        {
            "location": "/bootcamp/rccompetition/#what-to-download",
            "text": "WARG has created presentational step-by-step presentations to help you setup the programs needed:  MPLAB X:  (required)  https://docs.google.com/presentation/d/1XvRea8qPeCgIOqU_4q_P-z-q1EOupfJyO801Is2gDz4/edit?usp=sharing  This is the IDE used to program the chip on the RC Car  Github:    (optional)  https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  *Please note that the Github presenation presentation might be out of date, but the same concepts will apply in order to get it setup on your system. Contrary, you might not need to download the desktop client, and can simple get the RC-Car-Bootstrap-Competition project as a .ZIP, in which case you can place it where you want and open the Project from MPLAB.  *If you choose to use Github, you DO NOT need a UWARG member to add you to the group. Since the project is Public, anyone can view and download the RC-Car-Bootstrap in order to start programming. See the next section for instructions on how to do so.",
            "title": "What to Download"
        },
        {
            "location": "/bootcamp/rccompetition/#where-to-get-the-code-github",
            "text": "The following link is where you can download the base project for the RC Car Competition:  https://github.com/UWARG/RC-Car-Bootstrap-Competition  On the right side of the screen, select \"Download ZIP.\" Place the unzipped folder somewhere on your computer for you to access. Open this folder as a Project in MPLAB X, and you should be ready to start coding.  *Note: A presentation may be created later to teach people how to use MPLAB X, but if you start typing some code and want to test that it compiles (i.e. you've created correct code), then you may press the \"Build & Clean\" button to initially test the program. It should tell you if there are any errors with your code, or something that it doesn't understand.",
            "title": "Where to Get the Code (GitHub)"
        },
        {
            "location": "/bootcamp/rccompetition/#functionality-developed-by-warg-for-you-to-use",
            "text": "WARG has developed a bunch of functions that perform hardware communication with the car. This means that the recruits do not need to understand how to truly talk to the devices, but instead can program the system at a much higher level. What this means is something similar to the following comparison. Somebody tells you to shout \"Hello!\" You don't truly think about the fact that all those fancy biology components in your body are doing things, and somehow in the end\u2026. magical noise comes from your mouth. What happened is that somebody gave you a command at a \"higher level,\" your brain then took that command and did the appropriate things without you truly knowing what's going on, in order to make \"Hello!\" come from your mouth. Might be a weird analogy yes, but that's similar to what's going on in the code.  WARG has given you the following functions to work with. They must have the specified inputs, and they perform the specified actions:  setSteering(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100.    With -100 turning the wheels fully to the left, and 100 turning the wheels fully to the right.  setThrottle(int percent);  This function does exactly what you think it does. It takes an int value input ranging from -100 to 100. With -100 being full speed in reverse, and 100 being full speed forward.  getTime();  This function returns the time in milliseconds as type  long int , the function takes no inputs.  You are also given a struct to work with that holds and updates all of the appropriate GPS Data. In order to access this information, simply type \"GPS.______\" where the ____ is filled appropriately as follows:  GPS.latitude;     // the current latitude as type  long double  GPS.longitude;     // the current latitude as type  long double  GPS.speed;           // the current ground speed as type  float  GPS.heading;       // the current heading as type  int  GPS.satellites;     // the current number of satellites as type  char  GPS.positionFix;  // if there is a position fix or not as type  char  GPS.altitude;        // the current altitude as type  int",
            "title": "Functionality Developed by WARG for You to Use"
        },
        {
            "location": "/bootcamp/rccompetition/#where-you-program-in-the-code",
            "text": "When you download all of the required programs, and get the RC-Car-Bootstrap from Github, you will see the following code segment in the main.c file.   You will notice that there is already some code in the main body\u2026. YOU MUST LEAVE THIS THERE.  The code that exists is there to initialize the system and ensure it is running properly. As well, it performs all of our background tasks that send data do us about what your system is doing at the moment. All of your code must take place after \"setSteering(0);\" and before \"background();.\" Please note that this is meant by your code in the main function of your program, later on in the phases, you will be required to develop your own functions, which must be developed outside of this main.",
            "title": "Where You Program in the Code"
        },
        {
            "location": "/bootcamp/rccompetition/#aspects-of-programming-super-simplified",
            "text": "***WARNING: THIS SECTION IS NOT COMPLETED, AND YOU'LL NEED TO KNOW A FEW MORE THINGS THAN WHAT IS DESCRIBED HERE. FOLLOW THE PROVIDED TUTORIAL LINKS TO HELP YOU LEARN FOR THE TIME BEING.  For any recruit who is nervous, unsure, or thinking twice about joining the competition due to not having prior (or having minimal) knowledge of programming, WARG would like to motivate you to get past that fear. SO GET MOTIVATED!!!  Programming may take a little bit in order for the concepts to finally \"click,\" but once you grasp it\u2026     \u2026it all seems so simple  You will be programming in a language known as C. Just as there are multiple verbal languages (i.e. English, French, Spanish, etc.), there are a bunch of programming languages. These programming languages are a lot easier to transition between and pick up if you know one of the languages, in comparison to verbal languages.  Moving on, here is a REALLY REALLY simplified generalization of some programming concepts.",
            "title": "Aspects of Programming (Super Simplified)"
        },
        {
            "location": "/bootcamp/rccompetition/#variables",
            "text": "You can think of variables just like the ones you'd use in math, by this we mean that they can be seen as \"place holders\" for a value. Meaning that in math you may declare:  \"Let x be the number of apples Brian has on Monday\"  Variables in programming are similar, and are place holders for actual values. These values are hidden away and saved somewhere in the microchip (in memory\u2026. but we don't need to know about this right now). Here are a couple examples of variable  types :     Type  Description  Example      int  Can be thought of as a  whole  number, or a number  without  decimals  1,  16,  3054    float  Can be thought of as a number  with  decimals  1.02,  506.23579     You totally thought the list was going to be longer didn't you. Well, technically it is quite a bit larger yes, but in all honesty you could write the whole code for the competition using just these variables and you would be fine. With that said, you might want to utilize something known as an  Array . An array can be thought of as a list of a certain type of variable. If you want to save data on a few things that may relate, or be of similar characteristic, to one another\u2026 you may want to put them into a list.  In order to initialize your variables in your program, you would do as such:  int x = 0;    //This means that you've declared a new variable \"x\", that is of type int, and has starting value 0  float myFloat = 2.34; //a new variable \"myFloat\", of type float, with starting value 2.34  int myArray[5];  //Declaration of an array (un-initialized)\u2026  \u2026This means that you've declared an array of 5 int variables (i.e. there is a list of 5 int's), you've called this array \"myArray\", and you did not initialize the values to anything  You would then later access individual members of the array by doing the following:  myArray[0] = 8; //This sets the first member in the list to hold a value of 8  Piece of cake right? No? Well that's ok, because it took some of the Lead members of WARG a little while to truly get a grasp as well.  *** Obviously there's more to programming then just declaring variables, and WARG is currently in the process of writing this document to better help recruits get involved! For the time being, please look at the following tutorials online regarding basic C programming. There's lots of things on the internet if you use that thing\u2026. what are the kids calling it? \"The Google?\"  You'll need to know about \"if\" statements, \"while\" loops, and possible \"for\" loops in order to successfully complete the phases in the competition. Here are a few useful links to help you:  http://www.cprogramming.com/tutorial/c/lesson1.html   -- Specifically:  http://www.cprogramming.com/tutorial/c/lesson2.html   // if statements  http://www.cprogramming.com/tutorial/c/lesson3.html   // looping  http://www.cprogramming.com/tutorial/c/lesson4.html   // functions  Or more importantly for now (considering we're still developing this document), in order to be a part of any student team, you need to be able to research. Therefore the following is the most important link we can give you:  http://lmgtfy.com/?q=c+tutorial",
            "title": "Variables"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-definitions",
            "text": "This section of the document is meant to further define what is required, and expected for each Phase of the competition.",
            "title": "Phase Definitions"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-i",
            "text": "Purpose:  Allow recruits to get acquainted with a very simple program, and how the process works to program the RC Car. The recruits will need to call functions that have been premade for them, and make a simple loop.  Required Tasks:   \uf0b7\uf0b7Drive Forward for 10 seconds  \uf0b7\uf0b7Drive Backward for 10 seconds  \uf0b7\uf0b7Turn Right for 10 seconds  \uf0b7\uf0b7Turn Left for 10 seconds   Explanation:  This phase should not require further explanation in order to get a grasp on what's required. By defining a few variables, and using the pre-made functions given to use, the recruit should be able to create a program that performs the above tasks.  Evaluation and Weighting:    10% in total for the phase  2.5% will be given per each of the 4 tasks  It is simply expected that the car moves in the appropriate direction for the given time period. The car does not need to stop \"spot on\" the 10 second mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.",
            "title": "Phase I"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-ii",
            "text": "Purpose:  The initial purpose of this phase is to have the recruits create a new function from scratch. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 10 meters  \uf0b7\uf0b7Drive Backward 10 meters   Explanation:  In this phase the recruit must create their own function in order to determine the distance travelled from the car's current position, to a start point (or previous waypoint).  Your function definition should pass in latitude and longitude values of the GPS coordinates (2 sets, one for point 'A' and one for point 'B'). The following website gives you a pretty good layout of how your code should look (to some extent, it will look different due to you programming in C and not Java Script). Specifically the following code bite as well:  http://www.movable-type.co.uk/scripts/latlong.html   Above is the formula you must program into your function.  Below is how the created such a function with Java Script. *** Your function should return a float of \"d\"   var R =6371;// km  var\u03c61= lat1.toRadians();  var\u03c62= lat2.toRadians();  var\u0394\u03c6=(lat2-lat1).toRadians();  var\u0394\u03bb=(lon2-lon1).toRadians();  var a =Math.sin(\u0394\u03c6/2)*Math.sin(\u0394\u03c6/2)+      Math.cos(\u03c61)\\*Math.cos(\u03c62)\\*\n\n    Math.sin(\u0394\u03bb/2)\\*Math.sin(\u0394\u03bb/2);  var c =2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));  var d = R * c;   The only addition you must make to this code (besides writing it correctly for your C program), is to multiple the \"c\" value above by \u00b11000. Is needed to convert kilometers into meters.  Evaluation and Weighting:    10% in total for the phase  5% will be given per each of the 2 tasks  Initially, it is simply expected that the car moves in the appropriate direction for the given distance. The car does not need to stop \"spot on\" the 10 meter mark, but WARG will be able to easily tell if you've implemented the correct functionality in your code. It is also key to note that care should be taken into consideration, and there is no need to put the car at 100% throttle in order to complete this task.  Furthermore, out of the 5% given towards either task, a weighting of 4% will be achieved by implementing the functionality described in the previous paragraph. The additional 1% will be achieved based on error to the 10m mark. In order to reach the 10m as close as possible, the recruit must implement proper Control Theory in order to slow the car down and receive the extra weighting. The code cannot be written to simply reverse the car for a millisecond after reaching the 10m mark, as this harms the equipment and decreases its lifespan. You may not reverse back to the 10m mark either if you have passed it. Additionally, in order to achieve this extra weighting (and so that WARG can see your control loop is working correctly), the RC Car must be started at an initial throttle of _(40)_%. The weighting will be received based on error in comparison to the top team for this phase (team closest to the 10m mark).  Please note that the control theory aspect will be learned in later phases of the competition. The \"closeness\" to the 10m mark is worth only 1% since it is WARG's desire that all teams initially develop the code well enough to accomplish the initial 4% of this phase for each task. If teams finish the majority of the competition, and after learning control theory, they may return back to this phase in order to try and receive the addition 1%.",
            "title": "Phase II"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-iii",
            "text": "Purpose:  The initial purpose of this phase is to have the recruits begin to think in terms of heading, and how it relates to controlling the steering of the car. Once the recruits have completed later phases, and gained further knowledge, they can return to this phase in order to improve it and receive a higher weighting.  Required Tasks:   \uf0b7\uf0b7Drive Forward 5 meters, then  ooTurn Right 90 degrees, then  ooTurn Left 90 degrees   Explanation:  In this phase the recruit must create their own functionality in order to determine which direction to steer the car at any given point in time. The car may bounce around, and therefore move off of the desired path. Since we are constantly checking the state of the car (by continuously looping through the entire code), we can determine which way to steer the car at any point in time. It is recommended that this functionality be developed in the form of a function.  At no point during this phase should the car come to a stop while transitioning between task objectives. The desire is that the car drives a smooth path. For this reason, the car should never operate under _(20)_% throttle while transitioning between task objectives. The car may only be controlled to a complete stop once you are completed the phase in the \"Turn Left 90 degrees\" sub-task. Again, the car may never be driven backwards, and must always be moving forwards.  Evaluation and Weighting:    15% in total for the phase  12% will be given for initially achieving the tasks above by going (at minimum) the distance or angle change that's stated.  Initially it is WARG's desire that the recruit moves on after achieving this initial functionality, and returns back at a later time to improve upon the phase's functionality. The additional 3% will be achieved similarly to the methods described in Phase II, in the same manner that the additional 1% is achieved.",
            "title": "Phase III"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-iv",
            "text": "Purpose:  The purpose of this phase is for the recruit to put all of the functionality they've developed together, and create a simple control loop.  Required Tasks:   \uf0b7\uf0b7Drive a straight line  ooWhile maintaining heading  ooStop after _(100)_m   Explanation:  In this phase the recruit must create a control loop that will steer the car accordingly and keep it on the desired path. This involves monitoring the heading of the car, and steering the car in the appropriate direction if it starts to stray from the desired path. A heading a starting direction will be determined by WARG based on the competition testing location (the heading to hold will be hardcoded into the recruits program ahead of time, since at this point we are not expecting anything that calculates which heading should be held).  You will notice that if you turn the car too much in a given direction when it strays off the path, it will quickly be weaving back and forth on the path, and the amplitude of this \"weave\" will increase overtime. This is because you must  converge  towards the desired path, rather than do a jerking turn that makes the car immediately be on the path. The rate at which you turn the steering, relative to your distance from the path, is controlled through the  control loop , and by tuning the gains appropriately to fit your system (in this case the system is the RC Car).  Please refer to the  Control Theory  section in order to gain more knowledge on how to create a control loop. As well, WARG is considering bring in lecturers in order to host short lectures / tutorials on these concepts. This will be done based on the interest of the students.  Evaluation and Weighting:    15% in total for the phase  Considering that we do not expect the car to stray to too far from the desired path (there are no strong winds pushing the car off its path, such as that which occurs with the airplane while in the air), we do not expect the error from the path to be very large at all. Even if the recruit poorly tuned that control loops / gains, we believe the system shouldn't have a problem staying on the desired path.  With this in mind, the 10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error.  The additional 5% of this phase will be calculated based on the recruit's error in distance travelled, in comparison to that of the top team's error. (Hint: this is a controlled stop like that described in Phase II)  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired travel distance of _(100)_m. Again, the car should always be moving forward.",
            "title": "Phase IV"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-v",
            "text": "Purpose:  The purpose of this phase is for the recruit to develop dynamic functionality of their code (i.e. not hardcoded values). This phase also has the purpose of developing code that drives the car based on waypoints.  Required Tasks:   \uf0b7\uf0b7Drive from Point A to Point B  ooStop within a _(5)_m radius   Explanation:  The functionality as described in Phase IV should be implemented in this phase in order to better complete the task described.  You'll need to apply some logic into your program and probably create another function to perform basic geometry. In order to find the line (and heading) you must follow, you'll have to generate a xy based system from you latitude / longitude coordinates. You can do this by specifying an anchor point (of latitude longitude, this could possibly be your position on start-up). You can then find your x component, and y component of any given waypoint by holding either your latitude / longitude constant, and sending your anchor, and new waypoint through your getDistance() function.  On competition day, WARG will provide the recruit with a Waypoint to travel to. The program must get its current GPS position (current waypoint), and then calculate a straight line from this current position to the desired waypoint given by WARG. This is the heading that the car must be desired to hold in order to get to the waypoint.  WARG will start the car in the opposite (or some determined) direction relative to the goal Waypoint in order to ensure the system is calculating things appropriately.  *Hint: The RC Car should calculated which direction to turn in order to be going the appropriate heading the fastest.  Evaluation and Weighting:    15% in total for the phase  10% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 5% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 5% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.",
            "title": "Phase V"
        },
        {
            "location": "/bootcamp/rccompetition/#phase-vi",
            "text": "Purpose:  The purpose of this phase is to combine everything that the recruit has learned in order to make the RC Car follow a dynamic path of waypoints. Two paths of _(10)_ waypoints will be given for the car to follow (the car will follow one path, and then the new waypoints will be programmed, and the second path will be followed).  Required Tasks:   \uf0b7\uf0b7Follow a set of _(10)_ Waypoints   Explanation:  At this point in time, WARG hopes that the recruit has learned enough from previous stages in order to accomplish the described task of following a set of _(10)_ waypoints.  Waypoint 1 will be the RC Car's current position, the additional 9 waypoints will be provided.  Evaluation and Weighting:    35% in total for the phase  34% is allocated towards a large part of this phase. The amount each recruit receives will be based on their error in comparison to the top team's error. Error is determined by the cars distance from the desired path throughout the duration of the phase.  The additional 1% of this phase will be calculated based on the recruit's error in distance from the _(5)_m radius circle of the final waypoint (i.e. if the further you are from this radius, the more error you have), in comparison to that of the top team's error. If you stop within _(5)_m, you will be awarded with the full 1% weighting.  Once again, you must have a starting throttle of at least _(40)_%, and this should be your \"cruising\" throttle while following the path.  You may start to decrease and control your stopping point within 10m of the desired waypoint. Again, the car should always be moving forward.",
            "title": "Phase VI"
        },
        {
            "location": "/tutorials/git/",
            "text": "Git and Github Tutorial\n\n\nThis tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.\n\n\nWhat is Git?\n\n\nGit\n is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the \nchanges\n to your files only, not the individual files themselves.\n\n\nWhy use Git?\n\n\nYou may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break something).\n\n\nInstalling git\n\n\nYou have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also \nGithub for Desktop\n, which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.\n\n\nWindows\n\n\nYou can download and run the \ngit installer\n\n\nMac OS X\n\n\nYou can install \nhomebrew\n and install git with \nbrew install git\n\n\nUbuntu\n\n\nIf you're using linux, you can install git by simply running:\n\nsudo apt-get install git\n. \n\n\nCreating a Github account\n\n\nSign up\n for a github account if you don't have one. We'll later explain what github is, but you can just create an account for now.\n\n\nSetting up git for the first time\n\n\nTo set up git for the first time on your computer, run these commands in the git shell (or the command line): \n\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email your.email@example.com\ngit config --global push.default matching\ngit config --global alias.co checkout\n\n\n\n\nWhere \nYour Name\n and \nyour.email@example.com\n preferrably match your github account. If you've installed the GUI Github for Desktop client, you've probably done all of these steps already at the startup screen.\n\n\nHow to use Git\n\n\nUsing git is very simple. How the workflow works is:\n\n\n\n\nYou edit your code in your project\n\n\nYou decide that you would like to save the current state of your project\n\n\nYou add the changed files to the staging index with \ngit add .\n\n\nYou commit the files with \ngit commit -m \"Your unique commit message here\n\n\n\n\nBranching\n\n\nGit branches are a feature of git that allow you to work on multiple features at once. Branches also allow you to\nprototype and try new things without breaking the main code. A branch lets you essentially create a current snapshot\nof your code. A git repo can have as many branches as you want. \n\n\nSay for example you're working on Feature X. Feature X will take a while to make, and since you don't want it to be in the main code until its ready, you decide you want to  branch off of the \nmaster\n branch with a new branch called \nfeature-x\n. To create a branch you type in \ngit checkout -b feature-x\n. Now all of your changes and commits are applied to the \nfeature-x\n branch, and not the master branch. \n\n\nSay now you want to add Feature Y. Because you're using branches, you're not directly affecting the main code. You can\nswitch to the \nmaster\n branch with \ngit checkout master\n, which contains the latest, most stable code for your application. \nNow you can create a branch off of master called \nfeature-y\n with \ngit branch feature-y\n and then work on that branch \nwith \ngit checkout feature-y\n. Note that \ngit checkout -b feature-y\n is the same as running the previous two commands.\n\n\nYou can move between branches this way, and work on multiple features all at the same time, whilst not affecting the main code,\nusually located in the \nmaster\n branch until your feature is ready.\n\n\nThat's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the \nAdditional Resources\n section which lists articles that explain it.\n\n\nCommon Commands\n\n\nHere are some common commands you can use with git:\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngit init\n\n\nCreate a repository in the current directory\n\n\n\n\n\n\ngit clone {url}\n\n\nClone a remote repository into a subdirectory\n\n\n\n\n\n\ngit add {file or path}\n\n\nAdd file or files in directory recursively to the staging index\n\n\n\n\n\n\ngit add .\n\n\nAdd all of your changes to the staging index\n\n\n\n\n\n\ngit add . --all\n\n\nAdd all of your changes to the staging index (including removed files)\n\n\n\n\n\n\ngit reset HEAD {file or path}\n\n\nRemove file or files from the staging index\n\n\n\n\n\n\ngit checkout -- .\n\n\nRemove all changes from your working tree\n\n\n\n\n\n\ngit checkout {branch_name}\n\n\nSwitch to a branch\n\n\n\n\n\n\ngit checkout -b {branch_name}\n\n\nSwitch to a branch and create it if it doesnt yet exist\n\n\n\n\n\n\ngit branch {branch_name}\n\n\nCreate a branch off of the one you're currently on\n\n\n\n\n\n\ngit branch\n\n\nView all the branches you have stored locally, as well as view the branch you're on\n\n\n\n\n\n\ngit status\n\n\nShow status of the working tree\n\n\n\n\n\n\ngit diff {file}\n\n\nShow the changes in the file\n\n\n\n\n\n\ngit diff\n\n\nShow all changes in the working tree\n\n\n\n\n\n\ngit commit {file or path}\n\n\nCommit files that has been staged (with git-add)\n\n\n\n\n\n\ngit reset --soft HEAD^\n\n\nUndo commit & keep changes in the working tree\n\n\n\n\n\n\ngit reset --hard HEAD^\n\n\nReset the working tree to the last commit\n\n\n\n\n\n\ngit log {path} --oneline\n\n\nView commit log, optionally for specific path\n\n\n\n\n\n\ngit blame [file]\n\n\nShow file annotated with line modifications\n\n\n\n\n\n\ngit fetch\n\n\nFetch changes from a remote repository\n\n\n\n\n\n\ngit pull\n\n\nFetch and merge changes from a remote repository\n\n\n\n\n\n\ngit push origin {branch_name}\n\n\nPush branch and its changes to a remote repository (like github)\n\n\n\n\n\n\ngit remote -v\n\n\nList remote repositories\n\n\n\n\n\n\n\n\nWhat is Github?\n\n\nWhen you create a git repository, it created on your file system. \nGithub\n is the dropbox of git. It allows you to store your git repository online in public. This lets other people download and collaborate with your repo. Github has some extra perks in terms\nof collaborating with other people. One of these features includes the creation of Pull Requests. \n\n\nPull Requests\n\n\nA pull requests is analogous to you asking everyone on your project to take a look at the work you did, and accept your changes if they all agree. Thats what a pull request lets you do.\n\n\nA normal git/github workflow works like this:\n\n\n\n\nYou branch off of the master branch of the repo you're working on\n\n\nYou make your changes, committing often\n\n\nYou open up a Pull Request on Github against the master branch\n\n\nAnyone else working on the project will look at the PR, look at the changes you've made, and make comments on them if necessary\n\n\nAfter everyone gives you the thumbs up, you have permission to merge your changes in to the master branch. At that point anyone else that branches of off master will have your changes\n\n\nRepeat Step 1\n\n\n\n\nForks\n\n\nGithub also allows forks. Forks are essentially the ability to clone github repos that you dont have permission to push to into\nyour own account. After you've made changes to your fork, you can create a pull request against the original repo, and the developers\nof the repo can merge your changes in if they like them. \n\n\nAdditional Resources\n\n\n\n\n15 Minute Git Tutorial\n\n\nCodeAcademy Git Course\n\n\nMore Resources",
            "title": "Git and Github"
        },
        {
            "location": "/tutorials/git/#git-and-github-tutorial",
            "text": "This tutorial will introduce you to git and github. Knowing these is essential if you want to contribute to the software side of UWARG.",
            "title": "Git and Github Tutorial"
        },
        {
            "location": "/tutorials/git/#what-is-git",
            "text": "Git  is a source code version control system. What does this mean? It lets you manage source code. Git tracks changes to your code, lets you revert your code, and allows you to collaborate with other people easily.  Git tracks the  changes  to your files only, not the individual files themselves.",
            "title": "What is Git?"
        },
        {
            "location": "/tutorials/git/#why-use-git",
            "text": "You may just be used to saving code to your computer locally only, and relying on Ctrl-Z in case you break something and want to restart. This is where git shines. You commit code, which allows you to revert to it later if need be (say, you break something).",
            "title": "Why use Git?"
        },
        {
            "location": "/tutorials/git/#installing-git",
            "text": "You have two options when installing Git. There's the command line version (you use it through the command promt/no gui). There's also  Github for Desktop , which is a GUI client for Git that integrates with Github (don't worry we'll explain github later on). If you're a beginner, you should probably start out with the GUI client. If you're on linux or interested in using the command shell (its usually faster than the GUI client) then install that.",
            "title": "Installing git"
        },
        {
            "location": "/tutorials/git/#windows",
            "text": "You can download and run the  git installer",
            "title": "Windows"
        },
        {
            "location": "/tutorials/git/#mac-os-x",
            "text": "You can install  homebrew  and install git with  brew install git",
            "title": "Mac OS X"
        },
        {
            "location": "/tutorials/git/#ubuntu",
            "text": "If you're using linux, you can install git by simply running: sudo apt-get install git .",
            "title": "Ubuntu"
        },
        {
            "location": "/tutorials/git/#creating-a-github-account",
            "text": "Sign up  for a github account if you don't have one. We'll later explain what github is, but you can just create an account for now.",
            "title": "Creating a Github account"
        },
        {
            "location": "/tutorials/git/#setting-up-git-for-the-first-time",
            "text": "To set up git for the first time on your computer, run these commands in the git shell (or the command line):   git config --global user.name \"Your Name\"\ngit config --global user.email your.email@example.com\ngit config --global push.default matching\ngit config --global alias.co checkout  Where  Your Name  and  your.email@example.com  preferrably match your github account. If you've installed the GUI Github for Desktop client, you've probably done all of these steps already at the startup screen.",
            "title": "Setting up git for the first time"
        },
        {
            "location": "/tutorials/git/#how-to-use-git",
            "text": "Using git is very simple. How the workflow works is:   You edit your code in your project  You decide that you would like to save the current state of your project  You add the changed files to the staging index with  git add .  You commit the files with  git commit -m \"Your unique commit message here",
            "title": "How to use Git"
        },
        {
            "location": "/tutorials/git/#branching",
            "text": "Git branches are a feature of git that allow you to work on multiple features at once. Branches also allow you to\nprototype and try new things without breaking the main code. A branch lets you essentially create a current snapshot\nof your code. A git repo can have as many branches as you want.   Say for example you're working on Feature X. Feature X will take a while to make, and since you don't want it to be in the main code until its ready, you decide you want to  branch off of the  master  branch with a new branch called  feature-x . To create a branch you type in  git checkout -b feature-x . Now all of your changes and commits are applied to the  feature-x  branch, and not the master branch.   Say now you want to add Feature Y. Because you're using branches, you're not directly affecting the main code. You can\nswitch to the  master  branch with  git checkout master , which contains the latest, most stable code for your application. \nNow you can create a branch off of master called  feature-y  with  git branch feature-y  and then work on that branch \nwith  git checkout feature-y . Note that  git checkout -b feature-y  is the same as running the previous two commands.  You can move between branches this way, and work on multiple features all at the same time, whilst not affecting the main code,\nusually located in the  master  branch until your feature is ready.  That's it! Its that simple. When using git you may want to wrap your head around the concept of the staging index, the remote repository, local repository, etc. Those go beyond this tutorial however if you're interested you head scroll down to the  Additional Resources  section which lists articles that explain it.",
            "title": "Branching"
        },
        {
            "location": "/tutorials/git/#common-commands",
            "text": "Here are some common commands you can use with git:     Command  Description      git init  Create a repository in the current directory    git clone {url}  Clone a remote repository into a subdirectory    git add {file or path}  Add file or files in directory recursively to the staging index    git add .  Add all of your changes to the staging index    git add . --all  Add all of your changes to the staging index (including removed files)    git reset HEAD {file or path}  Remove file or files from the staging index    git checkout -- .  Remove all changes from your working tree    git checkout {branch_name}  Switch to a branch    git checkout -b {branch_name}  Switch to a branch and create it if it doesnt yet exist    git branch {branch_name}  Create a branch off of the one you're currently on    git branch  View all the branches you have stored locally, as well as view the branch you're on    git status  Show status of the working tree    git diff {file}  Show the changes in the file    git diff  Show all changes in the working tree    git commit {file or path}  Commit files that has been staged (with git-add)    git reset --soft HEAD^  Undo commit & keep changes in the working tree    git reset --hard HEAD^  Reset the working tree to the last commit    git log {path} --oneline  View commit log, optionally for specific path    git blame [file]  Show file annotated with line modifications    git fetch  Fetch changes from a remote repository    git pull  Fetch and merge changes from a remote repository    git push origin {branch_name}  Push branch and its changes to a remote repository (like github)    git remote -v  List remote repositories",
            "title": "Common Commands"
        },
        {
            "location": "/tutorials/git/#what-is-github",
            "text": "When you create a git repository, it created on your file system.  Github  is the dropbox of git. It allows you to store your git repository online in public. This lets other people download and collaborate with your repo. Github has some extra perks in terms\nof collaborating with other people. One of these features includes the creation of Pull Requests.",
            "title": "What is Github?"
        },
        {
            "location": "/tutorials/git/#pull-requests",
            "text": "A pull requests is analogous to you asking everyone on your project to take a look at the work you did, and accept your changes if they all agree. Thats what a pull request lets you do.  A normal git/github workflow works like this:   You branch off of the master branch of the repo you're working on  You make your changes, committing often  You open up a Pull Request on Github against the master branch  Anyone else working on the project will look at the PR, look at the changes you've made, and make comments on them if necessary  After everyone gives you the thumbs up, you have permission to merge your changes in to the master branch. At that point anyone else that branches of off master will have your changes  Repeat Step 1",
            "title": "Pull Requests"
        },
        {
            "location": "/tutorials/git/#forks",
            "text": "Github also allows forks. Forks are essentially the ability to clone github repos that you dont have permission to push to into\nyour own account. After you've made changes to your fork, you can create a pull request against the original repo, and the developers\nof the repo can merge your changes in if they like them.",
            "title": "Forks"
        },
        {
            "location": "/tutorials/git/#additional-resources",
            "text": "15 Minute Git Tutorial  CodeAcademy Git Course  More Resources",
            "title": "Additional Resources"
        },
        {
            "location": "/tutorials/shell/",
            "text": "Using the command shell\n\n\nSome of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line. \n\n\nA recommended tutorial you can checkout is \nCodeAcademy's Command Line Course\n. They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).\n\n\nNote: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like \ncmder\n.",
            "title": "Using the terminal"
        },
        {
            "location": "/tutorials/shell/#using-the-command-shell",
            "text": "Some of the docs and tutorials on this site assume that you know how to navigate the file system using the terminal (whether it be on Windows, Linux, or Mac). For example, working with the computer-vision and groundstation projects is alot easier to do on the command line than with a GUI. In both cases, it isn't possible to setup either of these projects without touching the command line.   A recommended tutorial you can checkout is  CodeAcademy's Command Line Course . They guide you through using bash to navigate the file system, run commands, etc. The course is free and should only take you about 3 hours. It's interactive and will teach you how to use the shell far better than we can ;).  Note: This course teaches bash (which is what runs on linux by default). It is however far better than the Windows CMD and you can install and use it on Windows by downloading and installing something like  cmder .",
            "title": "Using the command shell"
        },
        {
            "location": "/groundstation/",
            "text": "Welcome to the Groundstation docs!\n\n\nThe groundstation is the software running on the ground computer communicating to the plane through the \ndata-relay-station\n. This wiki describes everything you need to know about it in order to start contributing.\n\n\nTable of Contents\n\n\n\n\nIntroduction\n\n\nWhat you need to know\n\n\nInstallation\n\n\nTutorial\n\n\nProject Structure\n\n\nContributing\n\n\nDocumenting\n\n\nAdditional Resources",
            "title": "Table of Contents"
        },
        {
            "location": "/groundstation/#welcome-to-the-groundstation-docs",
            "text": "The groundstation is the software running on the ground computer communicating to the plane through the  data-relay-station . This wiki describes everything you need to know about it in order to start contributing.",
            "title": "Welcome to the Groundstation docs!"
        },
        {
            "location": "/groundstation/#table-of-contents",
            "text": "Introduction  What you need to know  Installation  Tutorial  Project Structure  Contributing  Documenting  Additional Resources",
            "title": "Table of Contents"
        },
        {
            "location": "/groundstation/introduction/",
            "text": "Introduction\n\n\nThe groundstation is a desktop application based on \nNW.js\n. This section will explain what NW.js and \nNode.js\n is.\n\n\nCommunication Path\n\n\nThe groundstation talks directly to the \ndata-relay-station\n. The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).\n\n\n\n\nWhat is Javascript and Node.js?\n\n\nAs you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes. \n\n\nEnter \nNode.js\n\n\nNode.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with \npython script.py\n you can run javascript scripts with \nnode script.js\n. It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it. \n\n\nWhat is NW.js?\n\n\nOk, so where does \nNW.js\n fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.\n\n\nNW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.",
            "title": "Introduction"
        },
        {
            "location": "/groundstation/introduction/#introduction",
            "text": "The groundstation is a desktop application based on  NW.js . This section will explain what NW.js and  Node.js  is.",
            "title": "Introduction"
        },
        {
            "location": "/groundstation/introduction/#communication-path",
            "text": "The groundstation talks directly to the  data-relay-station . The data-relay-station is a simple python server that acts as the middleman between the PicPilot running on the plane and the groundstation running at the base. The PicPilot sends data using it's xbee module, which the tracking antenna receives relaying it to the data relay station, which sends it to the groundstation. The groundstation can then, based on the data received, send commands back through the same path. As seen from this picture, the groundstation acts as one of the 'clients' to the data relay station (the raspberry pi).",
            "title": "Communication Path"
        },
        {
            "location": "/groundstation/introduction/#what-is-javascript-and-nodejs",
            "text": "As you may already know, javascript is a programming language. It's syntax is very similar to other C-based languages such as C++, Java, and so forth. Javascript was initially intended to only be run on the browser, and one of it's biggest limitations is that it doesn't have file access to your computer (for security purposes). This limitation prevented developers from using it other than for web application purposes.   Enter  Node.js  Node.js is a cross platform javascript runtime built on Chrome's V8 JavaScript engine. A lot of fancy words there. What this basically means is that Node provides a way for you to run javascript code natively on your computer without the need for a browser. It's essentially an interpreter. In the same way you can run python scripts with  python script.py  you can run javascript scripts with  node script.js . It's important to note that node.js isn't a language itself. You write javascript code and then run it with node.js to execute it.",
            "title": "What is Javascript and Node.js?"
        },
        {
            "location": "/groundstation/introduction/#what-is-nwjs",
            "text": "Ok, so where does  NW.js  fit in all this? Why do we need it if we can already write native applications with node.js and javascript? You can think of NW.js as a GUI framework. Usually when making a GUI, especially one that's cross-platform (being able to run on Linux, Mac, and Windows) you have to work with very low level graphic libraries and other weird shenanigans that are specific to each OS you're working it. That's what NW.js provides. It abstracts the creation of GUI's and allows you to create cross-platform desktop applications using a single interface. It's the equivalent of the Swing framework for Java or Qt for C++.  NW.js itself runs on top of node. How NW.js works is pretty simple. Basically it opens up a customized version of chrome and your app runs through there. So what you're essentially building is a web page, and using javascript to add functionality to the web page.",
            "title": "What is NW.js?"
        },
        {
            "location": "/groundstation/what-you-need-to-know/",
            "text": "What you need to know\n\n\nThis section will help to highlight \nmost\n of what you need to know before you can start developing. \n\n\nJavascript\n\n\nIf you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this \nCodeacademy Javascript Course\n. The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are: \n\n\n\n\nThe significance of var and when and when not to use it\n\n\nThat everything in javascript is an object, including functions\n\n\nThe 3 different ways of declaring javascript objects, and how they are different\n\n\n\n\nNode.js\n\n\nSo you don't need to read all of the gigantic \nNode.js API Documentation\n, though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.\n\n\nNode.js modules\n\n\nSo what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word \nrequire\n being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you. \n\n\nUsually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.\n\n\nSo what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling \nrequire('filelocation/filename)\n. But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.\n\n\nLets take an example comparing traditional methods and using require. \n\n\nUsing Regular Javascript\n\n\n<head>\n    <script>\n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n    </script>\n    <script>\n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n    </script>\n</head>\n\n\n\n\nThis is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.\n\n\nUsing Node.js Modules\n\n\n//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;\n\n\n\n\n//this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!\n\n\n\n\nYou may have noticed the \nmodule.exports=hello;\n line in the \nhello.js\n module. What this tells node is the result of calling \nrequire\n on the hello.js module will return the variable/function hello. In \napp.js\n we use this module by calling \nvar hello=require('hello')\n. The variable hello now contains whatever the \nhello.js\n module exported, which in this case is a function.\n\n\nYou can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling \nvar\n will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.\n\n\nNode Package Manager (npm)\n\n\nNPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the \nNPM registry\n. \n\n\nThe most important command of npm is \nnpm install <packagename>\n. This will install a package in your project directory. Doing an \nnpm install\n without any parameters at the project root will tell npm to look in your projects \npackage.json\n file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running \nnpm install -g nw\n. This will install the NW.js module globally on your computer, allowing you to use the \nnw\n command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running \nnw\n in the terminal.\n\n\nJavascript Frameworks\n\n\nThe groundstation uses \nBackbone\n and \nMarionette\n as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.\n\n\nYou don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation. \n\n\nLibraries Used\n\n\nOne of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include \nJquery\n for simple dom manipulations, and \nleaflet\n as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the \nLeaflet API Docs\n is pretty useful if you're working with the Map modules.",
            "title": "What you need to know"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#what-you-need-to-know",
            "text": "This section will help to highlight  most  of what you need to know before you can start developing.",
            "title": "What you need to know"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#javascript",
            "text": "If you already know Javascript, that's awesome. If you don't, then that's fine too. If you're already familiar with another programming language, you'll find javascript really similar and probably be able to pick it up as you start the developing the groundstation. If you don't know programming, it's highly suggested you take this  Codeacademy Javascript Course . The estimated course time is only 10 hours (which is really little if you think about it) and at the end you should be confident in basic programming concepts as well as javascript syntax. The most important javascripts concepts you need to know are:    The significance of var and when and when not to use it  That everything in javascript is an object, including functions  The 3 different ways of declaring javascript objects, and how they are different",
            "title": "Javascript"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs",
            "text": "So you don't need to read all of the gigantic  Node.js API Documentation , though you should reference it when you need to. Instead all you really need to know about node.js is its built-in package manager and the incredible power of modules that it provides you.",
            "title": "Node.js"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#nodejs-modules",
            "text": "So what are these modules and why are they useful? If you look at the groundstation syntax and other node.js examples online, you may notice the key word  require  being used a lot. This isn't a native javascript function. It's actually a feature node.js provides you.   Usually in webpages scripts execute as soon as you load them. If you want to devide your application into different parts, you would have had to split up your main javascript file into different files and load them in the order you want them to be run in. This approach is cumbersome and leads to bad practices. The biggest bad practice is the creation of global variables everywhere. Global variables make your application harder to maintain and debug.  So what do these modules do? Each module is basically a javascript file, and you call the javascript file by calling  require('filelocation/filename) . But how is this different than loading a script on your browser? Well, when you call require on a module, everything in that module runs in its own scope (so you're free to declare global variables in that file without affecting the rest of the application) and the return result of the require function returns whatever you want the module to return.  Lets take an example comparing traditional methods and using require.",
            "title": "Node.js modules"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#using-regular-javascript",
            "text": "<head>\n    <script>\n        //this is my module\n        var private_sensitive_variable=6;\n\n        //this is the function that i want my module to return\n        function hello(){\n            console.log('hello'+private_sensitive_variable); //will output hello 6\n        }\n    </script>\n    <script>\n    //this is a completely seperate module\n    hello(); //i can call this function from the above module which is what i wanted\n\n    console.log(private_sensitive_variable); //this will output 6, which is NOT what I wanted since the variable was declared globally within the above script/module\n    </script>\n</head>  This is a relatively simple example, however you can see that if we keep doing this, as the application becomes large, it'll become more of a pain to manage the application and keep track of what needs what. Here's the beauty of modules. They provide dependency management, so you can clearly see what each module depends on. In the above example if I reposition the second script above the first I'll get an exception thrown, since the function hello and the variable weren't declared yet. Now lets see how we can handle the same scenario using node modules.",
            "title": "Using Regular Javascript"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#using-nodejs-modules",
            "text": "//this is hello.js\nvar private_sensitive_variable=6;\n\nvar hello=function(){\n    console.log('hello'+private_sensitive_variable); //will output hello 6\n}\n\nmodule.exports=hello;  //this is app.js\nvar hello=require('hello');\n\nhello(); //will output hello 6\n\nconsole.log(private_sensitive_variable); //will throw an exception as this variable hasn't been declared globally or in the context of this module, which is good!  You may have noticed the  module.exports=hello;  line in the  hello.js  module. What this tells node is the result of calling  require  on the hello.js module will return the variable/function hello. In  app.js  we use this module by calling  var hello=require('hello') . The variable hello now contains whatever the  hello.js  module exported, which in this case is a function.  You can see that even though theres more abstraction in the second method, the code has become far more maintanable. Now calling  var  will not carelessly create global variables over our application. It will only create them in the scope of the module. We can also see the dependencies on our modules immediately, and keep track of them easily.",
            "title": "Using Node.js Modules"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#node-package-manager-npm",
            "text": "NPM stands for the Node Package Manager. It is based off the concept of node.js modules. It's basically a built-in dependency manager for node.js. Think of it as a plugin manager if you will, similar to pip for python or composer for php. One of the main advantages of using node.js is the abundance of libraries and modules that you can install and use in your application. You can find and search for all the packages available for use in the  NPM registry .   The most important command of npm is  npm install <packagename> . This will install a package in your project directory. Doing an  npm install  without any parameters at the project root will tell npm to look in your projects  package.json  file and install your apps dependencies. One of the dependencies that the groundstation relies on is the NW.js module. To try out installing a package globally, try running  npm install -g nw . This will install the NW.js module globally on your computer, allowing you to use the  nw  command. You can use this command to start up the groundstation as well, by navigating to the groundstation directory and running  nw  in the terminal.",
            "title": "Node Package Manager (npm)"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#javascript-frameworks",
            "text": "The groundstation uses  Backbone  and  Marionette  as it's javascript frameworks. Why use javascript frameworks at all? To help organize the code in an MVC design pattern. Basically, rather than having all of our system logic (logic responsible for core functionality) and logic for manipulating the view (ie button state, checking user input) in one place, using these frameworks helps split them up to create more maintanable and manageble code. The design pattern it helps enforce is called MVC (Model View Controller) which you can read up on if you'd like.  You don't have to read the documentation on these frameworks to start working on the groundstation. You'll get a grasp on it after reading the tutorial (next section) and working on the groundstation.",
            "title": "Javascript Frameworks"
        },
        {
            "location": "/groundstation/what-you-need-to-know/#libraries-used",
            "text": "One of the awesome things about javascript is the awesome community! There are literally thousands of libraries available for us to use. These include  Jquery  for simple dom manipulations, and  leaflet  as the map library. You don't have to know jquery to work on the groundstation, you'll pick it up eventually. Reading the  Leaflet API Docs  is pretty useful if you're working with the Map modules.",
            "title": "Libraries Used"
        },
        {
            "location": "/groundstation/installation/",
            "text": "Installation\n\n\n\n\n\n\nThe first step is cloning the repository. Open up the terminal and run: \n\ngit clone https://github.com/UWARG/WARG-Ground-Station\n\n\n\n\n\n\nThen you need to install Node.js. You can download and install it \nhere\n. Download Node version 5 and above preferably. After you've installed node you should have the \nnode\n command available for you to use in your terminal. Run \nnode help\n to verify that you've successfuly installed node and make sure you're running the right version.\n\n\n\n\n\n\nNow that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run \nnpm install\n to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).\n\n\n\n\n\n\nNow you're ready to start the app up. Run \nnpm start\n to start the application. You should see a window appear of the groundsation.\n\n\n\n\n\n\nNow you need to download the offline satelite files that the application uses for it's map. \nDownload them here.\n. Extract the zip into the \nassets\n folder of the project directory (so you should have a folder called \nsat_tiles\n in the assets folder). \n\n\n\n\n\n\nCongratulations! You should now have the groundstation installed on your computer ready for you to develop on!",
            "title": "Installation"
        },
        {
            "location": "/groundstation/installation/#installation",
            "text": "The first step is cloning the repository. Open up the terminal and run:  git clone https://github.com/UWARG/WARG-Ground-Station    Then you need to install Node.js. You can download and install it  here . Download Node version 5 and above preferably. After you've installed node you should have the  node  command available for you to use in your terminal. Run  node help  to verify that you've successfuly installed node and make sure you're running the right version.    Now that you've installed node, navigate to the groundstation project directory (the folder that was created when you did the git clone). Then run  npm install  to install all of the apps dependencies. If you get weird errors, try running your terminal in administrative mode (or sudo for linux users).    Now you're ready to start the app up. Run  npm start  to start the application. You should see a window appear of the groundsation.    Now you need to download the offline satelite files that the application uses for it's map.  Download them here. . Extract the zip into the  assets  folder of the project directory (so you should have a folder called  sat_tiles  in the assets folder).     Congratulations! You should now have the groundstation installed on your computer ready for you to develop on!",
            "title": "Installation"
        },
        {
            "location": "/groundstation/tutorial/",
            "text": "Groundstation Tutorial\n\n\nThis tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules. \n\n\nInstallation\n\n\nFollow the installation guide \nhere\n to install the groundstation on your computer.\n\n\nEditor\n\n\nYou can use your prefered editor for this application, or an IDE like Webstorm if you prefer.\n\n\nGetting Started\n\n\nTake a look at the \nproject structure\n so you roughly know what each folder of the application is for.\n\n\nCreating a new window\n\n\nTo start create a window, we need to create an html file that will represent our window. In the \nwindow\n folder at the project root, create a file and call it \nnew-window.html\n. Paste this boilerplate code on there:\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>My new window</title>\n</head>\n<body>\n    <p>Hello this is my new window!</p>\n</body>\n</html>\n\n\n\n\nAdding a menu item\n\n\nSo all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window. \n\n\nOpen up \napp/Menu.js\n. This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:\n\n\n// ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key: \"k\",\n    modifiers: \"ctrl-shift\",\n  }));\n\n\n\n\n\n\nNow lets see what we just did. Calling \nwindow_submenu.append(..)\n appends a menu item to the Window menu of the app. In this case its a \ngui.MenuItem\n which represents a menu item in NW.js applications. The \nlabel\n parameter is the name of the menu item, the \ntype: checkbox\n  indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The \nclick\n parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling \ngui.Window.open(...)\n to open up the window layout file we've just created. The \nkey\n and \nmodifiers\n parameters indicate the keyboard shortcuts that may be used to open up the window as well.\n\n\nNow run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'. \n\n\nAwesome, you've just added a window to the app. Now lets add more functionality to it with javascript.\n\n\nAdding javascript functionality\n\n\nEvery window you add will require a starting point. A single entry-point module. For the main application it is \napp/App.js\n. For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view. \n\n\nTo begin create a file called \nnew-window.js\n inside the \napp/windows/\n folder. Then in \nnew-window.html\n file you created earlier, paste this after the \n<title>\n tag.\n\n\n<!-- Our libraries -->\n<script src=\"../app/lib/jquery-2.1.4.js\"></script>\n<script src=\"../app/lib/underscore.js\"></script>\n<script src=\"../app/lib/backbone.js\"></script>\n<script src=\"../app/lib/backbone.marionette.js\"></script>\n\n<!-- Our window entry point -->\n<script src=\"../app/windows/new-window.js\"></script>\n\n\n\n\nSo what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.\n\n\nNow lets create an element that we can play around with in our script. Under the \n<p>\n tag add of the \nnew-window.html\n file add this line:\n\n\n<div id=\"special\">Our Special div</div>\n\n\n\n\nWe've assigned an id to this div so that we can reference it later in our javascript. \n\n\nNow that we've got our layout file ready, lets add the functionality in our application entry point. In \nnew-window.js\n, add this line:\n\n\n$(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});\n\n\n\n\nNow lets go to our app and open up the window. You should see this: \n\n\n\n\nIf all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.\n\n\nDebugging\n\n\nIf your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.\n\n\nCreating the Marionette ItemView\n\n\nSo what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so. \n\n\nTo get started, create a new file called \nnewWindowView.js\n in the \napp/views/\n folder. Copy and paste this boilerplate code:\n\n\n//This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element:\"#an-example-element\" //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n      \"click #an-example-element\": \"clickCallback\"\n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};\n\n\n\n\nThen, in your \nnew-window.html\n file, delete the \n<p>\n and \n<div>\n lines, so that there is nothing in the \n<body>\n tag.\n\n\nNow create a new layout file for the view by creating a file called \nnewWindowView.html\n inside the \nviews/\n folder at the project root. Paste this in the file:\n\n\n<p>Hello I am my own view!</p>\n\n\n\n\nAnd in your \nnew-window.js\n file replace all of the code with this:\n\n\n//our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});\n\n\n\n\nNow open up the groundstation and open up your window again. You should now see this:\n\n\n\n\nExplaning Marionette and ItemViews\n\n\nSo lets do a breakdown of what we just did. \n\n\nLets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc.. \n\n\nEach ItemView has to have its own template file, which is the \nnewWindowView.html\n file we created in the \nviews/\n folder. We specify this in our ItemView by setting the \ntemplate\n property. The ItemView will render that template and then our application entry point (\nexample-window.js\n) will append it to the body of our window. Here is a diagram showing what happens:\n\n\n\n\nWhy do it this way?\n\n\nYou may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an \nMVC\n pattern, standing for Model View Controller.",
            "title": "Tutorial"
        },
        {
            "location": "/groundstation/tutorial/#groundstation-tutorial",
            "text": "This tutorial will guide you through creating a groundstation window and adding logic to it using the core application modules.",
            "title": "Groundstation Tutorial"
        },
        {
            "location": "/groundstation/tutorial/#installation",
            "text": "Follow the installation guide  here  to install the groundstation on your computer.",
            "title": "Installation"
        },
        {
            "location": "/groundstation/tutorial/#editor",
            "text": "You can use your prefered editor for this application, or an IDE like Webstorm if you prefer.",
            "title": "Editor"
        },
        {
            "location": "/groundstation/tutorial/#getting-started",
            "text": "Take a look at the  project structure  so you roughly know what each folder of the application is for.",
            "title": "Getting Started"
        },
        {
            "location": "/groundstation/tutorial/#creating-a-new-window",
            "text": "To start create a window, we need to create an html file that will represent our window. In the  window  folder at the project root, create a file and call it  new-window.html . Paste this boilerplate code on there:  <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>My new window</title>\n</head>\n<body>\n    <p>Hello this is my new window!</p>\n</body>\n</html>",
            "title": "Creating a new window"
        },
        {
            "location": "/groundstation/tutorial/#adding-a-menu-item",
            "text": "So all we've done is create a layout file for the new window. Now we've got to \nhave a way of opening the window. To do this we'll add a menu item to our application which will open up our window.   Open up  app/Menu.js . This is the file the application uses to configure it's menu items. At the bottom of the file, add this entry under the window submenu:  // ===Window Submenu ===\n    var window_submenu=new gui.Menu();\n\n    //A bunch of code here\n\n    //You need to add this\n  window_submenu.append(new gui.MenuItem({\n    label:'My new window',\n    type:'checkbox',\n    click: function(){\n      gui.Window.open('windows/new-window.html',{\n        focus: true\n      });\n    },\n    key: \"k\",\n    modifiers: \"ctrl-shift\",\n  }));  Now lets see what we just did. Calling  window_submenu.append(..)  appends a menu item to the Window menu of the app. In this case its a  gui.MenuItem  which represents a menu item in NW.js applications. The  label  parameter is the name of the menu item, the  type: checkbox   indicates that we want the menu item to behave as a checkbox (when you open the window its checked). The  click  parameter indicates the callback funtion to execute when the user has clicked on the menu item. Here, we are calling  gui.Window.open(...)  to open up the window layout file we've just created. The  key  and  modifiers  parameters indicate the keyboard shortcuts that may be used to open up the window as well.  Now run the app. In the window submenu you should see a new item called \"My new window\". When you click it a new window will appear, with the text 'Hello this is my new window!'.   Awesome, you've just added a window to the app. Now lets add more functionality to it with javascript.",
            "title": "Adding a menu item"
        },
        {
            "location": "/groundstation/tutorial/#adding-javascript-functionality",
            "text": "Every window you add will require a starting point. A single entry-point module. For the main application it is  app/App.js . For your window it'll be different. You will have to create that entry-point module and load it in the window layout file you just created. This module will then load all of its dependencies (if any) and handle creating the view.   To begin create a file called  new-window.js  inside the  app/windows/  folder. Then in  new-window.html  file you created earlier, paste this after the  <title>  tag.  <!-- Our libraries -->\n<script src=\"../app/lib/jquery-2.1.4.js\"></script>\n<script src=\"../app/lib/underscore.js\"></script>\n<script src=\"../app/lib/backbone.js\"></script>\n<script src=\"../app/lib/backbone.marionette.js\"></script>\n\n<!-- Our window entry point -->\n<script src=\"../app/windows/new-window.js\"></script>  So what are all of these scripts? They are libraries that you will end up using later in the tutorial. The main one we'll use is Marionette, and the rest are dependencies that Marionette requires, such as underscore and jquery.  Now lets create an element that we can play around with in our script. Under the  <p>  tag add of the  new-window.html  file add this line:  <div id=\"special\">Our Special div</div>  We've assigned an id to this div so that we can reference it later in our javascript.   Now that we've got our layout file ready, lets add the functionality in our application entry point. In  new-window.js , add this line:  $(document).ready(function(){\n  $('#special').text('This text was not originally written on the div! Amazing!');\n});  Now lets go to our app and open up the window. You should see this:    If all went well, you have successfully created an application entry point script for your newly created window. You are now ready to add more complex functionality to it. The next section will talk about debugging your application and implementing Marionette and MVC in your window.",
            "title": "Adding javascript functionality"
        },
        {
            "location": "/groundstation/tutorial/#debugging",
            "text": "If your window still says 'Our Special div' that means you've made a mistake. To diagnose what went wrong, you can open up the developer tools console by clicking on the three bars right next to the url bar of the window. It'll tell you if there were any javascript errors or if any files failed to load.",
            "title": "Debugging"
        },
        {
            "location": "/groundstation/tutorial/#creating-the-marionette-itemview",
            "text": "So what we did previously is use jquery directly to manipulate a div in our layout (the view). That was a pretty simple example, however continuing to work on it this way will lead to hard to maintain code, since we're mixing our view logic (ie manipulations) and our application logic together. This is something we should avoid doing, and with the help of Marionette, its pretty easy to do so.   To get started, create a new file called  newWindowView.js  in the  app/views/  folder. Copy and paste this boilerplate code:  //This is an example Marionette view\n//NOTE: you should not require jquery in your views, as you should only reference the elements inside the view which you can do with the ui property of the view\nvar Template=require('../util/Template');\n/*\ncall your other dependencies here (for example if you need to listen to network events, call this)\nvar Network=require('../Network'); \nthen use the Network object inside your view\n*/\n\nmodule.exports=function(Marionette){\n\n  return Marionette.ItemView.extend({\n    template:Template('newWindowView'), //name of the file in the views folder at the project root\n    className:'newWindowView', //this is the class name the injected div will have (refer to this class in your style sheets)\n\n    ui:{ //any ui elements in the view that you would like to reference within your view logic\n      an_element:\"#an-example-element\" //you can now refer to the jquery wrapped element within the view with this.ui.an_element\n    },\n\n    //your custom jquery events\n    //selector then the name of the callback function\n    events:{\n      \"click #an-example-element\": \"clickCallback\"\n    },\n\n    initialize: function(){\n      //called when the view is first initialized (ie new ExampleView())\n    },\n    onRender:function(){\n      //called right after a render is called on the view (view.render())\n    },\n    onBeforeDestroy:function(){\n      //called just before destroy is called on the view\n    },\n    onDestroy:function(){\n      //called right after a destroy is called on the view\n    },\n\n    clickCallback:function(event){ //will be fired when a user clicks on #an-example-element\n\n    }\n  });\n};  Then, in your  new-window.html  file, delete the  <p>  and  <div>  lines, so that there is nothing in the  <body>  tag.  Now create a new layout file for the view by creating a file called  newWindowView.html  inside the  views/  folder at the project root. Paste this in the file:  <p>Hello I am my own view!</p>  And in your  new-window.js  file replace all of the code with this:  //our new-window.js file (the window entry point)\nvar windowView=require('./app/views/newWindowView')(Marionette);\n\n$(document).ready(function(){\n  $('body').append((new windowView()).render().$el);\n});  Now open up the groundstation and open up your window again. You should now see this:",
            "title": "Creating the Marionette ItemView"
        },
        {
            "location": "/groundstation/tutorial/#explaning-marionette-and-itemviews",
            "text": "So lets do a breakdown of what we just did.   Lets start of by explaning what an ItemView is. A Marionette itemView represents..a view. The itemView manages all aspects of the view, including rendering, capturing user input, etc..   Each ItemView has to have its own template file, which is the  newWindowView.html  file we created in the  views/  folder. We specify this in our ItemView by setting the  template  property. The ItemView will render that template and then our application entry point ( example-window.js ) will append it to the body of our window. Here is a diagram showing what happens:",
            "title": "Explaning Marionette and ItemViews"
        },
        {
            "location": "/groundstation/tutorial/#why-do-it-this-way",
            "text": "You may be asking yourself what was the point of doing all the fancy stuff if the end result was the same. What we've just done is seperated our view logic and application logic into different modules. Now, say we want to create a combined window that combines our view with the map. Because all of the logic associated\nwith our view is completely isolated, there is no code that we have re-write. We simply import the views that we're interested in and inject them into our new window. This form of writing applications is called an  MVC  pattern, standing for Model View Controller.",
            "title": "Why do it this way?"
        },
        {
            "location": "/groundstation/project-structure/",
            "text": "Project Structure\n\n\nThis is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.\n\n\n/\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json\n\n\n\n\napp/\n\n\nThis is where all of the applications javascript files are located. It is the heart and soul of the groundstation.\n\n\napp/lib\n\n\nAll javascript libraries go here, including jquery, marionette, leaflet, etc..\n\n\napp/views\n\n\nApplication logic that's responsible for views. Every single view has its own file here.\n\n\nassets/\n\n\nAny binary assets are stored here\n\n\nbuild/\n\n\nThe output of running \nnpm run build\n, which creates an executable of the groundstation for every operating system.\n\n\nconfig/\n\n\nThe groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.\n\n\nlogs/\n\n\nGroundstation log output. \n\n\nlogs/data_entries/\n\n\nOutput of the logs from the Data Entry Window\n\n\nnode_modules/\n\n\nAll of the node modules installed by running \nnpm install\n are stored in here. You don't really need to be concerned about this directory.\n\n\nstyles/\n\n\nCSS directory. This is where styles go. Everything in here is a .css file.\n\n\nviews/\n\n\nTemplates for the views of the app. Everything in here is .html files.\n\n\nindex.html\n\n\nThis is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.\n\n\npackage.json\n\n\nThis file describes the application, including any dependencies that it requires. You can read more about this file \nhere\n.",
            "title": "Project Structure"
        },
        {
            "location": "/groundstation/project-structure/#project-structure",
            "text": "This is the project folder structure. Not that there are\nmore folders than listed here, however these are the most relevant.  /\n    app/\n        connections/\n        lib/\n        map/\n        models/\n        util/\n        views/\n        windows/\n    assets/\n        fonts/\n        images/\n        simulation/\n        stl/\n    build/\n    config/\n    logs/\n    node_modules/\n    styles/\n        lib/\n        views/\n    views/\n    index.html\n    package.json",
            "title": "Project Structure"
        },
        {
            "location": "/groundstation/project-structure/#app",
            "text": "This is where all of the applications javascript files are located. It is the heart and soul of the groundstation.",
            "title": "app/"
        },
        {
            "location": "/groundstation/project-structure/#applib",
            "text": "All javascript libraries go here, including jquery, marionette, leaflet, etc..",
            "title": "app/lib"
        },
        {
            "location": "/groundstation/project-structure/#appviews",
            "text": "Application logic that's responsible for views. Every single view has its own file here.",
            "title": "app/views"
        },
        {
            "location": "/groundstation/project-structure/#assets",
            "text": "Any binary assets are stored here",
            "title": "assets/"
        },
        {
            "location": "/groundstation/project-structure/#build",
            "text": "The output of running  npm run build , which creates an executable of the groundstation for every operating system.",
            "title": "build/"
        },
        {
            "location": "/groundstation/project-structure/#config",
            "text": "The groundstation config files are stored here. These config files are then dynamically loaded, stored, and persisted across the application lifecycle.",
            "title": "config/"
        },
        {
            "location": "/groundstation/project-structure/#logs",
            "text": "Groundstation log output.",
            "title": "logs/"
        },
        {
            "location": "/groundstation/project-structure/#logsdata_entries",
            "text": "Output of the logs from the Data Entry Window",
            "title": "logs/data_entries/"
        },
        {
            "location": "/groundstation/project-structure/#node_modules",
            "text": "All of the node modules installed by running  npm install  are stored in here. You don't really need to be concerned about this directory.",
            "title": "node_modules/"
        },
        {
            "location": "/groundstation/project-structure/#styles",
            "text": "CSS directory. This is where styles go. Everything in here is a .css file.",
            "title": "styles/"
        },
        {
            "location": "/groundstation/project-structure/#views",
            "text": "Templates for the views of the app. Everything in here is .html files.",
            "title": "views/"
        },
        {
            "location": "/groundstation/project-structure/#indexhtml",
            "text": "This is the starting point of the application. This file is loaded, which in turn loads the necessary javascript files required to make the application run.",
            "title": "index.html"
        },
        {
            "location": "/groundstation/project-structure/#packagejson",
            "text": "This file describes the application, including any dependencies that it requires. You can read more about this file  here .",
            "title": "package.json"
        },
        {
            "location": "/groundstation/contributing/",
            "text": "Contributing\n\n\nIn order to contribute to the groundstation you must know how to use git. Check out our tutorial \nhere\n to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.\n\n\nGetting yourself a task\n\n\nIn order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.\n\n\nAfterwords, talk to the responsible team lead, and they will assign you a task on \nasana\n.\n\n\nBranches\n\n\nIf you are working on a feature or adding anything to the groundstation, \nbranch off of master\n first, and then start working on your task.\n\nDO NOT WORK ON MASTER\n. You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.\n\n\nPlease name your branches in the following format: \n{type_of_change}-{your_name}-{title_of_task}\n\n\ntype_of_change\n is either a \nfeature\n or a \nbug\n, depending on the context of your task. For \ntitle_of_task\n, just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of:\n\nfeature-serge-pid-graph\n.\n\n\nCoding Conventions\n\n\nVariable names in lower case with underscores as seperators. eg \nthis_is_a_variable\n\n\nFunction names in camel case. For example: \nfunctionNameHere()\n\n\nConstants in all capitals seperated by underscores. eg. \nTHIS_IS_A_CONSTANT\n\n\nModule and class names in capital camel case. For example: \nThisIsAModule\n\n\nFor file names, look at the file names in the folder and follow them. \n\n\nAs a rule of thumb, when in doubt, look at the existing code and follow the same pattern.\n\n\nDocumentating your code\n\n\nMost times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.\n\n\nNote that if you're creating any sort of function, class, object, or module, \nYOU MUST DOCUMENT IT WITH JSDOC SYNTAX!\n. More information can be found in\nthe \ndocumenting section\n. Your code will not be merged in if this is not done.\n\n\nPull Requests\n\n\nAfter you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.\n\n\nYOU MUST OPEN UP PULL REQUESTS. \nNEVER\n PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!",
            "title": "Contributing"
        },
        {
            "location": "/groundstation/contributing/#contributing",
            "text": "In order to contribute to the groundstation you must know how to use git. Check out our tutorial  here  to learn how to use it.\nFollow the guidelines here if you want to contribute to the groundstation.",
            "title": "Contributing"
        },
        {
            "location": "/groundstation/contributing/#getting-yourself-a-task",
            "text": "In order to qualify yourself to work on the groundstation, you must complete the groundstation bootcamp. The bootcamp should give you a good\nunderstanding of the underlying structure of the groundstation, and help you get familiar with the code.  Afterwords, talk to the responsible team lead, and they will assign you a task on  asana .",
            "title": "Getting yourself a task"
        },
        {
            "location": "/groundstation/contributing/#branches",
            "text": "If you are working on a feature or adding anything to the groundstation,  branch off of master  first, and then start working on your task. DO NOT WORK ON MASTER . You are making your life harder if you do so, since you'll have to transfer your changes to a different branch before\nyou can make a pull request.  Please name your branches in the following format:  {type_of_change}-{your_name}-{title_of_task}  type_of_change  is either a  feature  or a  bug , depending on the context of your task. For  title_of_task , just name it something relevant.\nAs an example, say a really cool developer named Serge is working on adding a PID graph to the groundstation. The branch name would be in the form of: feature-serge-pid-graph .",
            "title": "Branches"
        },
        {
            "location": "/groundstation/contributing/#coding-conventions",
            "text": "Variable names in lower case with underscores as seperators. eg  this_is_a_variable  Function names in camel case. For example:  functionNameHere()  Constants in all capitals seperated by underscores. eg.  THIS_IS_A_CONSTANT  Module and class names in capital camel case. For example:  ThisIsAModule  For file names, look at the file names in the folder and follow them.   As a rule of thumb, when in doubt, look at the existing code and follow the same pattern.",
            "title": "Coding Conventions"
        },
        {
            "location": "/groundstation/contributing/#documentating-your-code",
            "text": "Most times your code should be verbose enough that you shouldn't need too many comments. However times may arise when your\nlogic gets too complicated, so use your judgement as a developer and comment your code where you think it is necessary. Imagine\ntrying to read the code you're writing 5 years from now, and think of how easily you'd understand it.  Note that if you're creating any sort of function, class, object, or module,  YOU MUST DOCUMENT IT WITH JSDOC SYNTAX! . More information can be found in\nthe  documenting section . Your code will not be merged in if this is not done.",
            "title": "Documentating your code"
        },
        {
            "location": "/groundstation/contributing/#pull-requests",
            "text": "After you finish implementing your feature, open up a pull request on github. Let the responsible team lead know and they will code review your changes.\nUntil the pull request is merged in, your task is not complete.  YOU MUST OPEN UP PULL REQUESTS.  NEVER  PUSH DIRECTLY TO THE MASTER BRANCH ON GITHUB!",
            "title": "Pull Requests"
        },
        {
            "location": "/groundstation/documenting/",
            "text": "Documenting\n\n\nThe ground station uses \njsdocs\n for its documentation purposes.\n\n\nIf you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of \n/** your comment */\n and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.\n\n\nA good tutorial of what it is, why we use it, and how to use it can be found here: \nhttp://speakingjs.com/es5/ch29.html\n.\n\n\nYou are required to document the necessary part of your code with this format.\n\n\nJSDoc Reference\n\n\n\n\n\n\n\n\nBlock\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n@abstract\n\u02d9(synonyms: @virtual)\n\n\nThis member must be implemented (or overridden) by the inheritor.\n\n\n\n\n\n\n@author\n\n\nIdentify the author of an item.\n\n\n\n\n\n\n@callback\n\n\nDocument a callback function.\n\n\n\n\n\n\n@class\n (synonyms: @constructor)\n\n\nThis function is intended to be called with the \"new\" keyword.\n\n\n\n\n\n\n@classdesc\n\n\nUse the following text to describe the entire class.\n\n\n\n\n\n\n@constant\n (synonyms: @const)\n\n\nDocument an object as a constant.\n\n\n\n\n\n\n@constructs\n\n\nThis function member will be the constructor for the previous class.\n\n\n\n\n\n\n@copyright\n\n\nDocument some copyright information.\n\n\n\n\n\n\n@default\n (synonyms: @defaultvalue)\n\n\nDocument the default value.\n\n\n\n\n\n\n@deprecated\n\n\nDocument that this is no longer the preferred way.\n\n\n\n\n\n\n@description\n (synonyms: @desc)\n\n\nDescribe a symbol.\n\n\n\n\n\n\n@enum\n\n\nDocument a collection of related properties.\n\n\n\n\n\n\n@event\n\n\nDocument an event.\n\n\n\n\n\n\n@example\n\n\nProvide an example of how to use a documented item.\n\n\n\n\n\n\n@exports\n\n\nIdentify the member that is exported by a JavaScript module.\n\n\n\n\n\n\n@external\n (synonyms: @host)\n\n\nIdentifies an external class or module.\n\n\n\n\n\n\n@file\n (synonyms: @fileoverview or @overview)\n\n\nDescribe a file.\n\n\n\n\n\n\n@fires\n (synonyms: @emits)\n\n\nDescribe the events this method may fire.\n\n\n\n\n\n\n@function\n (synonyms: @funco or @method)\n\n\nDescribe a function or method.\n\n\n\n\n\n\n@global\n\n\nDocument a global object.\n\n\n\n\n\n\n@ignore\n\n\nOmit a symbol from the documentation.\n\n\n\n\n\n\n@implements\n\n\nThis symbol implements an interface.\n\n\n\n\n\n\n@inheritdoc\n\n\nIndicate that a symbol should inherit its parent's documentation.\n\n\n\n\n\n\n@instance\n\n\nDocument an instance member.\n\n\n\n\n\n\n@interface\n\n\nThis symbol is an interface that others can implement.\n\n\n\n\n\n\n@lends\n\n\nDocument properties on an object literal as if they belonged to a symbol with a given name.\n\n\n\n\n\n\n@license\n\n\nIdentify the license that applies to this code.\n\n\n\n\n\n\n@listens\n\n\nList the events that a symbol listens for.\n\n\n\n\n\n\n@member\n (synonyms: @var)\n\n\nDocument a member.\n\n\n\n\n\n\n@mixin\n\n\nDocument a mixin object.\n\n\n\n\n\n\n@module\n\n\nDocument a JavaScript module.\n\n\n\n\n\n\n@name\n\n\nDocument the name of an object.\n\n\n\n\n\n\n@namespace\n\n\nDocument a namespace object.\n\n\n\n\n\n\n@override\n\n\nIndicate that a symbol overrides its parent.\n\n\n\n\n\n\n@param\n (synonyms: @arg or @argument)\n\n\nDocument the parameter to a function.\n\n\n\n\n\n\n@property\n (synonyms: @prop)\n\n\nDocument a property of an object.\n\n\n\n\n\n\n@protected\n\n\nThis symbol is meant to be protected.\n\n\n\n\n\n\n@public\n\n\nThis symbol is meant to be public.\n\n\n\n\n\n\n@readonly\n\n\nThis symbol is meant to be read-only.\n\n\n\n\n\n\n@requires\n\n\nThis file requires a JavaScript module.\n\n\n\n\n\n\n@returns\n (synonyms: @return)\n\n\nDocument the return value of a function.\n\n\n\n\n\n\n@see\n\n\nRefer to some other documentation for more information.\n\n\n\n\n\n\n@static\n\n\nDocument a static member.\n\n\n\n\n\n\n@summary\n\n\nA shorter version of the full description.\n\n\n\n\n\n\n@this\n\n\nWhat does the 'this' keyword refer to here?\n\n\n\n\n\n\n@throws\n (synonyms: @exception)\n\n\nDescribe what errors could be thrown.\n\n\n\n\n\n\n@todo\n\n\nDocument tasks to be completed.\n\n\n\n\n\n\n@tutorial\n\n\nInsert a link to an included tutorial file.\n\n\n\n\n\n\n@type\n\n\nDocument the type of an object.\n\n\n\n\n\n\n@typedef\n\n\nDocument a custom type.",
            "title": "Documenting"
        },
        {
            "location": "/groundstation/documenting/#documenting",
            "text": "The ground station uses  jsdocs  for its documentation purposes.  If you're familiar with JavaDoc or PHPDoc, then its very similar. Essentially you add comments\nto your code using a double star comment in the form of  /** your comment */  and the jsdoc \ninterpreter generates nice well-described documentation based on your source code files.  A good tutorial of what it is, why we use it, and how to use it can be found here:  http://speakingjs.com/es5/ch29.html .  You are required to document the necessary part of your code with this format.",
            "title": "Documenting"
        },
        {
            "location": "/groundstation/documenting/#jsdoc-reference",
            "text": "Block  Description      @abstract \u02d9(synonyms: @virtual)  This member must be implemented (or overridden) by the inheritor.    @author  Identify the author of an item.    @callback  Document a callback function.    @class  (synonyms: @constructor)  This function is intended to be called with the \"new\" keyword.    @classdesc  Use the following text to describe the entire class.    @constant  (synonyms: @const)  Document an object as a constant.    @constructs  This function member will be the constructor for the previous class.    @copyright  Document some copyright information.    @default  (synonyms: @defaultvalue)  Document the default value.    @deprecated  Document that this is no longer the preferred way.    @description  (synonyms: @desc)  Describe a symbol.    @enum  Document a collection of related properties.    @event  Document an event.    @example  Provide an example of how to use a documented item.    @exports  Identify the member that is exported by a JavaScript module.    @external  (synonyms: @host)  Identifies an external class or module.    @file  (synonyms: @fileoverview or @overview)  Describe a file.    @fires  (synonyms: @emits)  Describe the events this method may fire.    @function  (synonyms: @funco or @method)  Describe a function or method.    @global  Document a global object.    @ignore  Omit a symbol from the documentation.    @implements  This symbol implements an interface.    @inheritdoc  Indicate that a symbol should inherit its parent's documentation.    @instance  Document an instance member.    @interface  This symbol is an interface that others can implement.    @lends  Document properties on an object literal as if they belonged to a symbol with a given name.    @license  Identify the license that applies to this code.    @listens  List the events that a symbol listens for.    @member  (synonyms: @var)  Document a member.    @mixin  Document a mixin object.    @module  Document a JavaScript module.    @name  Document the name of an object.    @namespace  Document a namespace object.    @override  Indicate that a symbol overrides its parent.    @param  (synonyms: @arg or @argument)  Document the parameter to a function.    @property  (synonyms: @prop)  Document a property of an object.    @protected  This symbol is meant to be protected.    @public  This symbol is meant to be public.    @readonly  This symbol is meant to be read-only.    @requires  This file requires a JavaScript module.    @returns  (synonyms: @return)  Document the return value of a function.    @see  Refer to some other documentation for more information.    @static  Document a static member.    @summary  A shorter version of the full description.    @this  What does the 'this' keyword refer to here?    @throws  (synonyms: @exception)  Describe what errors could be thrown.    @todo  Document tasks to be completed.    @tutorial  Insert a link to an included tutorial file.    @type  Document the type of an object.    @typedef  Document a custom type.",
            "title": "JSDoc Reference"
        },
        {
            "location": "/groundstation/resources/",
            "text": "Additional Resources\n\n\nThe following is a list of helpful resources that you can use in case you get stuck:\n\n\nDocumentation:\n\n\n\n\nJavascript Documentation\n\n\nNW.js Documentation\n\n\nNode.js Documentation\n\n\nMarionette Documentation\n\n\nBackbone Documentation\n\n\nUnderscore Documentation\n\n\nJquery Documentation\n\n\n\n\nTutorials\n\n\n\n\nCodeAcademy Javascript course\n\n\nCodeAcademy HTML & CSS course\n\n\nCodeAcademy jQuery course\n\n\n\n\nHelp\n\n\nTheres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.\n\n\nCommon problems\n\n\nQ: A module or library or something is complaining about \nwindow\n or \ndocument\n being undefined.\n\n\nA: \nRead this section about NW.js contexts\n\n\nTips\n\n\n\n\nIf you're using windows and want a much better terminal, use \ncmder\n\n\nIf you want to consolidate all of the documentation sources together, there's a really good site called \nDevDocs.io",
            "title": "Additional Resources"
        },
        {
            "location": "/groundstation/resources/#additional-resources",
            "text": "The following is a list of helpful resources that you can use in case you get stuck:",
            "title": "Additional Resources"
        },
        {
            "location": "/groundstation/resources/#documentation",
            "text": "Javascript Documentation  NW.js Documentation  Node.js Documentation  Marionette Documentation  Backbone Documentation  Underscore Documentation  Jquery Documentation",
            "title": "Documentation:"
        },
        {
            "location": "/groundstation/resources/#tutorials",
            "text": "CodeAcademy Javascript course  CodeAcademy HTML & CSS course  CodeAcademy jQuery course",
            "title": "Tutorials"
        },
        {
            "location": "/groundstation/resources/#help",
            "text": "Theres a huge community around javascript and node.js. 99% of the issues you'll encounter you can resolve by a simple google or stack overflow search.",
            "title": "Help"
        },
        {
            "location": "/groundstation/resources/#common-problems",
            "text": "Q: A module or library or something is complaining about  window  or  document  being undefined.  A:  Read this section about NW.js contexts",
            "title": "Common problems"
        },
        {
            "location": "/groundstation/resources/#tips",
            "text": "If you're using windows and want a much better terminal, use  cmder  If you want to consolidate all of the documentation sources together, there's a really good site called  DevDocs.io",
            "title": "Tips"
        },
        {
            "location": "/zeropilot/",
            "text": "ZeroPilot Table of Contents\n\n\n\n\nPinout Reference\n\n\nHardware\n\n\nSoftware documentation coming soon",
            "title": "Table of Contents"
        },
        {
            "location": "/zeropilot/#zeropilot-table-of-contents",
            "text": "Pinout Reference  Hardware  Software documentation coming soon",
            "title": "ZeroPilot Table of Contents"
        },
        {
            "location": "/zeropilot/pinout_reference/",
            "text": "ZeroPilot Pinout Reference\n\n\nTODO: make reference for connections to sensors and such and show the pin order for each connector",
            "title": "Pinout Reference"
        },
        {
            "location": "/zeropilot/pinout_reference/#zeropilot-pinout-reference",
            "text": "TODO: make reference for connections to sensors and such and show the pin order for each connector",
            "title": "ZeroPilot Pinout Reference"
        },
        {
            "location": "/zeropilot/hardware/",
            "text": "ZeroPilot Hardware\n\n\nIntroduction\n\n\nThe Zeropilot is WARG's autopilot platform using a custom PCB and firmware. The ZeroPilot has 2 processors on board. The first one, an STM32F7 chip, is the main autopilot processing unit. It controls both low level and high level control, including PID loops, navigation control, and sensor communication. The secondary chip is a STM32F0 chip called the safety controller, which translates the receiver's PPM to PWM, and then transmits it to the main autopilot unit using I2C or SPI. It also controls the autopilot's failsafe mode, and passes the PPM straight to the PWM output so that the pilot has full control of the UAV in case of firmware bugs.\n\n\nThe ZeroPilot schematic and PCB are created using KiCad and can be found on \nWARG's Github\n.\n\n\nPCB Overview\n\n\nBelow is an overview of the sections of the PCB:\n\n\n\n\nStackup\n\n\nThe ZeroPilot is a 4 layer board. This makes routing the PCB much easier and allows the PCB to be smaller. Each layer has a designated purpose and they are connected through small plated through holes known as vias.\n\n\nLayer 1 (Top layer)\n\n\nThis layer has all the components on it including the 2 processors, power circuitry, and molex-SPOX connectors. Routing on here is minimal and is limited to critical routing for components listed below.\n\n\n\n\nDecoupling capacitors are routed on the top layer since they need to directly be connected to VCC and GND as close as possible. These capacitors smooth out the voltage into the processor and ensure there is no stray AC noise in the 3.3V power supply. There is 1 decoupling capacitor for each VCC pin.\n\n\nCrystals are routed on the top layer because the traces must remain short in order to produce a consisent and predictable frequency. Longer traces cause stray capacitance which can affect the frequency of the oscilation. It is also important that the crystals have a good ground pour surrounding them to prevent excess RF energy to be released and affect other components.\n\n\nSwitching power supplies are routed on the top layer since there is a lot of AC current caused by the 2 buck regulators. Switching regulators quickly turn on and off a switch to let current flow through the inductor, causing a consistent voltage. The feedback pin of the buck regulator allows it monitor the output voltage and change the amount of time the switch is on (its duty cycle) so that the output voltage is constant. This high frequency switching can cause a lot of RF noise, so keeping this routing on one layer helps reduce any stray RF energy.\n\n\n\n\nLayer 2\n\n\nThis layer is where most of the routing is done. There are a few important things to note when routing on this layer:\n\n\n\n\nDo not route underneath any of the 4 crystals. Layer 2 is not shielded from the RF energy of the crystals, so it can induce noise in the signal lines and corrupt communication busses.\n\n\nMake sure there are no large gaps with no copper. When the 4 layers are laminated together in the PCB fabrication process, large gaps of copper can cause the layers above to sag and deform.\n\n\nFor debugging purposes, it is helpful not to run the complete trace on layer 2. If part of the trace is routed on layer 1 or 4, those traces can be cut if there is an issue with it. If the trace is completely on layer 2 then there is no way to break the trace. However, this isn't a high priority\n\n\n\n\nLayer 3\n\n\nThis layer is the ground plane. It makes sure all the circuitry has the same ground. Any ground pin of ICs should have a via to connect the chip to this layer and should be near the ground pin of the chip. There are a couple things to note about routing on this layer:\n\n\n\n\nThere should be no routing done on this layer.\n\n\nNever route on this layer\n\n\nMake sure there isn't a single trace on this layer or else you will be shamed and exiled from WARG (not actually).\n\n\n\n\nLayer 4 (Bottom layer)\n\n\nThis layer is used for power planes and some various components. Reserving a layer for power makes routing significantly easier and minimizes resistances in the power traces.\n\n\n\n\nMake sure there are no thin spots in the power planes. Bottlenecks cause high resistance and can cause voltages to be different in different parts of the power planes\n\n\nSome components can be placed here, but they must have low Z-height so that it is easy to mount on a surface.\n\n\nMinimize components on this layer. Due to the SMD reflow process, all components on this side must be done by hand. Only put selective components on this layer when they might not always be used or are easy to solder by hand.\n\n\n\n\nPower\n\n\nThe ZeroPilot has 3 voltage regulators to power all the ICs and peripherals.\n\n\n5V External\n\n\nThe 5V external power supply powers PWM and PPM. This is because these connections have a high risk of being shorted. PWMs are not shrouded or keyed connections, so they can be connected backwards or shifted. Separating 5V external and 5V interal power supplies allows increased safety and redundancy to prevent brown-outs on the processors.\n\n\nThe 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V interal. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.\n\n\nthe PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.\n\n\n5V Internal\n\n\nThe 5V internal power supply powers the communication headers (I2C, SPI, UART), the speaker, and the 3.3V supply. It is more safe than the 5V external supply since it is routed to interal circuitry or to shrouded and keyed connectors.\n\n\nThe 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V external. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.\n\n\nthe PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.\n\n\n3.3V\n\n\nThe 3.3V power supply is a linear regulator (LDO). It power both processors, microSD card, and flash memory.\n\n\nUsing and LDO enables a smoother output voltage and smaller footprint at the cost of less efficiency. The regulator is powered off of 5V internal supply and converts the 5V down to 3.3V. LDOs are inefficient because input current = output current. This means that is it is supplying 20mA at 3.3V, the input current will be 20mA at 5V.\n\n\nSchematic Conventions\n\n\nTo make sure the schematic looks clean and consistent, we have standardized convetions for schematic design.\n\n\n\n\nKeep as much circuitry off of the main page as possible. KiCad works in hierarchical structure, so the main page should essentially be a block diagram to show how the schematic is structured\n\n\nUse busses for cleanliness. It is possible to just put net names for everything and the schematic can be connected that way. However, this is very hard to read and follow where everything is going. If the distance is short, just use lines to connect the pins together. If there are multiple similar signals (such as UART), group them into a bus so that it is visually obvious where else it connects to. It is acceptable for power to be connected only via net names.\n\n\nMake sure the schematic flows left to right. Because of how we read english, we look at the schematic from left to right. This means that all inputs should be on the left side, and all outputs should be on the right side. For example, the power circuit should always be on the left side of the schematic since it is the input for the system. PWMs are on the right since that is the final output for the system.\n\n\nMake sure to use standard WARG or KiCad attribute names. If you need a specific attribute on a part, add its name here for reference.\n\n\n\n\n-part_num: WARG's unique part number that maps to the component library\n-no_load: This parameter should be used if a component isn't always be soldered onto the board. Use the value \nNO LOAD\n to indicate this.\n\n\n\n\nWhen you fabricate a board, make a Github release and attached the gerber files to it. This makes it easy to track what is being fabricated. Do the same for the WARG-KiCad library when you order the components for the board, and attach the bill of materials to the release.\n\n\nUse common sense. Make the schematic look clean and understandable, even if it means taking a couple hours after a schematic change to make it look nice. Having an easy to understand schematic will make debugging the PCB and schematic issues a much more pleasant experience.",
            "title": "Hardware"
        },
        {
            "location": "/zeropilot/hardware/#zeropilot-hardware",
            "text": "",
            "title": "ZeroPilot Hardware"
        },
        {
            "location": "/zeropilot/hardware/#introduction",
            "text": "The Zeropilot is WARG's autopilot platform using a custom PCB and firmware. The ZeroPilot has 2 processors on board. The first one, an STM32F7 chip, is the main autopilot processing unit. It controls both low level and high level control, including PID loops, navigation control, and sensor communication. The secondary chip is a STM32F0 chip called the safety controller, which translates the receiver's PPM to PWM, and then transmits it to the main autopilot unit using I2C or SPI. It also controls the autopilot's failsafe mode, and passes the PPM straight to the PWM output so that the pilot has full control of the UAV in case of firmware bugs.  The ZeroPilot schematic and PCB are created using KiCad and can be found on  WARG's Github .",
            "title": "Introduction"
        },
        {
            "location": "/zeropilot/hardware/#pcb-overview",
            "text": "Below is an overview of the sections of the PCB:",
            "title": "PCB Overview"
        },
        {
            "location": "/zeropilot/hardware/#stackup",
            "text": "The ZeroPilot is a 4 layer board. This makes routing the PCB much easier and allows the PCB to be smaller. Each layer has a designated purpose and they are connected through small plated through holes known as vias.",
            "title": "Stackup"
        },
        {
            "location": "/zeropilot/hardware/#layer-1-top-layer",
            "text": "This layer has all the components on it including the 2 processors, power circuitry, and molex-SPOX connectors. Routing on here is minimal and is limited to critical routing for components listed below.   Decoupling capacitors are routed on the top layer since they need to directly be connected to VCC and GND as close as possible. These capacitors smooth out the voltage into the processor and ensure there is no stray AC noise in the 3.3V power supply. There is 1 decoupling capacitor for each VCC pin.  Crystals are routed on the top layer because the traces must remain short in order to produce a consisent and predictable frequency. Longer traces cause stray capacitance which can affect the frequency of the oscilation. It is also important that the crystals have a good ground pour surrounding them to prevent excess RF energy to be released and affect other components.  Switching power supplies are routed on the top layer since there is a lot of AC current caused by the 2 buck regulators. Switching regulators quickly turn on and off a switch to let current flow through the inductor, causing a consistent voltage. The feedback pin of the buck regulator allows it monitor the output voltage and change the amount of time the switch is on (its duty cycle) so that the output voltage is constant. This high frequency switching can cause a lot of RF noise, so keeping this routing on one layer helps reduce any stray RF energy.",
            "title": "Layer 1 (Top layer)"
        },
        {
            "location": "/zeropilot/hardware/#layer-2",
            "text": "This layer is where most of the routing is done. There are a few important things to note when routing on this layer:   Do not route underneath any of the 4 crystals. Layer 2 is not shielded from the RF energy of the crystals, so it can induce noise in the signal lines and corrupt communication busses.  Make sure there are no large gaps with no copper. When the 4 layers are laminated together in the PCB fabrication process, large gaps of copper can cause the layers above to sag and deform.  For debugging purposes, it is helpful not to run the complete trace on layer 2. If part of the trace is routed on layer 1 or 4, those traces can be cut if there is an issue with it. If the trace is completely on layer 2 then there is no way to break the trace. However, this isn't a high priority",
            "title": "Layer 2"
        },
        {
            "location": "/zeropilot/hardware/#layer-3",
            "text": "This layer is the ground plane. It makes sure all the circuitry has the same ground. Any ground pin of ICs should have a via to connect the chip to this layer and should be near the ground pin of the chip. There are a couple things to note about routing on this layer:   There should be no routing done on this layer.  Never route on this layer  Make sure there isn't a single trace on this layer or else you will be shamed and exiled from WARG (not actually).",
            "title": "Layer 3"
        },
        {
            "location": "/zeropilot/hardware/#layer-4-bottom-layer",
            "text": "This layer is used for power planes and some various components. Reserving a layer for power makes routing significantly easier and minimizes resistances in the power traces.   Make sure there are no thin spots in the power planes. Bottlenecks cause high resistance and can cause voltages to be different in different parts of the power planes  Some components can be placed here, but they must have low Z-height so that it is easy to mount on a surface.  Minimize components on this layer. Due to the SMD reflow process, all components on this side must be done by hand. Only put selective components on this layer when they might not always be used or are easy to solder by hand.",
            "title": "Layer 4 (Bottom layer)"
        },
        {
            "location": "/zeropilot/hardware/#power",
            "text": "The ZeroPilot has 3 voltage regulators to power all the ICs and peripherals.",
            "title": "Power"
        },
        {
            "location": "/zeropilot/hardware/#5v-external",
            "text": "The 5V external power supply powers PWM and PPM. This is because these connections have a high risk of being shorted. PWMs are not shrouded or keyed connections, so they can be connected backwards or shifted. Separating 5V external and 5V interal power supplies allows increased safety and redundancy to prevent brown-outs on the processors.  The 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V interal. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.  the PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.",
            "title": "5V External"
        },
        {
            "location": "/zeropilot/hardware/#5v-internal",
            "text": "The 5V internal power supply powers the communication headers (I2C, SPI, UART), the speaker, and the 3.3V supply. It is more safe than the 5V external supply since it is routed to interal circuitry or to shrouded and keyed connectors.  The 5V supply is power by a DC/DC buck regulator and is the same regulator as the 5V external. It is important that the inductor, boost regulator, and input capacitor are well routed and have thick traces or copper pours.  the PW_GOOD pin allows the processor to know if the power supply has failed in some way. Usually this is because of a short on the output rail.",
            "title": "5V Internal"
        },
        {
            "location": "/zeropilot/hardware/#33v",
            "text": "The 3.3V power supply is a linear regulator (LDO). It power both processors, microSD card, and flash memory.  Using and LDO enables a smoother output voltage and smaller footprint at the cost of less efficiency. The regulator is powered off of 5V internal supply and converts the 5V down to 3.3V. LDOs are inefficient because input current = output current. This means that is it is supplying 20mA at 3.3V, the input current will be 20mA at 5V.",
            "title": "3.3V"
        },
        {
            "location": "/zeropilot/hardware/#schematic-conventions",
            "text": "To make sure the schematic looks clean and consistent, we have standardized convetions for schematic design.   Keep as much circuitry off of the main page as possible. KiCad works in hierarchical structure, so the main page should essentially be a block diagram to show how the schematic is structured  Use busses for cleanliness. It is possible to just put net names for everything and the schematic can be connected that way. However, this is very hard to read and follow where everything is going. If the distance is short, just use lines to connect the pins together. If there are multiple similar signals (such as UART), group them into a bus so that it is visually obvious where else it connects to. It is acceptable for power to be connected only via net names.  Make sure the schematic flows left to right. Because of how we read english, we look at the schematic from left to right. This means that all inputs should be on the left side, and all outputs should be on the right side. For example, the power circuit should always be on the left side of the schematic since it is the input for the system. PWMs are on the right since that is the final output for the system.  Make sure to use standard WARG or KiCad attribute names. If you need a specific attribute on a part, add its name here for reference.   -part_num: WARG's unique part number that maps to the component library\n-no_load: This parameter should be used if a component isn't always be soldered onto the board. Use the value  NO LOAD  to indicate this.   When you fabricate a board, make a Github release and attached the gerber files to it. This makes it easy to track what is being fabricated. Do the same for the WARG-KiCad library when you order the components for the board, and attach the bill of materials to the release.  Use common sense. Make the schematic look clean and understandable, even if it means taking a couple hours after a schematic change to make it look nice. Having an easy to understand schematic will make debugging the PCB and schematic issues a much more pleasant experience.",
            "title": "Schematic Conventions"
        },
        {
            "location": "/network/data_relay/",
            "text": "Data Relay\n\n\nPurpose\n\n\nThe data relay is a python script that can run on any computer and is primarly run on Raspberry Pi. It is the communication link with the vehicles and the ground stations. It communicates with XBees over a serial USB connection to receive and transmit data like commands from the ground station and telemetry coming from the UAV. The relay has a TCP connection over its network to communicate with various ground devices such as ground stations, tracking antennas, computer vision software, and WARG's android app. The benefit of this system is to allow multiple planes to communicate with multiple ground stations to give flexibility and redundancy.\n\n\nSeparating the ground station from the data relay makes our system safer by ensuring the plane will still fly if a ground station fails. If the ground station fails for any reason, another ground station can take its place and continue the UAV flight. To get write access, the ground stations sends 'commander' to the ground station over the TCP connection. This extra step ensure that other applications connected to the data relay will never accidentally send a command to the plane.\n\n\nSetup\n\n\nThe installation instructions can be found in the \ngithub README.md\n. These setup instructions will assist you in setting up the Raspberry Pi to run the data relay\n\n\n1. Setup the Hardware\n\n\nStep 1... plug in the device (duh). Connect power to the Raspberry Pi. Either plug in an ethernet cable to the Pi's ethernet port or connect it to the Wifi network. Plug in the XBee via USB cable unless you are planning to just use the Xbee simulator.\n\n\n2. Connecting the the Raspberry Pi\n\n\nThere are multiple ways to connect to the Raspberry Pi:\n\n\nThe easiest way to start the data relay script is to plug in a monitor and keyboard to the Pi. A terminal window will appear where you can run commands and start the script from.\n\n\nAn SSH connection is helpful and is what is usually used on the flight line to connect to the Raspberry Pi. To do this, type the following command:\n\n\nssh root@192.168.1.103\n\nThe IP address might be slightly different, and depending on the type of Raspberry Pi it might be \npi@[IP address]\n.\n\n\nIf you do this method, type \nscreen\n as the first command. This will make sure the script will still run even if the ssh connection breaks.\n\n\nYou can also setup the raspberry Pi to start the python script on startup so you don't need to connect to it at all. There are multiple ways to do this and currently have some issues, so this will be documented once a good method is figured out.\n\n\n3. Running the script\n\n\nAssuming the script isn't configured to run on startup, use the following command to start the data relay:\n\n\nIf you used ssh, first use the \nscreen\n command.\n\n\nUse the command \npython data_relay.py\n. If it started correctly, it should print out \nwriting headers\n\n\nTo see what options are available, use \npython data_relay.py -h\n to view all the possible parameters\n\n\nManually Sending Commands\n\n\nThe data relay can recieve commands in 2 ways. The normal way to send commands is through the ground station, using a TCP network connection. However, there is a way to manually send it commands from the data relay computer.\n\n\nOnce the script is started, a command prompt should come up, starting with \n(Cmd)\n. To manually send a command, type \ncmd\n then type the command you want, or press tab to view possible commands. Send any command data after the colon. To view the format of the commands, view the \ncommands.py\n file.\n\n\nSimulator\n\n\nThe data relay has the ability to run without an Xbee connected for debuggin purposes. It uses a csv file to print out data from a previous flight to simlate plane data. Use the --simfile parameter to use the simulator:\n\n\npython data_relay.py --simfile FILENAME.csv\n\n\nThe data relay can also simulate the XBee link to the autopilot system using a USB-uart dongle. Connect a USB-uart dongle from the data relay computer to the XBee port on the autopilot board. Use the --uart command to enable this feature:\n\npython data_relay.py --uart\n\n\nNetwork Connection\n\n\nThe data relay communicates to ground stations and other apps using a TCP connection. To enable ground stations to find the data relay computer without needing its IP address, the ground station broadcasts on a UDP connection to see if there are any data relays on the network. The data relay will respond to the UDP broadcast with a UDP packet to the IP address of the broadcast. The packet will include the IP address and port number of the data relay. The port number can also be seen in the data relay logs in the terminal. After this, the ground station will connect to the TCP connection. The TCP connection is more stable than a UDP connection and has a handshake protocol to make sure the ground station is connected to the data relay.\n\n\nThe data relay can use just the TCP mode if the UDP connection is unwanted. The legacy TCP information is below. Use --legacy_port to enable this:\n\n\nIP: 192.168.1.103\nPort: 1234",
            "title": "Data Relay"
        },
        {
            "location": "/network/data_relay/#data-relay",
            "text": "",
            "title": "Data Relay"
        },
        {
            "location": "/network/data_relay/#purpose",
            "text": "The data relay is a python script that can run on any computer and is primarly run on Raspberry Pi. It is the communication link with the vehicles and the ground stations. It communicates with XBees over a serial USB connection to receive and transmit data like commands from the ground station and telemetry coming from the UAV. The relay has a TCP connection over its network to communicate with various ground devices such as ground stations, tracking antennas, computer vision software, and WARG's android app. The benefit of this system is to allow multiple planes to communicate with multiple ground stations to give flexibility and redundancy.  Separating the ground station from the data relay makes our system safer by ensuring the plane will still fly if a ground station fails. If the ground station fails for any reason, another ground station can take its place and continue the UAV flight. To get write access, the ground stations sends 'commander' to the ground station over the TCP connection. This extra step ensure that other applications connected to the data relay will never accidentally send a command to the plane.",
            "title": "Purpose"
        },
        {
            "location": "/network/data_relay/#setup",
            "text": "The installation instructions can be found in the  github README.md . These setup instructions will assist you in setting up the Raspberry Pi to run the data relay",
            "title": "Setup"
        },
        {
            "location": "/network/data_relay/#1-setup-the-hardware",
            "text": "Step 1... plug in the device (duh). Connect power to the Raspberry Pi. Either plug in an ethernet cable to the Pi's ethernet port or connect it to the Wifi network. Plug in the XBee via USB cable unless you are planning to just use the Xbee simulator.",
            "title": "1. Setup the Hardware"
        },
        {
            "location": "/network/data_relay/#2-connecting-the-the-raspberry-pi",
            "text": "There are multiple ways to connect to the Raspberry Pi:  The easiest way to start the data relay script is to plug in a monitor and keyboard to the Pi. A terminal window will appear where you can run commands and start the script from.  An SSH connection is helpful and is what is usually used on the flight line to connect to the Raspberry Pi. To do this, type the following command:  ssh root@192.168.1.103 \nThe IP address might be slightly different, and depending on the type of Raspberry Pi it might be  pi@[IP address] .  If you do this method, type  screen  as the first command. This will make sure the script will still run even if the ssh connection breaks.  You can also setup the raspberry Pi to start the python script on startup so you don't need to connect to it at all. There are multiple ways to do this and currently have some issues, so this will be documented once a good method is figured out.",
            "title": "2. Connecting the the Raspberry Pi"
        },
        {
            "location": "/network/data_relay/#3-running-the-script",
            "text": "Assuming the script isn't configured to run on startup, use the following command to start the data relay:  If you used ssh, first use the  screen  command.  Use the command  python data_relay.py . If it started correctly, it should print out  writing headers  To see what options are available, use  python data_relay.py -h  to view all the possible parameters",
            "title": "3. Running the script"
        },
        {
            "location": "/network/data_relay/#manually-sending-commands",
            "text": "The data relay can recieve commands in 2 ways. The normal way to send commands is through the ground station, using a TCP network connection. However, there is a way to manually send it commands from the data relay computer.  Once the script is started, a command prompt should come up, starting with  (Cmd) . To manually send a command, type  cmd  then type the command you want, or press tab to view possible commands. Send any command data after the colon. To view the format of the commands, view the  commands.py  file.",
            "title": "Manually Sending Commands"
        },
        {
            "location": "/network/data_relay/#simulator",
            "text": "The data relay has the ability to run without an Xbee connected for debuggin purposes. It uses a csv file to print out data from a previous flight to simlate plane data. Use the --simfile parameter to use the simulator:  python data_relay.py --simfile FILENAME.csv  The data relay can also simulate the XBee link to the autopilot system using a USB-uart dongle. Connect a USB-uart dongle from the data relay computer to the XBee port on the autopilot board. Use the --uart command to enable this feature: python data_relay.py --uart",
            "title": "Simulator"
        },
        {
            "location": "/network/data_relay/#network-connection",
            "text": "The data relay communicates to ground stations and other apps using a TCP connection. To enable ground stations to find the data relay computer without needing its IP address, the ground station broadcasts on a UDP connection to see if there are any data relays on the network. The data relay will respond to the UDP broadcast with a UDP packet to the IP address of the broadcast. The packet will include the IP address and port number of the data relay. The port number can also be seen in the data relay logs in the terminal. After this, the ground station will connect to the TCP connection. The TCP connection is more stable than a UDP connection and has a handshake protocol to make sure the ground station is connected to the data relay.  The data relay can use just the TCP mode if the UDP connection is unwanted. The legacy TCP information is below. Use --legacy_port to enable this:  IP: 192.168.1.103\nPort: 1234",
            "title": "Network Connection"
        },
        {
            "location": "/network/multi_echo/",
            "text": "Multi Echo Server\n\n\nPurpose\n\n\nThe Multi echo server is a python script that can run on any computer and is meant to be run on the raspberry pi along with the data relay. The server recieves information from a TCP connection and echos it out to all devices connected to the server via TCP connection. This allows communication between ground applications to talk to eachother.\n\n\nCurrently this script is not in use in our current setup. However, this script will likely be used for computer vision and tracking antenna communication between them and the ground station. Having this communication between ground applications enables the ground station operator to have more data about all the running scripts. For example, the multi-echo server could allow the ground station operator to send commands to the tracking antenna to initialize it, or to get data about the antenna's orientation and status. It can also be used to transmit computer vision data such as potential mission targets to the ground stations.\n\n\nNetwork\n\n\nThe network for the multi echo is setup the same as the data relay. The UDP broadcast is not yet implemented, so it always runs in legacy mode. The standard connection information is listed below:\n\n\nIP address: 192.168.1.103 (same as data relay)\n\n\nPort: 4321",
            "title": "Multi Echo"
        },
        {
            "location": "/network/multi_echo/#multi-echo-server",
            "text": "",
            "title": "Multi Echo Server"
        },
        {
            "location": "/network/multi_echo/#purpose",
            "text": "The Multi echo server is a python script that can run on any computer and is meant to be run on the raspberry pi along with the data relay. The server recieves information from a TCP connection and echos it out to all devices connected to the server via TCP connection. This allows communication between ground applications to talk to eachother.  Currently this script is not in use in our current setup. However, this script will likely be used for computer vision and tracking antenna communication between them and the ground station. Having this communication between ground applications enables the ground station operator to have more data about all the running scripts. For example, the multi-echo server could allow the ground station operator to send commands to the tracking antenna to initialize it, or to get data about the antenna's orientation and status. It can also be used to transmit computer vision data such as potential mission targets to the ground stations.",
            "title": "Purpose"
        },
        {
            "location": "/network/multi_echo/#network",
            "text": "The network for the multi echo is setup the same as the data relay. The UDP broadcast is not yet implemented, so it always runs in legacy mode. The standard connection information is listed below:  IP address: 192.168.1.103 (same as data relay)  Port: 4321",
            "title": "Network"
        },
        {
            "location": "/computer-vision/",
            "text": "Welcome to the Computer Vision Docs!\n\n\nContents\n\n\n\n\nInstallation\n\n\nBuilding the project - Linux\n\n\nBuilding the project - Windows\n\n\nCoding Conventions\n\n\nUsing the WARG Server Environment\n\n\nContributing\n\n\nWriting Tests",
            "title": "Table of Contents"
        },
        {
            "location": "/computer-vision/#welcome-to-the-computer-vision-docs",
            "text": "",
            "title": "Welcome to the Computer Vision Docs!"
        },
        {
            "location": "/computer-vision/#contents",
            "text": "Installation  Building the project - Linux  Building the project - Windows  Coding Conventions  Using the WARG Server Environment  Contributing  Writing Tests",
            "title": "Contents"
        },
        {
            "location": "/computer-vision/Installation/",
            "text": "Installation\n\n\nThe installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.\n\n\nIf you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.\n\n\n\n\nGo to \nhttps://docs.docker.com/mac/\n for Mac systems\n\n\nGo to \nhttps://docs.docker.com/windows/\n for Windows systems.\n\n\n\n\nOnce docker is installed you can get our docker image by running \ndocker pull uwarg/warg-cv\n\n\nAfter the image has been fetched:\n\n\n\n\ndocker create -it --name cv uwarg/warg-cv\n to create a new container using the warg-cv image called cv\n\n\ndocker exec -it cv bash\n to enter the container\n\n\n\n\nWhen you want to use the container again in future, use docker exec (as in step 2 above). There is no need to create a new container unless the image has changed.",
            "title": "Installation"
        },
        {
            "location": "/computer-vision/Installation/#installation",
            "text": "The installation process depends on what system you have. WARG-CV runs on Linux. However, in case you don\u2019t have Linux, we have premade a DockerFile, so that you can setup a virtual image on any system.\nYou may be able to get the project to compile on Mac OS X, but that is up to you to figure out.  If you don't have a Linux environment, don't worry! You can download a docker image. It is essentially a premade virtual machine.   Go to  https://docs.docker.com/mac/  for Mac systems  Go to  https://docs.docker.com/windows/  for Windows systems.   Once docker is installed you can get our docker image by running  docker pull uwarg/warg-cv  After the image has been fetched:   docker create -it --name cv uwarg/warg-cv  to create a new container using the warg-cv image called cv  docker exec -it cv bash  to enter the container   When you want to use the container again in future, use docker exec (as in step 2 above). There is no need to create a new container unless the image has changed.",
            "title": "Installation"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/",
            "text": "Building the Project\n\n\n1. Install Dependencies\n\n\nDependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2\n\n\n2. Clone the Repo\n\n\ngit clone https://github.com/UWARG/computer-vision.git\n\n\n\n\nIf you want to be able to submit changes you should fork the repository first and then clone your fork\n\n\ngit clone https://github.com/YOUR_NAME_HERE/computer-vision.git\n\n\n\n\n3. Configure the project with CMake\n\n\nIt is recommended to build from a separate directory to keep the source tree clean\n\n\ncd computer vision\nmkdir build\ncd build\ncmake ..\n\n\n\n\n4. Build\n\n\nmake\n\n\n\n\nBuilding individual modules\nOnce the project is configured\n\n\nmake MODULE_NAME\n\n\n\n\nFor a list of build targets including Submodules\n\n\nmake help\n\n\n\n\nRunning tests\n\n\nmake test",
            "title": "Building the project [Linux]"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#building-the-project",
            "text": "",
            "title": "Building the Project"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#1-install-dependencies",
            "text": "Dependencies:\n- OpenCV - 3.x (2.x.x is no longer supported)\n- Boost - Tested with 1.56-60, should work with earlier versions\n- ZBar\n- DecklinkSDK (Optional, if available builds support for reading video from Decklink video capture cards)\n- Exiv2",
            "title": "1. Install Dependencies"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#2-clone-the-repo",
            "text": "git clone https://github.com/UWARG/computer-vision.git  If you want to be able to submit changes you should fork the repository first and then clone your fork  git clone https://github.com/YOUR_NAME_HERE/computer-vision.git",
            "title": "2. Clone the Repo"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#3-configure-the-project-with-cmake",
            "text": "It is recommended to build from a separate directory to keep the source tree clean  cd computer vision\nmkdir build\ncd build\ncmake ..",
            "title": "3. Configure the project with CMake"
        },
        {
            "location": "/computer-vision/Building-the-project-[Linux]/#4-build",
            "text": "make  Building individual modules\nOnce the project is configured  make MODULE_NAME  For a list of build targets including Submodules  make help  Running tests  make test",
            "title": "4. Build"
        },
        {
            "location": "/computer-vision/Building-the-project-[Windows]/",
            "text": "Building the project\n\n\nTODO: Anyone who wants to try doing this, please fill this out",
            "title": "Building the project [Windows]"
        },
        {
            "location": "/computer-vision/Building-the-project-[Windows]/#building-the-project",
            "text": "TODO: Anyone who wants to try doing this, please fill this out",
            "title": "Building the project"
        },
        {
            "location": "/computer-vision/Coding-Conventions/",
            "text": "Coding Conventions\n\n\nCode\n\n\nVariable Names:\n\n\n\n\nLower camel case\n\n\n\n\ne.g. \nvarName\n\n\nConstant Names:\n\n\n\n\nUpper snake case\n\n\n\n\ne.g. \nCONST_NAME\n\n\nFunction Names:\n\n\n\n\nLower snake case\n\n\n\n\ne.g. \nfunction_name\n\n\nClass Names:\n\n\n\n\nUpper camel case\n\n\n\n\ne.g. \nClassName\n\n\nIndentation:\n\n\n\n\n4 spaces per level of indentation\n\n\nNo tabs\n\n\n\n\nBrackets:\n\n\n\n\nSingle space before opening brackets\n\n\nSingle space after closing brackets if followed by an else\n\n\nNo space before opening parentheses in function declarations/definitions\n\n\nSingle space before opening parentheses in if statements\n\n\n\n\nvoid foo_bar(int i) {\n    int varName = (i + 2)/2;\n\n    if (true) {\n\n    } else if (false) {\n\n    } else {\n\n    }\n}\n\n\n\n\nArithmetic\n\n\n\n\nNo spaces around \n*\n, \n/\n, \n%\n and operators with higher precedence than them (e.g. \n++\n, \n--\n, \n::\n, \n!\n) with the exceptions of c-style casts and the sizeof operator, which should only have a space preceding them.\n\n\nSingle space on either side of \n+\n, \n-\n and operators with lower precedence than them (e.g. \n<<\n, \n==\n, \n||\n) with the exception of comma \n,\n, which only has a space following it.\n\n\n\n\nint varName = (i + 2)/2;\nint rem = (i + 2)%2;\nint i, j;\ni = (int)(2.5*2);\nbool x = i == 2 || j == 3;\nsize_t s = sizeof(int);\nsize_t s = sizeof(x); // avoid using 'sizeof x' as it can lead to ambiguity when followed by a more complicated expression,\n\n\n\n\nFile Structure\n\n\nFile Names:\n\n\n\n\nLower snake case for source and header files, with the name of the file matching class the file contains if the file contains a class (but in lower snake case instead of upper camel case)\n\n\nNote CMake uses upper camel case for its files\n\n\nexecutables and scripts should be lower-case with a dash separating words\n\n\n\n\ne.g. header: \nfile_name.h\n\n\ne.g. executable: \nwarg-cv\n\n\nDirectory Structure:\n\n\n|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...\n\n\n\n\nHeader File Formatting\n\n\n\n\nHeader files should include a doxygen \n@file\n block identical to the one below (use correct file name)\n\n\nIf the file contains a class declaration, it should also include a doxygen \n@class\n block with at minimum a @brief description (Brief descriptions are always shown in doxygen, while long descriptions are ommitted in the brief overview of the functions and this will be blank if no \n@brief\n is included)\n\n\nAll functions in the header file should have a doxygen comment block containing at minimum a \n@brief\n description\n\n\nA longer description, if warranted, should include a description of the function's contract (i.e. the guaranteed results of the function) as well as any other information pertinent to anyone calling the function\n\n\nFunction parameters should be described with an \n@param\n description\n\n\nFunction return value should be described with an \n@returns\n description\n\n\nIf the function may throw an exception, the circumstances of this and the type of exception thrown should be described in the long description of the function\n\n\n\n\n\n\nAll variables and constants in the header file should have a doxygen comment with at minimum a \n@brief\n description\n\n\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \"bar.h\"\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief Brief description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * @brief Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nSource file formatting\n\n\n\n\nSource files should include a doxygen \n@file\n block identical to the one below (use correct file name)\n\n\nSource files are not required to have doxygen formatting, but it is recommended that you use it if declaring classes/functions/variables etc. inside the source file\n\n\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \"bar.h\"\n#include \"foo.h\"\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not required in source files\n    //     comments are greatly appreciated\n    return baz;\n}",
            "title": "Coding Conventions"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#coding-conventions",
            "text": "",
            "title": "Coding Conventions"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#code",
            "text": "",
            "title": "Code"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#variable-names",
            "text": "Lower camel case   e.g.  varName",
            "title": "Variable Names:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#constant-names",
            "text": "Upper snake case   e.g.  CONST_NAME",
            "title": "Constant Names:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#function-names",
            "text": "Lower snake case   e.g.  function_name",
            "title": "Function Names:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#class-names",
            "text": "Upper camel case   e.g.  ClassName",
            "title": "Class Names:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#indentation",
            "text": "4 spaces per level of indentation  No tabs",
            "title": "Indentation:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#brackets",
            "text": "Single space before opening brackets  Single space after closing brackets if followed by an else  No space before opening parentheses in function declarations/definitions  Single space before opening parentheses in if statements   void foo_bar(int i) {\n    int varName = (i + 2)/2;\n\n    if (true) {\n\n    } else if (false) {\n\n    } else {\n\n    }\n}",
            "title": "Brackets:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#arithmetic",
            "text": "No spaces around  * ,  / ,  %  and operators with higher precedence than them (e.g.  ++ ,  -- ,  :: ,  ! ) with the exceptions of c-style casts and the sizeof operator, which should only have a space preceding them.  Single space on either side of  + ,  -  and operators with lower precedence than them (e.g.  << ,  == ,  || ) with the exception of comma  , , which only has a space following it.   int varName = (i + 2)/2;\nint rem = (i + 2)%2;\nint i, j;\ni = (int)(2.5*2);\nbool x = i == 2 || j == 3;\nsize_t s = sizeof(int);\nsize_t s = sizeof(x); // avoid using 'sizeof x' as it can lead to ambiguity when followed by a more complicated expression,",
            "title": "Arithmetic"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#file-structure",
            "text": "",
            "title": "File Structure"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#file-names",
            "text": "Lower snake case for source and header files, with the name of the file matching class the file contains if the file contains a class (but in lower snake case instead of upper camel case)  Note CMake uses upper camel case for its files  executables and scripts should be lower-case with a dash separating words   e.g. header:  file_name.h  e.g. executable:  warg-cv",
            "title": "File Names:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#directory-structure",
            "text": "|-- computer-vision\n    |-- modules\n        |-- core\n            |-- include\n                |-- header.h\n            |-- src\n                |-- source.cpp\n            |-- CMakeLists.txt\n    |-- CMakeLists.txt\n    |-- main.cpp\n         ...",
            "title": "Directory Structure:"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#header-file-formatting",
            "text": "Header files should include a doxygen  @file  block identical to the one below (use correct file name)  If the file contains a class declaration, it should also include a doxygen  @class  block with at minimum a @brief description (Brief descriptions are always shown in doxygen, while long descriptions are ommitted in the brief overview of the functions and this will be blank if no  @brief  is included)  All functions in the header file should have a doxygen comment block containing at minimum a  @brief  description  A longer description, if warranted, should include a description of the function's contract (i.e. the guaranteed results of the function) as well as any other information pertinent to anyone calling the function  Function parameters should be described with an  @param  description  Function return value should be described with an  @returns  description  If the function may throw an exception, the circumstances of this and the type of exception thrown should be described in the long description of the function    All variables and constants in the header file should have a doxygen comment with at minimum a  @brief  description   /**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \"bar.h\"\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief Brief description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * @brief Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED",
            "title": "Header File Formatting"
        },
        {
            "location": "/computer-vision/Coding-Conventions/#source-file-formatting",
            "text": "Source files should include a doxygen  @file  block identical to the one below (use correct file name)  Source files are not required to have doxygen formatting, but it is recommended that you use it if declaring classes/functions/variables etc. inside the source file   /**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n * Copyright (c) 2015-2016, Waterloo Aerial Robotics Group (WARG)\n * All rights reserved.\n *\n * This software is licensed under a modified version of the BSD 3 clause license\n * that should have been included with this software in a file called COPYING.txt\n * Otherwise it is available at:\n * https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \"bar.h\"\n#include \"foo.h\"\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not required in source files\n    //     comments are greatly appreciated\n    return baz;\n}",
            "title": "Source file formatting"
        },
        {
            "location": "/computer-vision/Contributing/",
            "text": "Contributing\n\n\n\n\nAdding a New Class\n\n\nThe project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.\n\n\nThe class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.\n\n\nFor example: Suppose we are creating class Foo in module Core\n\n\n(See \nCoding Conventions\n for details on formatting)\n\n\nFile: modules/core/include/foo.h\n\n\n/**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \"bar.h\"\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED\n\n\n\n\nThe corresponding source file which contains the definitions for the class Foo is placed in the src folder\n\n\nFile: modules/core/src/foo.cpp\n\n\n/**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \"bar.h\"\n#include \"foo.h\"\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}\n\n\n\n\n\nHowever we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\n\n\n\n\nYour source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)\n\n\nBut what if bar is part of an external library?\n\n\nIf you've forgotten what bar is already notice that it is an external class included in foo.h\n\n\nThe first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.\n\n\nIf you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.\n\n\nFor simplicity we will assume bar.h is part of the package Bar\n\n\nFile: modules/core/CMakeLists.txt\n\n\ninclude_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()\n\n\n\n\nYou may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.\n\n\nAnd we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.\n\n\n\n\nContributing to Master Repository\n\n\nTo get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.\n\n\nYou then need to make your local code point your fork rather than master.\n\n\ngit remote set-url origin $FORK_URL\n\n\n\n\nWhere $FORK_URL is the clone link for your fork\n\n\nYou will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.\n\n\ngit remote add upstream git@github.com:UWARG/computer-vision.git\n\n\n\n\nor for https\n\n\ngit remote add upstream https://github.com/UWARG/computer-vision.git\n\n\n\n\nthis allows upstream changes to be fetched with \ngit fetch upstream\n and merged into the current branch with \ngit merge upstream/branch_name\n\n\nNow, you can commit your code and push to the fork with\n\n\ngit add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m \"Added class Foo\"\ngit push origin\n\n\n\n\nNote that it is recommended to add files individually rather than adding all at once with \ngit add -A .\n\n\nThat way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using \ngit diff\n\n\nOnce the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.\n\n\nFrom the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.\n\n\nPlease note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:\n\n\ngit config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix",
            "title": "Contributing"
        },
        {
            "location": "/computer-vision/Contributing/#contributing",
            "text": "",
            "title": "Contributing"
        },
        {
            "location": "/computer-vision/Contributing/#adding-a-new-class",
            "text": "The project is divided into modules. Any class that is specific to a certain module should be stored in that module's directory. Classes that need to be accessed by multiple modules should go in Core.  The class should be declared in a header file of the same name as the class and placed in the appropriate module's include directory.  For example: Suppose we are creating class Foo in module Core  (See  Coding Conventions  for details on formatting)  File: modules/core/include/foo.h  /**\n * @file foo.h\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#ifndef FOO_H_INCLUDED\n#define FOO_H_INCLUDED\n\n#include \"bar.h\"\n\n/**\n * @class Foo\n *\n * Foo description goes here\n *\n * @brief optional briefer description goes here\n */\n\nclass Foo : public Bar {\npublic:\n\n    /**\n     * Constructor for foo\n     *\n     * @param baz description of param baz immediately follows variable name\n     */\n    Foo(int baz);\n\n    /**\n     * Getter for baz\n     *\n     * @returns description of value returned\n     */\n    int get_baz();\n\nprivate:\n    /**\n     * Description of baz\n     */\n     int baz;\n\n};\n\n#endif // FOO_H_INCLUDED  The corresponding source file which contains the definitions for the class Foo is placed in the src folder  File: modules/core/src/foo.cpp  /**\n * @file foo.cpp\n * @author WARG\n *\n * @section LICENSE\n *\n *  Copyright (c) 2015, Waterloo Aerial Robotics Group (WARG)\n *  All rights reserved.\n *\n *  This software is licensed under a modified version of the BSD 3 clause license\n *  that should have been included with this software in a file called COPYING.txt\n *  Otherwise it is available at:\n *  https://raw.githubusercontent.com/UWARG/computer-vision/master/COPYING.txt\n */\n\n#include \"bar.h\"\n#include \"foo.h\"\n\nFoo::Foo(int baz) : baz(baz) { }\n\nint Foo::get_baz() {\n    // note that while documentation is not needed in source files\n    //     comments are greatly appreciated\n    return baz;\n}  However we're not done yet. While header files when placed in the proper directory are immediately ready for use, source files must be added to the module's CMakeLists.txt file to be compiled into the module.  File: modules/core/CMakeLists.txt  include_directories(include)\nadd_library(Core src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)  Your source file should be added to the arguments of the add_library function (ideally in retaining alphabetical order for readability)",
            "title": "Adding a New Class"
        },
        {
            "location": "/computer-vision/Contributing/#but-what-if-bar-is-part-of-an-external-library",
            "text": "If you've forgotten what bar is already notice that it is an external class included in foo.h  The first question to answer is whether or not the use of bar can be avoided. In particular it may provide functionality that is already available in one of the project's current dependencies. Unless it provides substantially improved functionality over what is already available it probably shouldn't be added to the project.  If you determine that bar is a necessary dependency, then it needs to be added to CMakeLists.txt as well. As long as it is only being used in one module, it can be defined in that module's CMakeLists.txt rather than the global CMakeLists.txt.  For simplicity we will assume bar.h is part of the package Bar  File: modules/core/CMakeLists.txt  include_directories(include)\nfind_package(Bar)\nif(Bar_FOUND)\n    include_directories(${Bar_INCLUDE_DIRS})\n    add_library(Core ${Bar_LIBRARIES} src/foo.cpp src/frame.cpp src/pixel_target.cpp src/target.cpp)\nendif()  You may want to research the library you've added online since many external libraries have additional configuration that needs to be added to the CMakeLists or unusual naming conventions for the package.  And we're done.\nNow if you re-run cmake and re-build Foo should be built into the project.",
            "title": "But what if bar is part of an external library?"
        },
        {
            "location": "/computer-vision/Contributing/#contributing-to-master-repository",
            "text": "To get your code added to master you will, if you haven't done so already, need to fork the project. This can be done by going to the computer-vision page on GitHub and clicking the fork button in the top right.  You then need to make your local code point your fork rather than master.  git remote set-url origin $FORK_URL  Where $FORK_URL is the clone link for your fork  You will also want to set a new remote, called upstream, to reference the master repository so that you can pull changes.  git remote add upstream git@github.com:UWARG/computer-vision.git  or for https  git remote add upstream https://github.com/UWARG/computer-vision.git  this allows upstream changes to be fetched with  git fetch upstream  and merged into the current branch with  git merge upstream/branch_name  Now, you can commit your code and push to the fork with  git add modules/core/src/foo.cpp modules/core/include/foo.h modules/core/CMakeLists.txt\ngit commit -m \"Added class Foo\"\ngit push origin  Note that it is recommended to add files individually rather than adding all at once with  git add -A .  That way you ensure you only commit the files you intend to add.\nYou can also see a list of all unstaged changes (changes that have yet to be added) using  git diff  Once the code is pushed, go to Github to your fork's page and create a pull request by either going into the pull request menu and choosing \"New Pull Request\", or, if you have pushed code recently, a pop-up will appear on the main page prompting you to create a pull request.  From the pull request page you can add comments to the pull request noting what you have changed, you can review the changed you have made to make sure you haven't included anything unnecessary and then you can submit the request.  Please note that pull requests will be rejected if they contain extraneous changes.\nYou can avoid a lot of issues by configuring git to ignore point out whitespace issues in diffs and to fix when patching with:  git config core.whitespace trailing-space,space-before-tab\ngit config apply.whitespace fix",
            "title": "Contributing to Master Repository"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/",
            "text": "Using the Warg Computer environment\n\n\n(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)\n\n\nSetting up an SSH Client\n\n\nBefore you can connect to the WARG Server you will need an SSH client.\n\n\nWindows:\n\n\nThere are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded \nhere\n\n\nMac OS X and Linux:\n\n\nSSH should be installed by default and can be accessed by the following terminal command\n\n\nssh user@hostname\n\n\n\n\nGetting an account\n\n\nYou will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.\n\n\nConnecting to the server\n\n\nTo connect to the WARG server you will need\n\n\nUser:\n     User-name you set up on the WARG server\n\n\nHost-name:\n ip address of the WARG computer\n\n\nPort:\n 22 (The default port, you probably won't need to set this)\n\n\nLinux and OS X\n\n\nOn Linux or OS X this translates to the following command:\n\n\nssh user@ssh.uwarg.com\n\n\n\n\nOptionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)\n\n\nssh user@ssh.uwarg.com -Y\n\n\n\n\nWindows\n\n\nOn Windows, see one of the following tutorials for more info on configuring PuTTY.\n\n\nAn older tutorial that covers the basics\n\n\nhttp://jfitz.com/tips/putty_config.html\n\n\nMore advanced PuTTY usage\n\n\nhttp://support.suso.com/supki/SSH_Tutorial_for_Windows\n\n\nUseful Commands in the Server Environment (feel free to expand this section)\n\n\n(words in ALL_CAPS are arguments)\n\n\nls\n Shows a list of files and directories in your current directory or in a different one by specifying a different directory \nls DIRECTORY\n\n\ncd DIRECTORY\n opens the given directory\n\n\nnano\n Simple command line text editor, can open files with \nnano FILE_NAME\n\n\n(for a more complex editor that is better suited to programming, try \nvim\n or \nemacs\n. \nhere\n is an emacs tutorial and \nhere\n is a vim one. There is also this fun looking interactive vim tutorial \nhere\n)\n\n\nYou can also learn more about any of the commands by appending \n--help\n to a command or by entering \nman COMMAND\n\n\nUseful Graphical Applications\n\n\ngedit\n The Gnome text editor\n\n\nnautilus\n A Linux file manager",
            "title": "Using the WARG computer environment"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#using-the-warg-computer-environment",
            "text": "(Note that at the time of this being written the server is still being set up, hence a lot of this guide is both not yet applicable and may change)",
            "title": "Using the Warg Computer environment"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#setting-up-an-ssh-client",
            "text": "Before you can connect to the WARG Server you will need an SSH client.",
            "title": "Setting up an SSH Client"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows",
            "text": "There are several windows SSH clients, one of the more popular ones is PuTTY, which can be downloaded  here",
            "title": "Windows:"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#mac-os-x-and-linux",
            "text": "SSH should be installed by default and can be accessed by the following terminal command  ssh user@hostname",
            "title": "Mac OS X and Linux:"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#getting-an-account",
            "text": "You will not be able to connect to the WARG server without an account on the system. You will have to come in personally to the WARG bay to set this up.",
            "title": "Getting an account"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#connecting-to-the-server",
            "text": "To connect to the WARG server you will need  User:      User-name you set up on the WARG server  Host-name:  ip address of the WARG computer  Port:  22 (The default port, you probably won't need to set this)",
            "title": "Connecting to the server"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#linux-and-os-x",
            "text": "On Linux or OS X this translates to the following command:  ssh user@ssh.uwarg.com  Optionally you can append -Y to the end of the command to enable graphics forwarding which will allow you to run graphical applications on the server (with the graphics being displayed on your computer)  ssh user@ssh.uwarg.com -Y",
            "title": "Linux and OS X"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#windows_1",
            "text": "On Windows, see one of the following tutorials for more info on configuring PuTTY.  An older tutorial that covers the basics  http://jfitz.com/tips/putty_config.html  More advanced PuTTY usage  http://support.suso.com/supki/SSH_Tutorial_for_Windows",
            "title": "Windows"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-commands-in-the-server-environment-feel-free-to-expand-this-section",
            "text": "(words in ALL_CAPS are arguments)  ls  Shows a list of files and directories in your current directory or in a different one by specifying a different directory  ls DIRECTORY  cd DIRECTORY  opens the given directory  nano  Simple command line text editor, can open files with  nano FILE_NAME  (for a more complex editor that is better suited to programming, try  vim  or  emacs .  here  is an emacs tutorial and  here  is a vim one. There is also this fun looking interactive vim tutorial  here )  You can also learn more about any of the commands by appending  --help  to a command or by entering  man COMMAND",
            "title": "Useful Commands in the Server Environment (feel free to expand this section)"
        },
        {
            "location": "/computer-vision/Using-the-WARG-server-environment/#useful-graphical-applications",
            "text": "gedit  The Gnome text editor  nautilus  A Linux file manager",
            "title": "Useful Graphical Applications"
        },
        {
            "location": "/computer-vision/Writing-Tests/",
            "text": "Writing Tests\n\n\nTesting should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure\n\n\n|-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg\n\n\n\n\nTesting should be done using the boost test framework.\n\n\nTutorials provided by boost are found \nhere\n.\n\n\nAPI Reference available \nhere\n\n\nTo test code it should be run inside the \nBOOST_AUTO_TEST_CASE\n and use the boost test macros to verify sanity and results.\nSome available macros include\n\n\nBOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.\n\n\n\n\nTest heirarchy\n\n\nBoost tests are stored in a heirarchy of nested suites.\nThe global suite for a file can be set with the \nBOOST_TEST_MODULE\n macro.\nYou can define additional suites by encapsulating test cases and suites with \nBOOST_AUTO_TEST_SUITE(SuiteName);\n and \nBOOST_AUTO_TEST_SUITE_END();\n\n\nNote that currently the xsl parser for generating an xUnit compatible XML file does not properly handle nested test suites and only makes use of the suite directly encapsulating the test cases (the suite declared with \nBOOST_TEST_MODULE\n).\nHowever since this is expected to be fixed relatively soon, it is recommended that you use the following format to declare tests.\n\n\nGuidelines for naming test suites and test cases\n\n\nThe global test suite for a file (specified with \nBOOST_TEST_MODULE\n) should correspond to the computer-vision module the tests are part of.\nA test suite should be created for each file with \nBOOST_AUTO_TEST_SUITE\n and should encompass all the tests in the file. Tests contained within a single file should all test a single feature or function of the program. Tests for different features/functions should go in their own file with a separate test suite. The file should also have the same name as the test suite (though test suite names should be camel cased).\n\n\nAdditional test suites can also be created inside test suites at your discretion if a certain suite has a large number of test cases that can be meaningfully subdivided.\n\n\nFor consistency, test suite and test case names should be UpperCamelCase (and test module name should be the full UpperCamelCase version of the module name. e.g. targetid should be TargetIdentification).\n\n\nAlso note that all names should be sufficiently descriptive to be unique in their scope (as well as sufficiently descriptive to convey what is being tested in a particular suite/case). That is, each test suite in a module needs to have a unique name to avoid naming conflicts, but names of test suites inside those suites and names of test cases only need to be unique inside their encapsulating test suite.\n\n\nExample\n\n\nfile: modules/mymodule/test/mysuite.cpp\n\n\n#define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE MyModule\n#include <boost/test/unit_test.hpp>\n#include \"foo.h\" // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_SUITE(MySuite);\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}\n\nBOOST_AUTO_TEST_SUITE_END();\n\n\n\n\nfile: modules/mymodule/test/CMakeLists.txt\n\n\ninclude_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME \"example test\"\n    COMMAND mytest --log_format=XML --log_sink=TEST-mytest.xml --log_level=all --report_level=no\n)",
            "title": "Writing Tests"
        },
        {
            "location": "/computer-vision/Writing-Tests/#writing-tests",
            "text": "Testing should be done in a directory inside the submodule called test, which should be included in the module's CMakeLists.txt via add_subdirectory and should have its own CMakeLists.txt.\nFurthermore, large test files should be stored in the global computer-vision/testdata directory so that they can be shared between multiple tests.\nThat is, test directories should have the following structure  |-- computer-vision\n    |-- modules\n        |-- MODULE_NAME\n            |-- include\n            |-- src\n            |-- test\n                |-- CMakeLists.txt\n                |-- foo_test.cpp\n                |-- bar_test.cpp\n            |-- CMakeLists.txt\n    |-- testdata\n        |-- image.jpg  Testing should be done using the boost test framework.  Tutorials provided by boost are found  here .  API Reference available  here  To test code it should be run inside the  BOOST_AUTO_TEST_CASE  and use the boost test macros to verify sanity and results.\nSome available macros include  BOOST_WARN(predicate); // produces a warning if predicate is false, does not cause failures\nBOOST_CHECK(predicate); // produces a failure if predicate is false, but continues testing\nBOOST_REQUIRE(predicate); // produces a failure if predicate is false and aborts test suite.",
            "title": "Writing Tests"
        },
        {
            "location": "/computer-vision/Writing-Tests/#test-heirarchy",
            "text": "Boost tests are stored in a heirarchy of nested suites.\nThe global suite for a file can be set with the  BOOST_TEST_MODULE  macro.\nYou can define additional suites by encapsulating test cases and suites with  BOOST_AUTO_TEST_SUITE(SuiteName);  and  BOOST_AUTO_TEST_SUITE_END();  Note that currently the xsl parser for generating an xUnit compatible XML file does not properly handle nested test suites and only makes use of the suite directly encapsulating the test cases (the suite declared with  BOOST_TEST_MODULE ).\nHowever since this is expected to be fixed relatively soon, it is recommended that you use the following format to declare tests.",
            "title": "Test heirarchy"
        },
        {
            "location": "/computer-vision/Writing-Tests/#guidelines-for-naming-test-suites-and-test-cases",
            "text": "The global test suite for a file (specified with  BOOST_TEST_MODULE ) should correspond to the computer-vision module the tests are part of.\nA test suite should be created for each file with  BOOST_AUTO_TEST_SUITE  and should encompass all the tests in the file. Tests contained within a single file should all test a single feature or function of the program. Tests for different features/functions should go in their own file with a separate test suite. The file should also have the same name as the test suite (though test suite names should be camel cased).  Additional test suites can also be created inside test suites at your discretion if a certain suite has a large number of test cases that can be meaningfully subdivided.  For consistency, test suite and test case names should be UpperCamelCase (and test module name should be the full UpperCamelCase version of the module name. e.g. targetid should be TargetIdentification).  Also note that all names should be sufficiently descriptive to be unique in their scope (as well as sufficiently descriptive to convey what is being tested in a particular suite/case). That is, each test suite in a module needs to have a unique name to avoid naming conflicts, but names of test suites inside those suites and names of test cases only need to be unique inside their encapsulating test suite.",
            "title": "Guidelines for naming test suites and test cases"
        },
        {
            "location": "/computer-vision/Writing-Tests/#example",
            "text": "file: modules/mymodule/test/mysuite.cpp  #define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE MyModule\n#include <boost/test/unit_test.hpp>\n#include \"foo.h\" // declares type foo, header is in the core module\n\nBOOST_AUTO_TEST_SUITE(MySuite);\n\nBOOST_AUTO_TEST_CASE(TestName) {\n    foo bar;\n    BOOST_CHECK(foo.baz());\n}\n\nBOOST_AUTO_TEST_SUITE_END();  file: modules/mymodule/test/CMakeLists.txt  include_directories(${Core_INCLUDE_DIR})\nadd_executable(mytest test.cpp)\ntarget_link_libraries(mytest Core)\n\n# Tests\nadd_test(\n    NAME \"example test\"\n    COMMAND mytest --log_format=XML --log_sink=TEST-mytest.xml --log_level=all --report_level=no\n)",
            "title": "Example"
        },
        {
            "location": "/mechanical/",
            "text": "Welcome to the Mechanical Docs!\n\n\nTable of Contents\n\n\n\n\nGrabCad\n\n\nCAD Guidelines and Commandments\n\n\n3D Printing Guidelines",
            "title": "Table of Contents"
        },
        {
            "location": "/mechanical/#welcome-to-the-mechanical-docs",
            "text": "",
            "title": "Welcome to the Mechanical Docs!"
        },
        {
            "location": "/mechanical/#table-of-contents",
            "text": "GrabCad  CAD Guidelines and Commandments  3D Printing Guidelines",
            "title": "Table of Contents"
        },
        {
            "location": "/mechanical/cad-guidelines/",
            "text": "WARG CAD Guidelines\n\n\nTo keep things more consistent at WARG, we enforce a set of guidelines on all submitted CAD designs. This only applies to mechanical CAD files (not electrical). Since we use Solidworks for most of our mechanical work, these guidelines mainly apply to it. \n\n\nThe 13 CAD Commandments\n\n\nIn order for your design to be accepted it must adhere to all the commandments listed below. If the part does not you will be notified what modifications need to be made in order for it to be accepted. Once your part is accepted you can begin to manufacturer/make the part. If an assembly of parts is being made all parts and the assembly must be approved before manufacturing/making the assembly.\n\n\n\n\nAll parts (sketches) must be fully defined\n\n\nAll fastening holes (screw, bolt etc.. holes) must be done using hole wizard\n\n\nUse relations to eliminate redundant dimensions\n\n\nParts must be made in MMGS scale\n\n\nParts must use \nWARG\u2019s standard naming convention\n\n\nAssemblies must contain ALL components fully defined and related such that distances are equal\n\n\nAssemblies must have ALL holes concentric with fasteners of required length mated to the holes (check McMaster Carr if you need CAD models of fasteners)\n\n\nNO assembly features\n\n\nWhen making part revisions look at the previous version and identify any filing/drilling/sanding/machining you had to do to the parts to make them fit and ENSURE that the new part is modified so that the changes don\u2019t have to be made again.\n\n\nFillets/Chamfers of equal size must be made in the SAME feature. All fillets/chamfers must be added as features and NOT included in the sketches.\n\n\nEnsure that your assemblies are manufacturable with appropriate tolerances (ie parts have clearance to be assembled and parts don\u2019t have to go through walls/break physics to work).\n\n\nConsider the thickness and dimensions of parts to ensure that they are reasonable. A 3mm and 5mm thickness go a long way.\n\n\nAll of the relevant CAD files should be uploaded and synced on \nGrabCad\n. The design will \nNOT BE REVIEWED\n if it is not on GrabCad. Screenshots and stl files do not suffice.\n\n\n\n\nNOTE\n: \nIf you violate one of these commandments you must notify a team lead with a valid explanation as to the reason for violating the commandment\n\n\nCAD Naming Convention\n\n\nAll CAD files should adhere to the following naming convention (snake upper case):\n\n\nFor regular part files\n\n\n<PROJECT_NAME>__<SUBASSEMBLY_NAME>_<PART##>_<PART_NAME>.SLDPRT\n\n\n\n\neg. \nSPIKE__GIMBAL_03_OUTSIDE_CASE.SLDPRT\n\n\nFor assemblies\n\n\n<PROJECT_NAME>__<SUBASSEMBLY_NAME>_00_ASSEMBLY.SLDASM\n\n\n\n\neg. \nSPIKE__GIMBAL_00_ASSEMBLY.SLDASM\n\n\nFor assemblies within assemblies\n\n\nCreate a folder with the same naming convention as the part, and follow the same naming convention inside the folder, prepending the project name.\n\n\nFor example, if the gimbal assembly contains a part camera which itself is also an assembly:\n\n\n\n\nCreate folder named \nGIMBAL_02_CAMERA\n\n\nInside the folder follow the same naming convention, but prepend the original project name at the begining.\n\n\n\n\neg.\n\n\nGIMBAL_00_ASSEMBLY.SLDASM\nGIMBAL_O1_CAMERA\n --> GIMBAL_CAMERA_00_ASSEMBLY.SLDASM\n --> GIMBAL_CAMERA_01_GO_PRO.SLDPRT\n\n\n\n\nFor drawings\n\n\nIn the assembly folder create another folder to store drawings.\n\n\n<PROJECT_NAME>_DRAWINGS\n\n\n\n\nFor the actual part files, follow the same naming convention as above, and store them in this folder.\n\n\nRenders\n\n\nCreate a seperate \nRenders\n folder within your project and dump all your renders there. No naming convention here\n\n\nExample\n\n\nProject Name: DATA_RELAY_CASE\n\n\nSub Assemblies: Wooden Case, OrangePi\n\n\nProject Root\n\n\n\n\nSub-assembly",
            "title": "CAD Guidelines"
        },
        {
            "location": "/mechanical/cad-guidelines/#warg-cad-guidelines",
            "text": "To keep things more consistent at WARG, we enforce a set of guidelines on all submitted CAD designs. This only applies to mechanical CAD files (not electrical). Since we use Solidworks for most of our mechanical work, these guidelines mainly apply to it.",
            "title": "WARG CAD Guidelines"
        },
        {
            "location": "/mechanical/cad-guidelines/#the-13-cad-commandments",
            "text": "In order for your design to be accepted it must adhere to all the commandments listed below. If the part does not you will be notified what modifications need to be made in order for it to be accepted. Once your part is accepted you can begin to manufacturer/make the part. If an assembly of parts is being made all parts and the assembly must be approved before manufacturing/making the assembly.   All parts (sketches) must be fully defined  All fastening holes (screw, bolt etc.. holes) must be done using hole wizard  Use relations to eliminate redundant dimensions  Parts must be made in MMGS scale  Parts must use  WARG\u2019s standard naming convention  Assemblies must contain ALL components fully defined and related such that distances are equal  Assemblies must have ALL holes concentric with fasteners of required length mated to the holes (check McMaster Carr if you need CAD models of fasteners)  NO assembly features  When making part revisions look at the previous version and identify any filing/drilling/sanding/machining you had to do to the parts to make them fit and ENSURE that the new part is modified so that the changes don\u2019t have to be made again.  Fillets/Chamfers of equal size must be made in the SAME feature. All fillets/chamfers must be added as features and NOT included in the sketches.  Ensure that your assemblies are manufacturable with appropriate tolerances (ie parts have clearance to be assembled and parts don\u2019t have to go through walls/break physics to work).  Consider the thickness and dimensions of parts to ensure that they are reasonable. A 3mm and 5mm thickness go a long way.  All of the relevant CAD files should be uploaded and synced on  GrabCad . The design will  NOT BE REVIEWED  if it is not on GrabCad. Screenshots and stl files do not suffice.   NOTE :  If you violate one of these commandments you must notify a team lead with a valid explanation as to the reason for violating the commandment",
            "title": "The 13 CAD Commandments"
        },
        {
            "location": "/mechanical/cad-guidelines/#cad-naming-convention",
            "text": "All CAD files should adhere to the following naming convention (snake upper case):",
            "title": "CAD Naming Convention"
        },
        {
            "location": "/mechanical/cad-guidelines/#for-regular-part-files",
            "text": "<PROJECT_NAME>__<SUBASSEMBLY_NAME>_<PART##>_<PART_NAME>.SLDPRT  eg.  SPIKE__GIMBAL_03_OUTSIDE_CASE.SLDPRT",
            "title": "For regular part files"
        },
        {
            "location": "/mechanical/cad-guidelines/#for-assemblies",
            "text": "<PROJECT_NAME>__<SUBASSEMBLY_NAME>_00_ASSEMBLY.SLDASM  eg.  SPIKE__GIMBAL_00_ASSEMBLY.SLDASM",
            "title": "For assemblies"
        },
        {
            "location": "/mechanical/cad-guidelines/#for-assemblies-within-assemblies",
            "text": "Create a folder with the same naming convention as the part, and follow the same naming convention inside the folder, prepending the project name.  For example, if the gimbal assembly contains a part camera which itself is also an assembly:   Create folder named  GIMBAL_02_CAMERA  Inside the folder follow the same naming convention, but prepend the original project name at the begining.   eg.  GIMBAL_00_ASSEMBLY.SLDASM\nGIMBAL_O1_CAMERA\n --> GIMBAL_CAMERA_00_ASSEMBLY.SLDASM\n --> GIMBAL_CAMERA_01_GO_PRO.SLDPRT",
            "title": "For assemblies within assemblies"
        },
        {
            "location": "/mechanical/cad-guidelines/#for-drawings",
            "text": "In the assembly folder create another folder to store drawings.  <PROJECT_NAME>_DRAWINGS  For the actual part files, follow the same naming convention as above, and store them in this folder.",
            "title": "For drawings"
        },
        {
            "location": "/mechanical/cad-guidelines/#renders",
            "text": "Create a seperate  Renders  folder within your project and dump all your renders there. No naming convention here",
            "title": "Renders"
        },
        {
            "location": "/mechanical/cad-guidelines/#example",
            "text": "Project Name: DATA_RELAY_CASE  Sub Assemblies: Wooden Case, OrangePi",
            "title": "Example"
        },
        {
            "location": "/mechanical/cad-guidelines/#project-root",
            "text": "",
            "title": "Project Root"
        },
        {
            "location": "/mechanical/cad-guidelines/#sub-assembly",
            "text": "",
            "title": "Sub-assembly"
        },
        {
            "location": "/mechanical/3d-printing-guidelines/",
            "text": "Guide to 3D Printing\n\n\nGeneral guidelines and requirements for 3D printing:\n\n\n\n\nGet your \nWATIMAKE 3D print certification\n.\n\n\nKeep in mind the orientation of the 3D print to maximize strength of the part, minimize support materials, and maximize feature accuracy.\n\n\nConsider the maximum build volume of the printer\n\n\nKeep in mind warping \u2013 the back part of the printer nearer to the extruder is warmer. Maintaining constant temperature will prevent warping due to rapid cooling. Therefore, if certain features are important put them closer to the extruder than the door to maintain a constant environment.\n\n\nConsider splitting large parts into multiple parts and using flanges/mating features to appropriately to attach together.\n\n\nConsider the material your using. ABS is more prone to warping and is no brittle. PLA warps less and is brittle.\n\n\nFilament is not cheap \u2013 consider the amount if infill, you should not be using more than 30% for a structural part.\n\n\nConsider the amount of shells (number of outer layers before infill begins) that you need 4-6 layers is appropriate.",
            "title": "3D Printing Guidelines"
        },
        {
            "location": "/mechanical/3d-printing-guidelines/#guide-to-3d-printing",
            "text": "General guidelines and requirements for 3D printing:   Get your  WATIMAKE 3D print certification .  Keep in mind the orientation of the 3D print to maximize strength of the part, minimize support materials, and maximize feature accuracy.  Consider the maximum build volume of the printer  Keep in mind warping \u2013 the back part of the printer nearer to the extruder is warmer. Maintaining constant temperature will prevent warping due to rapid cooling. Therefore, if certain features are important put them closer to the extruder than the door to maintain a constant environment.  Consider splitting large parts into multiple parts and using flanges/mating features to appropriately to attach together.  Consider the material your using. ABS is more prone to warping and is no brittle. PLA warps less and is brittle.  Filament is not cheap \u2013 consider the amount if infill, you should not be using more than 30% for a structural part.  Consider the amount of shells (number of outer layers before infill begins) that you need 4-6 layers is appropriate.",
            "title": "Guide to 3D Printing"
        },
        {
            "location": "/mechanical/grabcad/",
            "text": "GrabCad\n\n\nHere at WARG we use \nGrabCad Workbench\n for all of our CAD file management. It is a service like Google Drive and Github that's specially designed for sharing CAD files.\n\n\nNOTE\n: \nWe require that all CAD files (non-bootcamp) are uploaded to GrabCad. Please Do not directly send screenshots, stl files, or solidworks files directly to team leads or review! Send them the grabcad link instead\n\n\nFeatures\n\n\nGrabCad is completely free, and features:\n\n\n\n\nSyncing CAD files\n\n\nViewing CAD files from within a web browser\n\n\nRevision storage and rollback\n\n\nAttaching comments to files\n\n\n\n\nThat revision storage is a big one. We no longer have to have multiple files delimited by versions. Grabcad lets you view and rollback to previous version of the CAD file, in case something goes wrong.\n\n\nHow it works\n\n\nMuch like Github, GrabCad creates a new revision of the file when it detects a change in the file. GrabCad doesn't sync automatically, and instead waits for you to issue an upload. It does this so that a single file doesnt have hundreds of revisions from every time you've saved the file.\n\n\nHow to get started\n\n\nAfter you've completed the bootcamp, you will be able granted access to the WARG GrabCad.\n\n\nTo do this:\n\n\n\n\nSign up here: \nworkbench.grabcad.com\n\n\nRequest that a team lead send you a GrabCad invite to the WARG group\n\n\nDownload and install the \nGrabCad desktop app",
            "title": "GrabCad"
        },
        {
            "location": "/mechanical/grabcad/#grabcad",
            "text": "Here at WARG we use  GrabCad Workbench  for all of our CAD file management. It is a service like Google Drive and Github that's specially designed for sharing CAD files.  NOTE :  We require that all CAD files (non-bootcamp) are uploaded to GrabCad. Please Do not directly send screenshots, stl files, or solidworks files directly to team leads or review! Send them the grabcad link instead",
            "title": "GrabCad"
        },
        {
            "location": "/mechanical/grabcad/#features",
            "text": "GrabCad is completely free, and features:   Syncing CAD files  Viewing CAD files from within a web browser  Revision storage and rollback  Attaching comments to files   That revision storage is a big one. We no longer have to have multiple files delimited by versions. Grabcad lets you view and rollback to previous version of the CAD file, in case something goes wrong.",
            "title": "Features"
        },
        {
            "location": "/mechanical/grabcad/#how-it-works",
            "text": "Much like Github, GrabCad creates a new revision of the file when it detects a change in the file. GrabCad doesn't sync automatically, and instead waits for you to issue an upload. It does this so that a single file doesnt have hundreds of revisions from every time you've saved the file.",
            "title": "How it works"
        },
        {
            "location": "/mechanical/grabcad/#how-to-get-started",
            "text": "After you've completed the bootcamp, you will be able granted access to the WARG GrabCad.  To do this:   Sign up here:  workbench.grabcad.com  Request that a team lead send you a GrabCad invite to the WARG group  Download and install the  GrabCad desktop app",
            "title": "How to get started"
        },
        {
            "location": "/picpilot/",
            "text": "Welcome to the PicPilot wiki!\n\n\nThis site is to document all the functions and required background knowledge about the autopilot system.\n\n\n\n\nIntroduction\n\n\nSetup\n\n\nC\n\n\nProgramming the Device\n\n\nAutopilot System Overview\n\n\nSchematics and Board Design\n\n\nProject Files\n\n\nCoding Convention\n\n\n\n\n\n\nPID Loops\n\n\nPWM I/O\n\n\nUniversal Asynchronous Receive/Transmit (UART)\n\n\nSerial Peripheral Interface (SPI)\n\n\nDirect Memory Access (DMA)\n\n\nInter-Interchip Communication (I2C)\n\n\nDatalink\n\n\nAnalog-to-Digital Converter (ADC)\n\n\nSensors and Peripherals\n\n\nGPS(MEDIATEK-3329)\n\n\nIMU (VectorNav-100)\n\n\nAltimeter (MPL3115A2)\n\n\nXBEE PRO S3B\n\n\nRC Receiever (EzUHF)\n\n\nAirspeed Sensor (To be implemented)\n\n\nUltrasonic Sensor (To be implemented)\n\n\n\n\n\n\nAttitude Control\n\n\nPath Management\n\n\nFAQ - WIP\n\n\n\n\nBackground Reading\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help",
            "title": "Table of Contents"
        },
        {
            "location": "/picpilot/#welcome-to-the-picpilot-wiki",
            "text": "This site is to document all the functions and required background knowledge about the autopilot system.   Introduction  Setup  C  Programming the Device  Autopilot System Overview  Schematics and Board Design  Project Files  Coding Convention    PID Loops  PWM I/O  Universal Asynchronous Receive/Transmit (UART)  Serial Peripheral Interface (SPI)  Direct Memory Access (DMA)  Inter-Interchip Communication (I2C)  Datalink  Analog-to-Digital Converter (ADC)  Sensors and Peripherals  GPS(MEDIATEK-3329)  IMU (VectorNav-100)  Altimeter (MPL3115A2)  XBEE PRO S3B  RC Receiever (EzUHF)  Airspeed Sensor (To be implemented)  Ultrasonic Sensor (To be implemented)    Attitude Control  Path Management  FAQ - WIP",
            "title": "Welcome to the PicPilot wiki!"
        },
        {
            "location": "/picpilot/#background-reading",
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help",
            "title": "Background Reading"
        },
        {
            "location": "/picpilot/introduction/",
            "text": "Introduction\n\n\nThe PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by \nMicrochip\n. The microcontroller that is currently supported is the \ndspic33fj256gp710A\n. However, many other similar models can be easily adapted for support.\n\n\nThis software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics \nhere\n. The schematics are also included in another section of this document.\n\n\nThe two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.\n\n\nSetup\n\n\nTo get started, you will need three things:\n\n\n\n\n\n\nA Git Client\n\n\n\n\n\n\nMPLAB XC16 Compiler (16-bit)\n\n\n\n\n\n\n(Optional) MPLAB X IDE\n\n\n\n\n\n\nGithub Setup\n\n\nA similar powerpoint presentation can be found here:\nhttps://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing\n\n\nIf you are not using the GUI skip this section.\n\n\n\n\nSetup a \nGithub\n Account\n\n\nSelect \"Set up Git\"\n\n\nSelect \"Download GitHub for \n\"\n\n\nSelect \"Run\" and continue through the installation process\n\n\nOnce the installation is complete, launch the application.\n\n\nLog in\n\n\nFind the Git Bash shell and type in the following commands:\n\n\ngit config global user.name \"YOUR USERNAME HERE\"\n\n\ngit config global user.email \"YOUR EMAIL HERE\"\n\nThese set the default name and email you use when committing to GitHub.\n\n\nAt this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.\n\n\nYou should then be able to clone the project using the clone button, or the project URL.  \n\n\n\n\nYou should now have the code. \n\n\nMPLAB Setup\n\n\nYou now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.\n\n\nCompiler\n\n\n\n\nDownload the \ncompiler\n. You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.\n\n\nAccept the license agreement.\n\n\nSelect \"Install Compiler\".\n\n\nSelect \"Install MPLAB XC16 C Compiler on this computer.\n\n\nLeave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.\n\n\nSelect \"Run the compiler in free mode\".\n\n\nSelect the installation directory.\n\n\n\n\nRun and finish the installation.\n\n\n\n\n\n\nNote whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).\n\n\n\n\n\n\nIDE (The fancy word editor that lets you do some code-shenanigans)\n\n\n\n\nDownload the \nIDE Package\n. You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.\n\n\nProceed through the installation process (select installation directory, accept license agreement).\n\n\n\n\nGitHub Usage\n\n\nIf you don't know how to use Git or you need a reference, \nGitImmersion\n is a great website.\n\n\nGUI Usage:\n\n\n\n\nMake sure you have correctly set your default storage location in the Options menu.  \n\n\n\n\nSaving Files (Committing and Pushing)\n  \n\n\n\n\nSelect your Project\n\n\nSelect the files that are supposed to be committed.\n\n\nWrite a commit message, that gives a general overview about each change completed in this update.\n\n\nHit \"Commit\".\n\n\nOnce you are ready to sync the changes, hit the sync button (top of the window).\n\n\n\n\nReading Files from the Server (Pulling)\n\n* Simply click the sync button at top of the window.\n\n\nGeneral Syntax (Git Bash):\n\n\n\n\ngit add <Filename> or git add .\n stages the file for commit.\n\n\ngit status\n displays all changes being made.\n\n\ngit commit -m \"<Commit message here>\"\n makes the change.\n\n\ngit push\n sends the change to the server\n\n\ngit pull\n retrieves the latest change from the server.\n\n\ngit checkout <HASH>\n retrieves a SPECIFIC version from the server.\n\n\ngit checkout -b <Branch Name>\n creates a new branch.\n\n\ngit merge master\n merges the current branch with the latest code.\n\n\n\n\nGeneral Concepts:\n\n\n\n\nWhen making small changes it is okay to commit to the master branch.\n\n\nWhen making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.\n\n\nAlways build your code before committing (To make sure it isn't broken).\n\n\nTry and get rid of warnings if possible.\n\n\n\n\nC (Programming Language)\n\n\nThe language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.\n\n\nThe compiler used for this project is listed above. It is a modified version of the GCC Compiler.\n\n\nA set of well maintained tutorials can be found here: \nhttp://www.cprogramming.com/tutorial/c/lesson1.html\n\n\nTopics that one should be familiar with include (in order of importance):\n\n\n\n\nIf statements\n\n\nLooping\n\n\nFunctions\n\n\nVariable types and how they work\n\n\nArrays\n\n\nPointers\n\n\nStructures, Unions\n\n\n\n\nUnrelated topics:\n\n\n\n\nPrintf (There is no GUI)\n\n\nFile I/O (All I/O operations are specific to the chip)\n\n\n\n\nKnowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.\n\n\nProgramming the Device\n\n\nIn order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.\n\n\nWhen using the MPLAB X GUI the process to program the device is as follows:\n\n\n-\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.\n\n\nWhen using your own editor and compiling from the command line:\n\n\n-\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).\n\n\nIf you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.\n\n\nAutopilot System Overview\n\n\nThe autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.\n\n\nFirst of all, the flowchart block diagram of the system is presented below:\n\n\n\n\nFrom this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.\n\n\nThere are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.\n\n\nThere are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.\n\n\nThe outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).\n\n\nThis document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.\n\n\n\n\nSchematics and Board Design\n\n\nThe following schematic is V2.1 of the PicPilot. You can check out the board schematics \non GrabCAD\n. You will require \nDiptrace\n in order to view the files. You can use the free version or use WARG's \"Pro\" license.\n\n\n\n\nThis board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:\n\n\n\n\n\n\n\n\nSwitching Power Supply 1\n\n\n\n\n\n\nSwitching Power Supply 2\n\n\n\n\n\n\nBattery Port\n\n\n\n\n\n\nExternal Battery Monitor\n\n\n\n\n\n\nAnalog sensors: airspeed and ultrasonic\n\n\n\n\n\n\nUART2 Port -\u0093 Unused\n\n\n\n\n\n\nPath Manager Debug\n\n\n\n\n\n\nPath Manager Programming Port\n\n\n\n\n\n\nI2C- Altimeter\n\n\n\n\n\n\nSPI Ports: Top- GPS, Bottom- Unused\n\n\n\n\n\n\nMicrocontroller 2 -\u0093 Path Manager\n\n\n\n\n\n\nSPI -IMU\n\n\n\n\n\n\nUART2- Xbee\n\n\n\n\n\n\nAttitude Manager Programming Port\n\n\n\n\n\n\nMicrocontroller 2 - Attitude Manager\n\n\n\n\n\n\nAttitude Manager Debug\n\n\n\n\n\n\nRelay Controller Programmer Port\n\n\n\n\n\n\nSafety Relays (Inputs 1-4)\n\n\n\n\n\n\nI2C - PWM Extension\n\n\n\n\n\n\nPWM Outputs\n\n\n\n\n\n\nPWM Inputs\n\n\n\n\n\n\nTo get a full list of the different pins, look at the schematic on GrabCad. Highlighted below are the ground connections (and you are politely reminded to NEVER connect these pins to anything but ground, always check before connecting cables).\n\n\n\n\nProject files\n\n\nAll the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):\n\n\n\n\nAttitudeManager.c\n\n\nAttitudeManager.h\n\n\ncameraManager.c\n\n\ncameraManager.h\n\n\nClock.c\n\n\nClock.h\n\n\ncommands.h\n\n\ndebug.c\n\n\ndebug.h\n\n\ndelay.c\n\n\ndelay.h\n\n\nfmath.c\n\n\nfmath.h\n\n\nFullInitialize.c\n\n\nFullInitialize.h\n\n\nI2C.c\n\n\nI2C.h\n\n\nInputCapture.c\n\n\nInputCapture.h\n\n\nInterchipDMA.c\n\n\nInterchipDMA.h\n\n\nlcd.h\n\n\nmain.c\n\n\nmain.h\n\n\nMPL3115A2.c\n\n\nMPL3115A2.h\n\n\nnet.h\n\n\nnet_common.c\n\n\nnet_inbound.c\n\n\nnet_outbound.c\n\n\nOrientationControl.c\n\n\nOrientationControl.h\n\n\nOutputCompare.c\n\n\nOutputCompare.h\n\n\nPathManager.h\n\n\nPathManager.c\n\n\nPWM.c\n\n\nPWM.h\n\n\nSPI.c\n\n\nStartupErrorCodes.c\n\n\nStartupErrorCodes.h\n\n\nStringUtils.c\n\n\nStringUtils.h\n\n\nUART1.c\n\n\nUART1.h\n\n\nUART2.c\n\n\nUART2.h\n\n\nVN_lib.c\n\n\nVN_lib.h\n\n\nVN_math.c\n\n\nVN_math.h\n\n\nVN_type.h\n\n\nVN_user.c\n\n\nVN_user.h\n\n\nVN100.c\n\n\nVN100.h\n\n\nvoltageSensor.c\n\n\nvoltageSensor.h\n\n\n\n\nCoding Convention\n\n\nThe coding convention form this project follows the standard coding convention for the C language.\n\n\nThe rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:\n\n\n\n\nNaming convention\n -\u0093 Use \ncamelCase\n notation for variables. Use capitals and \nunder_score_case\n for constants.\n\n\nIndentation Style\n -\u0093 Use tabs/indents to show the program structure.\n\n\nCommenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.\n\n\nNever hard-code values\n. Any constants should be defined together so that they can be easily changed through iterations of the code.",
            "title": "Introduction"
        },
        {
            "location": "/picpilot/introduction/#introduction",
            "text": "The PICpilot is a software package meant to control fixed-wing aircraft and numerous \"copters\", among other vehicles. It requires the usage of a specific type of digital signal microcontroller. This microcontroller is produced by  Microchip . The microcontroller that is currently supported is the  dspic33fj256gp710A . However, many other similar models can be easily adapted for support.  This software is designed to be used with two communicating microcontrollers (essential double cores). Due to the atypical nature of the software, it is recommended to view the board schematics  here . The schematics are also included in another section of this document.  The two processors are allocated to two individual tasks. The chip which is responsible for attitude management is often referred to as the \"main\" chip. It is responsible for making corrections to the planes orientation in space, which involves pitch, roll, yaw, heading, throttle, and altitude. It also manages a few additional tasks involving relaying communication with the ground station. The second processor is often referred to as the \"Path Manager\". This chip controls the where the plane should fly (path), and the transitions in altitude and heading between each waypoint (specific GPS coordinates). It also controls the GPS and altitude sensors. These two chips work asynchronously from one another in order to automate the plane.",
            "title": "Introduction"
        },
        {
            "location": "/picpilot/introduction/#setup",
            "text": "To get started, you will need three things:    A Git Client    MPLAB XC16 Compiler (16-bit)    (Optional) MPLAB X IDE",
            "title": "Setup"
        },
        {
            "location": "/picpilot/introduction/#github-setup",
            "text": "A similar powerpoint presentation can be found here: https://docs.google.com/presentation/d/1HkjCdRQyY1LFaUO-24SxHGLx4cgeq_Z5OWQQNKFfidM/edit?usp=sharing  If you are not using the GUI skip this section.   Setup a  Github  Account  Select \"Set up Git\"  Select \"Download GitHub for  \"  Select \"Run\" and continue through the installation process  Once the installation is complete, launch the application.  Log in  Find the Git Bash shell and type in the following commands:  git config global user.name \"YOUR USERNAME HERE\"  git config global user.email \"YOUR EMAIL HERE\" \nThese set the default name and email you use when committing to GitHub.  At this point you will need to let one of the WARG team leads know your username, so that you can be added to the repository member's list.  You should then be able to clone the project using the clone button, or the project URL.     You should now have the code.",
            "title": "Github Setup"
        },
        {
            "location": "/picpilot/introduction/#mplab-setup",
            "text": "You now need the libraries and compilers, as well as the optional MPLAB X IDE, in order to develop code.",
            "title": "MPLAB Setup"
        },
        {
            "location": "/picpilot/introduction/#compiler",
            "text": "Download the  compiler . You want the MPLAB XC16 Compiler V1.21 or newer. Unzip the file once it is completed.  Accept the license agreement.  Select \"Install Compiler\".  Select \"Install MPLAB XC16 C Compiler on this computer.  Leave the activation key blank. Confirm \"Yes\" when the dialog prompts you about using the free version.  Select \"Run the compiler in free mode\".  Select the installation directory.   Run and finish the installation.    Note whenever you make a new project, make sure the right compiler is selected, otherwise there will be a lot of indicated syntax errors (red underlines).",
            "title": "Compiler"
        },
        {
            "location": "/picpilot/introduction/#ide-the-fancy-word-editor-that-lets-you-do-some-code-shenanigans",
            "text": "Download the  IDE Package . You want the MPLAB X IDE V2.10 or newer. Unzip the file once it is completed.  Proceed through the installation process (select installation directory, accept license agreement).",
            "title": "IDE (The fancy word editor that lets you do some code-shenanigans)"
        },
        {
            "location": "/picpilot/introduction/#github-usage",
            "text": "If you don't know how to use Git or you need a reference,  GitImmersion  is a great website.",
            "title": "GitHub Usage"
        },
        {
            "location": "/picpilot/introduction/#gui-usage",
            "text": "Make sure you have correctly set your default storage location in the Options menu.     Saving Files (Committing and Pushing)      Select your Project  Select the files that are supposed to be committed.  Write a commit message, that gives a general overview about each change completed in this update.  Hit \"Commit\".  Once you are ready to sync the changes, hit the sync button (top of the window).   Reading Files from the Server (Pulling) \n* Simply click the sync button at top of the window.",
            "title": "GUI Usage:"
        },
        {
            "location": "/picpilot/introduction/#general-syntax-git-bash",
            "text": "git add <Filename> or git add .  stages the file for commit.  git status  displays all changes being made.  git commit -m \"<Commit message here>\"  makes the change.  git push  sends the change to the server  git pull  retrieves the latest change from the server.  git checkout <HASH>  retrieves a SPECIFIC version from the server.  git checkout -b <Branch Name>  creates a new branch.  git merge master  merges the current branch with the latest code.",
            "title": "General Syntax (Git Bash):"
        },
        {
            "location": "/picpilot/introduction/#general-concepts",
            "text": "When making small changes it is okay to commit to the master branch.  When making large changes (that take multiple days to complete), always make a branch, so that others can work concurrently without compiling broken code.  Always build your code before committing (To make sure it isn't broken).  Try and get rid of warnings if possible.",
            "title": "General Concepts:"
        },
        {
            "location": "/picpilot/introduction/#c-programming-language",
            "text": "The language being used in this project is C. If you are familiar with C++, the concepts are very similar. C is a low level programming language. This means that it does not have a large amount of \"built-in\" functionality, therefore learning C is quite straight forward.  The compiler used for this project is listed above. It is a modified version of the GCC Compiler.  A set of well maintained tutorials can be found here:  http://www.cprogramming.com/tutorial/c/lesson1.html  Topics that one should be familiar with include (in order of importance):   If statements  Looping  Functions  Variable types and how they work  Arrays  Pointers  Structures, Unions   Unrelated topics:   Printf (There is no GUI)  File I/O (All I/O operations are specific to the chip)   Knowledge of common data structures (binary trees, linked lists, etc.) is beneficial, but not mandatory.",
            "title": "C (Programming Language)"
        },
        {
            "location": "/picpilot/introduction/#programming-the-device",
            "text": "In order to program the device, you must have setup your account according to the Setup section. You should also refer to the Schematics and Board Design section for the ports required to complete the programming process. You will require an ICD 3 or a similar programming device.  When using the MPLAB X GUI the process to program the device is as follows:  -\n  1. Ensure the project you wish to program is the main project.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Click the \"Make and Program Device\" button in the top toolbar. Optionally, you can also press the debug button to use the debugging features of MPLAB X.  When using your own editor and compiling from the command line:  -\n  1. Have the binary file ready for programming.\n  2. Connect a cable to the programming port. The pins that should be part of the programming port are MCLR, PGD1, and PGC1.\n  3. Open the MPLAB IPE interface.\n  4. Select your chip model.\n  5. For the source option, browse to your binary file.\n  6. Press program and wait. Then optionally also use the verify option (recommended).  If you are using both chips of the PICpilot, ensure you correctly set the chip identifier pre-compiler in the main.h file, and ensure you program both chips.",
            "title": "Programming the Device"
        },
        {
            "location": "/picpilot/introduction/#autopilot-system-overview",
            "text": "The autopilot system is meant to be adaptable to any aircraft including fixed-wing and multi-rotor aircraft (still WIP). This document mostly covers the software design of the system, although there are a few hardware notes made in this section and the next.  First of all, the flowchart block diagram of the system is presented below:   From this diagram you can see how the software combined with the hardware interacts to provide the final resulting UAV behaviour.  There are three chips. The main one is most commonly referred to as the attitude manager. It is also the communication manager, and the Master chip for all interchip communication. The other chip is referred to as the path manager. The third one has the dedicated task of managing the mechanical \"safety\" relays which ensure that a safety pilot can always regain control of the aircraft.  There are four sensors used in the original design of the aircraft. A GPS (Global Positioning System), IMU (Inertial Measurement Unit), Altimeter, and a camera are all part of the system. Additionally, 2 wireless interfaces are included in the design. A wireless Xbee transmitter/receiver provides telemetry data, whereas an additional (Ultra-high frequency [UHF]) receiver is used to attain control from a standard RC controller.  The outputs from the system include pictures and potentially video, telemetry data, and a functioning aircraft (with moving flaps, elevators, rudder, and ailerons).  This document only covers the PICpilot, however a system overview of a previously fully assembled system will be described in this section. In the past, the PICpilot has been expanded into a larger and more sophisticated system as seen below.",
            "title": "Autopilot System Overview"
        },
        {
            "location": "/picpilot/introduction/#schematics-and-board-design",
            "text": "The following schematic is V2.1 of the PicPilot. You can check out the board schematics  on GrabCAD . You will require  Diptrace  in order to view the files. You can use the free version or use WARG's \"Pro\" license.   This board has 2 dspic33fj256710a chips. This is the PCB for the board. This is the labelled version:     Switching Power Supply 1    Switching Power Supply 2    Battery Port    External Battery Monitor    Analog sensors: airspeed and ultrasonic    UART2 Port -\u0093 Unused    Path Manager Debug    Path Manager Programming Port    I2C- Altimeter    SPI Ports: Top- GPS, Bottom- Unused    Microcontroller 2 -\u0093 Path Manager    SPI -IMU    UART2- Xbee    Attitude Manager Programming Port    Microcontroller 2 - Attitude Manager    Attitude Manager Debug    Relay Controller Programmer Port    Safety Relays (Inputs 1-4)    I2C - PWM Extension    PWM Outputs    PWM Inputs    To get a full list of the different pins, look at the schematic on GrabCad. Highlighted below are the ground connections (and you are politely reminded to NEVER connect these pins to anything but ground, always check before connecting cables).",
            "title": "Schematics and Board Design"
        },
        {
            "location": "/picpilot/introduction/#project-files",
            "text": "All the project files are hosted on Github. However, for convenience they are listed below (accurate at the time of writing of this document):   AttitudeManager.c  AttitudeManager.h  cameraManager.c  cameraManager.h  Clock.c  Clock.h  commands.h  debug.c  debug.h  delay.c  delay.h  fmath.c  fmath.h  FullInitialize.c  FullInitialize.h  I2C.c  I2C.h  InputCapture.c  InputCapture.h  InterchipDMA.c  InterchipDMA.h  lcd.h  main.c  main.h  MPL3115A2.c  MPL3115A2.h  net.h  net_common.c  net_inbound.c  net_outbound.c  OrientationControl.c  OrientationControl.h  OutputCompare.c  OutputCompare.h  PathManager.h  PathManager.c  PWM.c  PWM.h  SPI.c  StartupErrorCodes.c  StartupErrorCodes.h  StringUtils.c  StringUtils.h  UART1.c  UART1.h  UART2.c  UART2.h  VN_lib.c  VN_lib.h  VN_math.c  VN_math.h  VN_type.h  VN_user.c  VN_user.h  VN100.c  VN100.h  voltageSensor.c  voltageSensor.h",
            "title": "Project files"
        },
        {
            "location": "/picpilot/introduction/#coding-convention",
            "text": "The coding convention form this project follows the standard coding convention for the C language.  The rule-set for the coding format is not extremely specific. However, there are a few rules of thumb to be aware of. The rules of thumb are:   Naming convention  -\u0093 Use  camelCase  notation for variables. Use capitals and  under_score_case  for constants.  Indentation Style  -\u0093 Use tabs/indents to show the program structure.  Commenting -\u0093 Be thorough with comments. Include a header at the beginning of every file describing the file, the author, the file name, and the date of creation. For headers, include comments describing any constants, and for each function prototype include the function name, function inputs and outputs, and a description of its functionality.  Never hard-code values . Any constants should be defined together so that they can be easily changed through iterations of the code.",
            "title": "Coding Convention"
        },
        {
            "location": "/picpilot/pid-loops/",
            "text": "PID Loops\n\n\nPID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.\n\n\nThe letters \"PID\" stand for:\n\n\n\n\n\n\nProportional Control \u2013 This stabilizes any instantaneous changes to the system\n\n\n\n\n\n\nIntegral Control \u2013 This stabilizes and reduces long-term error in the system\n\n\n\n\n\n\nDerivative Control \u2013 This stabilizes abrupt changes (large derivative values).\n\n\n\n\n\n\nPI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:\n\n\n\n\nA common PID control loop\n\n\nIn a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.\n\n\nFor the proportional module, the error is simply multiplied by a factor.\n\n\nFor the integral module, the error is integrated over time, before being multiplied by its corresponding factor.\n\n\nFor the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.\n\n\nThese three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:\n\n\nint controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));\n\n\nWhere \nHEADING_ROLL_SCALE _FACTOR\n is a dimensionless scale factor.\n\n\nWhere \ndValue\n is the derivative.\n\n\nWhere \nsum_gain\n is the integral summation over time.\n\n\nWhere \nerror\n is the setpoint minus the output.\n\n\nWhere \nkd_gain\n is the derivative gain.\n\n\nWhere \nkp_gain\n is the proportional gain.\n\n\nWhere \nki_gain\n is the integral gain.\n\n\nNote that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.\n\n\nThe PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.\n\n\nRate Control\n\n\nRate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the \nrate of angular rotation\n, also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:\n\n\n\n\nRate control PID loop\n\n\nThe equation that relates the input with the output is:\n\n\nControl Signal = (dx \u2013 dy) * Kd\n\n\nControl Signal = de * Kd\n\n\nRate Control - In The Code\n\n\nRate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:\n\n\nint controlSignal(float setpoint, float output, unsigned char type)\n\n\nThis function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.\n\n\nAngular Control\n\n\nOnce the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.\n\n\nAn Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.\n\n\nThe resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:\n\n\n\n\nAngular Control PID Loop\n\n\nThe equations that relate r(t) and dx(t) are:\n\n\ndx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)\n\n\ndx(t) = e * Kp + Ki * integral(e,dt)\n\n\nAngular Control \u2013 In The Code\n\n\nAngular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)\n\n\nThis function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.\n\n\nHeading Control\n\n\nOnce rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.\n\n\nThe measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.\n\n\nThis control system uses the commonly recognized PID loop structure:\n\n\n\n\nHeading Control PID Loop\n\n\nThe equations that relate r(t) and h(t) are:\n\n\nr(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)\n\n\nr(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)\n\n\nHeading Control \u2013 In The Code\n\n\nHeading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:\n\n\nint controlSignalHeading(int setpoint, int output)\n\n\nThis function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).\n\n\nThis function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.\n\n\nThe remainder of the PID control is the same. An integrator, derivative, and proportional term is present.\n\n\nAltitude and Throttle Control\n\n\nAltitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.\n\n\nBoth altitude and throttle control is established by the use of PID loops. Currently, altitude uses the \nproportional\n and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).\n\n\nGenerally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 No airspeed sensor\n\n\n\n\nAltitude and Throttle Control PID Loop \u2013 Airspeed sensor\n\n\nAltitude and Throttle Control \u2013 In The Code\n\n\nIn the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:\n\n\nint controlSignalAltitude(int sp_Altitude,int gps_Altitude);\n\n\nThis function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.\n\n\nThe two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.\n\n\nThe function responsible for the PID control of the throttle is:\n\n\nint controlSignalThrottle(int setpoint, int output);\n\n\nThis function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).\n\n\nThe two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.\n\n\nTotal PID Control Overview\n\n\nThe total control diagram can be approximated with the flow chart below:\n\n\n\n\nTuning PID Loops\n\n\nAs explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.\n\n\nThe empirical method which WARG employs in the PID tuning is called the \nZieger-Nichols Method\n. This method involves a tuning procedure with the assistance of the following chart:\n\n\n\n\n\n\n\n\nControl Type\n\n\nKp\n\n\nKi\n\n\nKd\n\n\n\n\n\n\n\n\n\n\nP\n\n\n0.5Ku\n\n\n-\n\n\n-\n\n\n\n\n\n\nPI\n\n\n0.45Ku\n\n\n1.2Kp/Tu\n\n\n-\n\n\n\n\n\n\nPD\n\n\n0.8Ku\n\n\n-\n\n\nKpTu/8\n\n\n\n\n\n\nClassic PID\n\n\n0.6Ku\n\n\n2Kp/Tu\n\n\nKpTu/8\n\n\n\n\n\n\nPessen Integral Rule\n\n\n0.7Ku\n\n\n2.5Kp/Tu\n\n\n3KpTu/20\n\n\n\n\n\n\nSome Overshoot\n\n\n0.33Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\nNo Overshoot\n\n\n0.2Ku\n\n\n2Kp/Tu\n\n\nKpTu/3\n\n\n\n\n\n\n\n\nAs a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.\n\n\nThe tuning procedure is as follows:\n\n\n\n\nBegin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.\n\n\nRetrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.\n\n\nReset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).\n\n\nRepeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.",
            "title": "PID Loops"
        },
        {
            "location": "/picpilot/pid-loops/#pid-loops",
            "text": "PID Loops are vital to the functionality of the PICpilot Autopilot software. UAV systems (especially fixed-wing) are difficult to characterize through a mathematical model. Hence, a control algorithm, such as a PID loop, simplifies the process. It does so by making small changes to the system at regular intervals. The algorithm tracks changes in the past (short term and long term) and the present to be adaptive to future conditions. For instance, if a sudden disturbance is introduced into the system, differential control will compensate and attempt to stabilize the system.  The letters \"PID\" stand for:    Proportional Control \u2013 This stabilizes any instantaneous changes to the system    Integral Control \u2013 This stabilizes and reduces long-term error in the system    Derivative Control \u2013 This stabilizes abrupt changes (large derivative values).    PI systems are usually more common than PID systems. Nonetheless, a common PID system would look like this:   A common PID control loop  In a PID system, the input, r(t), is compared with the output, y(t), in the time domain. The subtraction between these two values yields the error, e(t). The error is then fed into the PID modules. Note each module contains a constant Kd, Kp, Ki. These are scaling factors. They determine the proportions in which each module adds together.  For the proportional module, the error is simply multiplied by a factor.  For the integral module, the error is integrated over time, before being multiplied by its corresponding factor.  For the derivative module, the error is differentiated at each time step, before being multiplied by its corresponding factor.  These three values are added together to determine u(t), which controls the system (plane, quadcopter, etc.). This can be expressed through the following code segment:  int controlSignal = (int)(HEADING_ROLL_SCALE_FACTOR * ((dValue * kd_gain[HEADING]) + (error * kp_gain[HEADING]) + (sum_gain[HEADING] * ki_gain[HEADING])));  Where  HEADING_ROLL_SCALE _FACTOR  is a dimensionless scale factor.  Where  dValue  is the derivative.  Where  sum_gain  is the integral summation over time.  Where  error  is the setpoint minus the output.  Where  kd_gain  is the derivative gain.  Where  kp_gain  is the proportional gain.  Where  ki_gain  is the integral gain.  Note that abrupt changes would affect the derivative term, gradual drift would affect the integral term, and anything in between would affect the proportional term.  The PID model used in the PICpilot is slightly different. Some modules are rearranged, and a hierarchy of PID loops is present.",
            "title": "PID Loops"
        },
        {
            "location": "/picpilot/pid-loops/#rate-control",
            "text": "Rate control is the basis of most aerial aircraft. The flaps on the wings of a plane control the rate at which it turns or rotates, but not the actual angle of the aircraft. For instance, if the flaps on a fixed wing aircraft were fully deflected, the aircraft would continuously spin out of control. It will not stop at a certain angle. In that sense, you control the  rate of angular rotation , also known as the derivative. Likewise, the sensors on the aircraft (gyroscopes), measure the rate of rotation (derivative). This provides an interesting PID system. This PID loop only contains the derivative term. Hence the name \"rate control\".  The rate control diagram looks like this:   Rate control PID loop  The equation that relates the input with the output is:  Control Signal = (dx \u2013 dy) * Kd  Control Signal = de * Kd",
            "title": "Rate Control"
        },
        {
            "location": "/picpilot/pid-loops/#rate-control-in-the-code",
            "text": "Rate Control takes place at the end of the program execution cycle. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function that completes the calculation is called:  int controlSignal(float setpoint, float output, unsigned char type)  This function is responsible for the angular rates of the plane. It contains the differential equations that are part of the PID control system. It calculates the derivative term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg/s or rad/s). The units depend on the value of SERVO_SCALE_FACTOR which can be changed for various units. The original value was degrees per second.",
            "title": "Rate Control - In The Code"
        },
        {
            "location": "/picpilot/pid-loops/#angular-control",
            "text": "Once the roll, pitch, and yaw of the aircraft are empirically controlled (using the rate control code), the roll, pitch, and yaw can then be controlled in terms of angles. In other words, this PI controller allows the aircraft to be commanded to maintain a certain angle in the air, such as a 30 degree bank angle. This allows the aircraft to be controlled by the autopilot to turn, as well as alter its altitude.  An Inertial Measurement Unit (IMU) provides the sensory information required to control the plane in this manner. The IMU usually uses a Kalman filter and state estimation (using integration) to determine the position of the unit.  The resulting angular control PI loop incorporates the rate control loop from the section above. The angular control diagram looks like this:   Angular Control PID Loop  The equations that relate r(t) and dx(t) are:  dx(t) = (r \u2013 y) * Kp + Ki * integral(r-y,dt)  dx(t) = e * Kp + Ki * integral(e,dt)",
            "title": "Angular Control"
        },
        {
            "location": "/picpilot/pid-loops/#angular-control-in-the-code",
            "text": "Angular control code takes place right before the rate control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalAngles(float setpoint, float output, unsigned char type, float SERVO_SCALE_FACTOR_ANGLES)  This function is responsible for the orientation of the plane. It contains the equations that model a PID control system. It calculates the proportional and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (deg or rad), where the units depend on the value of SERVO_SCALE_FACTOR_ANGLES which can be changed for various units.",
            "title": "Angular Control \u2013 In The Code"
        },
        {
            "location": "/picpilot/pid-loops/#heading-control",
            "text": "Once rudimentary control of the aircraft is attained using the angular control loop and the rate control loop, the position of the aircraft can be controlled. As a result, the next control loop controls the heading of the aircraft. For instance, the plane can be directed at a 30 degree magnetic heading, and it will maintain that heading for as long as is required.  The measurements come from an external GPS sensor. The sensor measurements can also come from other sources, but they need to be in units of degrees. Currently, the calculations are done in degrees.  This control system uses the commonly recognized PID loop structure:   Heading Control PID Loop  The equations that relate r(t) and h(t) are:  r(t) = Kd * d(h \u2013 \u03b8)/dt + (h \u2013 \u03b8) * Kp + Ki * integral(h \u2013 \u03b8,dt)  r(t) = Kd * de/dt + e * Kp + Ki * integral(e,dt)",
            "title": "Heading Control"
        },
        {
            "location": "/picpilot/pid-loops/#heading-control-in-the-code",
            "text": "Heading control code takes place right before the angular control portion of the code. The code responsible for this can be found in the _AttitudeManager.c _and _OrientationControl.c _files. The function responsible for these calculations is called:  int controlSignalHeading(int setpoint, int output)  This function is responsible for steering the plane in the correct direction. It contains the equations that model a PID control system. It calculates the derivative, proportional, and integral term of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of angles (currently in degrees).  This function completes a comparison between the setpoint and the output, and then decides if it should turn left or right. When the setpoint and the output are subtracted, the resulting error is set to be between -180 and +180, where -180 degrees indicates the requirement to bank left and +180 degrees indicates the requirement to bank right.  The remainder of the PID control is the same. An integrator, derivative, and proportional term is present.",
            "title": "Heading Control \u2013 In The Code"
        },
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control",
            "text": "Altitude and Throttle control are two separate control loops. However, they are highly dependent on one another. For instance, if the throttle is increased, the plane has a natural tendency to gain altitude. Likewise, if the throttle is decreased, the plane has a natural tendency to lose altitude. Likewise, the opposite is true; if the plane gains or losses altitude, the airspeed of the aircraft changes.  Both altitude and throttle control is established by the use of PID loops. Currently, altitude uses the  proportional  and _derivative _terms, whereas, throttle uses only the _proportional _term. You can determine this by looking at the gain settings for each PID loop (if the gain is zero, the respective PID term is unused).  Generally, the throttle control should be regulated using an airspeed sensor, in order to keep the airspeed constant. However, in cases where there is no airspeed sensor (such as in SPIKE), altitude is used directly to calculate both the throttle and the pitch angle (to change the altitude). This directly affects airspeed and altitude, and if properly tuned is quite effective. This is the appropriate PID diagram for a non-airspeed sensor setup:   Altitude and Throttle Control PID Loop \u2013 No airspeed sensor   Altitude and Throttle Control PID Loop \u2013 Airspeed sensor",
            "title": "Altitude and Throttle Control"
        },
        {
            "location": "/picpilot/pid-loops/#altitude-and-throttle-control-in-the-code",
            "text": "In the PIC pilot software, altitude control is dependent on a PID loop. Currently, the integral term is implemented, but unused. On the other hand, the throttle control only uses the proportional term and the integral term. The derivative term is negligible. Currently, the integral term is unused (for SPIKE) and thus only the proportional term is used. The function responsible for the PID control of the altitude is:  int controlSignalAltitude(int sp_Altitude,int gps_Altitude);  This function is responsible for the altitude control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of meters above the initial starting point.  The two parameters used to call the function are the setpoint (sp_Altitude) and the sensor output (gps_Altitude). These are then used to calculate the corresponding error.  The function responsible for the PID control of the throttle is:  int controlSignalThrottle(int setpoint, int output);  This function is responsible for the throttle control of the plane. It contains the equations that model a PID control system. It calculates the proportional, integral, and derivative terms of the control signal. The setpoint (target value required by the system) and the output (current state of the system) are both inputs to this function in terms of percentage from no throttle (0%) to full throttle (100%).  The two parameters used to call the function are the setpoint and the sensor output. These are then used to calculate the corresponding error.",
            "title": "Altitude and Throttle Control \u2013 In The Code"
        },
        {
            "location": "/picpilot/pid-loops/#total-pid-control-overview",
            "text": "The total control diagram can be approximated with the flow chart below:",
            "title": "Total PID Control Overview"
        },
        {
            "location": "/picpilot/pid-loops/#tuning-pid-loops",
            "text": "As explained above, PID loops keep unstable systems stable via input through (primarily) electronic means. In order to do so, one must analyze the transfer functions of the system and determine PID control gains, or more practically develop these gains from empirically testing the system.  The empirical method which WARG employs in the PID tuning is called the  Zieger-Nichols Method . This method involves a tuning procedure with the assistance of the following chart:     Control Type  Kp  Ki  Kd      P  0.5Ku  -  -    PI  0.45Ku  1.2Kp/Tu  -    PD  0.8Ku  -  KpTu/8    Classic PID  0.6Ku  2Kp/Tu  KpTu/8    Pessen Integral Rule  0.7Ku  2.5Kp/Tu  3KpTu/20    Some Overshoot  0.33Ku  2Kp/Tu  KpTu/3    No Overshoot  0.2Ku  2Kp/Tu  KpTu/3     As a general rule, flying a vehicle requires minimal overshoot and maximum disturbance rejection. The \"Some Overshoot\" control type is unwanted in aerial applications.  The tuning procedure is as follows:   Begin with roll. Increase the proportional gain until the plane oscillates with a constant period and amplitude.  Retrieve the data, plot it in excel and determine the period of oscillation (Tu\u00ad). The proportional gain at which the vehicle began to oscillate is the Ultimate Gain (Ku). Use the above chart to determine the appropriate gain values.  Reset all the gains. Repeat steps 1 and 2 for pitch and yaw (if need be).  Repeat steps 1 and 2, but with all the calculated gains running on the system. This step will fine tune all the values since pitch, roll, and yaw are interdependent. You will only need to repeat this step, whenever making changes to the PID setup or any crucial component on the system itself.",
            "title": "Tuning PID Loops"
        },
        {
            "location": "/picpilot/pwm-io/",
            "text": "PWM and IO\n\n\nPWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:\n\n\n\n\nFor this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:\n\n\n\n\nThe duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.\n\n\nThese PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).\n\n\nHardware\n\n\nThe dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):\n\n\n\n\n\n\n\n\nChannel\n\n\nFunction\n\n\nPin/Port\n\n\nInput/Output\n\n\n\n\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n68/RD8\n\n\nInput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n69/RD9\n\n\nInput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n70/RD10\n\n\nInput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n71/RD11\n\n\nInput\n\n\n\n\n\n\n5\n\n\nUHF Switch\n\n\n79/RD12\n\n\nInput\n\n\n\n\n\n\n6\n\n\nN/A\n\n\n80/RD13\n\n\nInput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n47/RD14\n\n\nInput\n\n\n\n\n\n\n8\n\n\nAutopilot On/Off\n\n\n48/RD15\n\n\nInput\n\n\n\n\n\n\n1\n\n\nRoll\n\n\n72/RD0\n\n\nOutput\n\n\n\n\n\n\n2\n\n\nPitch\n\n\n76/RD1\n\n\nOutput\n\n\n\n\n\n\n3\n\n\nThrottle\n\n\n77/RD2\n\n\nOutput\n\n\n\n\n\n\n4\n\n\nYaw\n\n\n78/RD3\n\n\nOutput\n\n\n\n\n\n\n5\n\n\nCamera Shutter\n\n\n81/RD4\n\n\nOutput\n\n\n\n\n\n\n6\n\n\nCamera Gimbal\n\n\n82/RD5\n\n\nOutput\n\n\n\n\n\n\n7\n\n\nN/A\n\n\n83/RD6\n\n\nOutput\n\n\n\n\n\n\n8\n\n\nN/A\n\n\n84/RD7\n\n\nOutput\n\n\n\n\n\n\n\n\nEach pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).\n\n\nFor detailed hardware specifications see the Microchip website: \ndspic33fj256gp710A\n\n\nIn the Code\n\n\nThree files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.\n\n\nPWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.\n\n\nPWM.c contains 7 functions:\n\n\n\n\n\n\n\n\nFunction Name\n\n\nInput Variables\n\n\nOutput\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\ninitPWM\n\n\ninputChannels, outputChannels\n\n\nNone.\n\n\nThis function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011\n\n\n\n\n\n\nPWMInputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the input from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\nPWMOutputCalibration\n\n\nchannel, signalScaleFactor, signalOffset\n\n\nNone.\n\n\nCalibrates the output from the controller so that the range outputs from -100 to 100.\n\n\n\n\n\n\ngetPWM\n\n\nchannel\n\n\nInteger\n\n\nReturns the value (scaled) from the input of a certain channel.\n\n\n\n\n\n\ngetPWMArray\n\n\nNone.\n\n\nNone.\n\n\nReturns the value (scaled) from the input of all channels.\n\n\n\n\n\n\nsetPWM\n\n\nchannel, pwm\n\n\nNone.\n\n\nSets a certain output compare channel to a certain value according to the pwm range between -100 and 100.\n\n\n\n\n\n\nsetPWMArray\n\n\nocArray\n\n\nNone.\n\n\nSets all output compare channels to values stored in an array. These should be between -100 and 100.\n\n\n\n\n\n\n\n\nFor future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".\n\n\nIt should be noted that the initialization procedure is necessary for the PWM IO functions to work.\n\n\nFor input capture, the settings that are initialized include (for channel 1):\n\n\n   IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt\n\n\n\nThe initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.\n\n\nFor output capture, the settings that are initialized include (for channel 1):\n\n\n// Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)\n\n\n\nThe initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.\n\n\nLikewise, since both IC and OC use \ntimer2\n. An initialization of this component is also required:\n\n\nT2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer\n\n\n\nThe initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).",
            "title": "PWM and IO"
        },
        {
            "location": "/picpilot/pwm-io/#pwm-and-io",
            "text": "PWM stands for Pulse Width Modulation. This means that digital or analog data is encoded through the use of square wave electrical signals, where the width of the square wave determines the value of the data. For instance, in UAVs, a larger square wave will add more throttle, whereas a smaller square wave will add less throttle. The same concepts apply to the ailerons, flaps, rudder, and elevators. A PWM signal can be plotted on a voltage - time plot to attain the following graph:   For this application, the most common pulse width for a square wave is 1.5 milliseconds. This value represents the zero position for all control surfaces. The maximum value for the square wave is 2 milliseconds. The minimum value is 1 millisecond. Likewise, when using throttle, a 1 millisecond square wave is 0% throttle, and a 2 millisecond square wave is 100% throttle. For instance, here is a diagram of 3 consecutive pulses, which command the plane to throttle to 100%, followed by 50%, followed by 0%:   The duty cycle or period specifies the frequency of the pulses. For servo motors, the period is 22.5 milliseconds. This means that one square wave should be detected every 22.5 milliseconds. If the period is unreasonably short, or unreasonably long, the servo motor may seize, until the data is corrected. The allowable error range varies between speed controllers, but it is generally very forgiving (from experience). In general, make sure the period is more than 12 milliseconds and less than 25 milliseconds.  These PWM signals can be used to convey information as input and output to a digital signal controller (DSC). The input is often referred to as \"Input Capture\". The output is often referred to as \"Output Capture\". Each wire connection can handle one channel. The current implementation of the PICpilot supports 8 input channels and 8 output channels. Out of the 8 input channels, 6 are currently used. Out of the 8 output channels, 6 are currently used. The roll, pitch, throttle, yaw and the autopilot on/off channels are the most critical in order for the UAV to work. This encompasses 9 channels in total (5 inputs, 4 outputs).",
            "title": "PWM and IO"
        },
        {
            "location": "/picpilot/pwm-io/#hardware",
            "text": "The dspic33fj256gp710a chip supports 16 channels (8 inputs and 8 outputs):     Channel  Function  Pin/Port  Input/Output      1  Roll  68/RD8  Input    2  Pitch  69/RD9  Input    3  Throttle  70/RD10  Input    4  Yaw  71/RD11  Input    5  UHF Switch  79/RD12  Input    6  N/A  80/RD13  Input    7  N/A  47/RD14  Input    8  Autopilot On/Off  48/RD15  Input    1  Roll  72/RD0  Output    2  Pitch  76/RD1  Output    3  Throttle  77/RD2  Output    4  Yaw  78/RD3  Output    5  Camera Shutter  81/RD4  Output    6  Camera Gimbal  82/RD5  Output    7  N/A  83/RD6  Output    8  N/A  84/RD7  Output     Each pin has corresponding registers to determine the configuration for each pin. The input capture settings that can be configured include the clock source (for timing and comparison), edge detection (trigger on rising, falling or both), and interrupts (every event, or every 2, 3, or 4). For output compare, the settings that can be configured include the clock source, pulse type (single, continuous, high/low initialization).  For detailed hardware specifications see the Microchip website:  dspic33fj256gp710A  In the Code  Three files are in charge of controlling all the PWM signals. InputCapture.c, which contains all the functions used to manage input capture, OutputCompare.C, which contains all the functions used to manage output compare. Finally, PWM.c links these files together.  PWM.c combines both input capture and output compare into a simple interface that is easy to manage and consistent to use. It then applies scaling factors to the arbitrary timer units, which map the Input Capture and Output Capture values to variables that range between -100 and 100.  PWM.c contains 7 functions:     Function Name  Input Variables  Output  Notes      initPWM  inputChannels, outputChannels  None.  This function MUST be called before any other functions used below.The variables must be in binary representation. For example, channel 1, 2, and 5 enabled is: 0b00010011    PWMInputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the input from the controller so that the range outputs from -100 to 100.    PWMOutputCalibration  channel, signalScaleFactor, signalOffset  None.  Calibrates the output from the controller so that the range outputs from -100 to 100.    getPWM  channel  Integer  Returns the value (scaled) from the input of a certain channel.    getPWMArray  None.  None.  Returns the value (scaled) from the input of all channels.    setPWM  channel, pwm  None.  Sets a certain output compare channel to a certain value according to the pwm range between -100 and 100.    setPWMArray  ocArray  None.  Sets all output compare channels to values stored in an array. These should be between -100 and 100.     For future use, the calibration functions should be coordinated with the ground station, in order to be able to calibrate the controller/plane sensitivities and limits \"on the go\".  It should be noted that the initialization procedure is necessary for the PWM IO functions to work.  For input capture, the settings that are initialized include (for channel 1):     IC1CONbits.ICM = 0b00; // Disable Input Capture 1 module\n\n   IC1CONbits.ICTMR = 1; // Select Timer2 as the IC1 Time base\n\n   IC1CONbits.ICI = 0b11; // Interrupt on every capture event\n\n   IC1CONbits.ICM = 0b001; // Generate capture event on every Rising and Falling edge\n\n   // Enable Capture Interrupt And Timer2\n\n   IPC0bits.IC1IP = 7; // Setup IC1 interrupt priority level - Highest\n\n   IFS0bits.IC1IF = 0; // Clear IC1 Interrupt Status Flag\n\n   IEC0bits.IC1IE = 1; // Enable IC1 interrupt  The initialization procedure selects a timer, setting for frequency of capture events, interrupt frequency, as well as other interrupt settings.  For output capture, the settings that are initialized include (for channel 1):  // Initialize Output Compare Module\n\nOC1CONbits.OCM = 0b000; // Disable Output Compare Module\n\nOC1R = MIDDLE\\_PWM; // Write the duty cycle for the first PWM pulse = 1.5ms/4688\n\nOC1RS = MIDDLE\\_PWM; // Write the duty cycle for the second PWM pulse] = 1.5ms/4688\n\nOC1CONbits.OCTSEL = 0; // Select Timer 2 as output compare time base\n\nOC1CONbits.OCM = 0b110; // Select the Output Compare mode (without fault protection)  The initialization procedure selects a timer, initial duty cycle (this changes after the first program cycle), and output compare mode.  Likewise, since both IC and OC use  timer2 . An initialization of this component is also required:  T2CONbits.TON = 0; // Disable Timer\n\nT2CONbits.TCS = 0; // Select internal instruction cycle clock\n\nT2CONbits.TGATE = 0; // Disable Gated Timer mode\n\nT2CONbits.TCKPS = 0b01; // Select 1:8 Prescaler\n\nTMR2 = 0x00; // Clear timer register\n\nsetPeriod(20);\n\nIPC1bits.T2IP = 0x01; // Set Timer 2 Interrupt Priority Level - Lowest\n\nIFS0bits.T2IF = 0; // Clear Timer 2 Interrupt Flag\n\nIEC0bits.T2IE = 1; // Enable Timer 2 interrupt\n\nT2CONbits.TON = 1; // Start Timer  The initialization procedure selects the clock source (internal instruction clock), selects a scaling amount (determined via oscilloscope measurements), sets the period of the pulse cycle (20ms), and enables the Timer2  interrupt (this is not used for PWM signals, it is used to keep track of the runtime of the chip).",
            "title": "Hardware"
        },
        {
            "location": "/picpilot/uart/",
            "text": "UART\n\n\nUART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:\n\n\n\n\nNote that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.\n\n\nUART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the \nbaud rate\n. It is very similar to a bit rate.\n\n\nAs a side note (don't worry if you are confused), Bit rate is the number of \nbits_transferred per second. Baud rate is the number of _symbols\n transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.\n\n\nFor the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.\n\n\nAlthough UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.\n\n\n\n\nFirst a start bit is sent\n\n\nThe message is then relayed in series\n\n\nThe stop bit(s) are then sent. (There can be 1 or 2 stop bits)\n\n\n\n\nThe stop and end bits indicate the beginning and the end of communication.\n\n\n\n\n\n\n\n\nBit number\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n7\n\n\n8\n\n\n9\n\n\n10\n\n\n11\n\n\n\n\n\n\n\n\n\n\n\n\nStart bit\n\n\n5\u20138 data bits\n\n\nStop bit(s)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStart\n\n\nData 0\n\n\nData 1\n\n\nData 2\n\n\nData 3\n\n\nData 4\n\n\nData 5\n\n\nData 6\n\n\nData 7\n\n\nStop\n\n\n\n\n\n\n\n\n\n\n\n\nThe most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.\n\n\nIn case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.\n\n\nSecondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.\n\n\nThirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.\n\n\nThis form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).\n\n\nFor detailed register maps and specifications of the UART interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nUART1\n\n\nU1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n1\n\n\nSets the Baud Rate to 115200 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nUART2\n\n\nU2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nU1MODEbits.UEN\n\n\n0\n\n\nEnables the Rx and Tx pins and disables the CTS and RTS pins.\n\n\n\n\n\n\nU1MODEbits.PDSEL\n\n\n0\n\n\nConfigures 8 bit messages with no parity bits.\n\n\n\n\n\n\nU1MODEbits.STSEL\n\n\n0\n\n\nConfigures 1 stop bit.\n\n\n\n\n\n\nU1BRG\n\n\n5\n\n\nSets the Baud Rate to 38400 Baud.\n\n\n\n\n\n\nIPC7\n\n\n17408\n\n\nSets the priority level for UART interrupts.\n\n\n\n\n\n\nIFS0bits.U1TXIF\n\n\n0\n\n\nClears the transmit interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the transmit interrupt event.\n\n\n\n\n\n\nIFS0bits.U1RXIF\n\n\n0\n\n\nClears the receive interrupt flag.\n\n\n\n\n\n\nIEC0bits.U1TXIE\n\n\n0\n\n\nEnables the receive interrupt event.\n\n\n\n\n\n\nU1MODEbits.UARTEN\n\n\n1\n\n\nTurns UART on.\n\n\n\n\n\n\nU1STAbits.UTXEN\n\n\n1\n\n\nAllows transmission (Tx) to take place.\n\n\n\n\n\n\n\n\nNote that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).",
            "title": "UART"
        },
        {
            "location": "/picpilot/uart/#uart",
            "text": "UART stands for Universal Asynchronous Receive Transmit. It is a protocol for chips to be able to communicate between on another. It is a serial form of communication, where each bit of data is transmitted along the same connection. The minimum hardware requirements look like this:   Note that Tx represents the transmit port, Rx represents the receive port, and the GND represents the required ground connection.  UART is convenient due to its simplicity. Note that the interface does not have a clock line or any special signalling channels. Most other methods of communication require a pulsing clock to determine the rate at which data is transferred from one component to another. UART is \"asynchronous\" and therefore the bits on the transfer line and the receive line do not need to be transmitted at the same instance in time. Instead, both chips have a predefined rate at which they transfer binary information to one another. This predefined rate is often determined by the user, or sometimes (very rarely) restricted by the manufacturer. This rate is referred to as the  baud rate . It is very similar to a bit rate.  As a side note (don't worry if you are confused), Bit rate is the number of  bits_transferred per second. Baud rate is the number of _symbols  transferred per second. A bit can be 0 or 1. A symbol carries different amounts of information in different technologies. For instance, in certain communication protocols, there can be 64 possible values for a single symbol. 64 values required 6 bits to be represented. Therefore, the baud rate is 6 times less than the bit rate.  For the UART communication protocol, the baud rate is equivalent to the bit rate, although \"baud\" is the correct terminology.  Although UART can be used in both 8 bit mode and 16 bit mode, the PICpilot uses the 8 bit mode of communication as displayed below.   First a start bit is sent  The message is then relayed in series  The stop bit(s) are then sent. (There can be 1 or 2 stop bits)   The stop and end bits indicate the beginning and the end of communication.     Bit number  1  2  3  4  5  6  7  8  9  10  11       Start bit  5\u20138 data bits  Stop bit(s)             Start  Data 0  Data 1  Data 2  Data 3  Data 4  Data 5  Data 6  Data 7  Stop       The most common settings for the UART protocol include 8 data bits, no parity, 1 stop bit, and no flow control. Remember to make sure that the baud rate matches up, and NEVER connect Tx to Tx or Rx to Rx.  In case you do not know, parity is a special bit used to check the integrity of the data sent. It indicates whether or not the sum of the 8 bits must be odd or even. If this result does not match the parity bit, the microcontroller would know that the information is garbled.  Secondly, flow control requires additional pins, where each peripheral signals the other one before it transmits and receives. This ensures that both chips are ready to communicate.  Thirdly, the terms full duplex and half duplex refer to a chip being able to multitask. Full duplex indicates that both chips send and receive at the same time. Half duplex indicates that only one chip sends and receives at a time. Usually, some type of flow control is required for half duplex systems.  This form of communication is used for two purposes on the PICpilot. It is used for the data link, as well as the debugging interface. The settings are listed below.",
            "title": "UART"
        },
        {
            "location": "/picpilot/uart/#in-the-code",
            "text": "Each dspic33fj256gp710a has two UART interfaces. They are labeled UART1 and UART2. In the code, two corresponding files are present: UART1.c and UART2.c (as well as their header files). UART1 and UART2 have nearly the same configuration settings, but with slight discrepancies. UART1 is used for debugging purposes. UART2 is used for the wireless transmitter (datalink).  For detailed register maps and specifications of the UART interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.",
            "title": "In the code"
        },
        {
            "location": "/picpilot/uart/#uart1",
            "text": "U1MODEbits.UEN = 0;\n\nU1MODEbits.PDSEL = 0b00;\n\nU1MODEbits.STSEL = 0;\n\nU1BRG = 1;\n\nIPC7 = 0x4400;\n\nIFS0bits.U1TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC0bits.U1TXIE = 0;        // Enable Transmit Interrupts\n\nIFS0bits.U1RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC0bits.U1RXIE = 0;        // Enable Recieve Interrupts\n\nU1MODEbits.UARTEN = 1;        //Enable UART\n\nU1STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  1  Sets the Baud Rate to 115200 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.",
            "title": "UART1"
        },
        {
            "location": "/picpilot/uart/#uart2",
            "text": "U2MODEbits.UEN = 0;\n\nU2MODEbits.PDSEL = 0b00;\n\nU2MODEbits.STSEL = 0;\n\nU2BRG = 5;\n\nIPC7 = 0x4400;\n\nIFS1bits.U2TXIF = 0;                // Clear the Transmit Interrupt Flag\n\nIEC1bits.U2TXIE = 0;        // Enable Transmit Interrupts\n\nIFS1bits.U2RXIF = 0;                // Clear the Recieve Interrupt Flag\n\nIEC1bits.U2RXIE = 0;        // Enable Recieve Interrupts\n\nU2MODEbits.UARTEN = 1;        //Enable UART\n\nU2STAbits.UTXEN = 1;        //This must be set after UARTEN - This allows UART to control the Tx pin.     Register  Value  Function      U1MODEbits.UEN  0  Enables the Rx and Tx pins and disables the CTS and RTS pins.    U1MODEbits.PDSEL  0  Configures 8 bit messages with no parity bits.    U1MODEbits.STSEL  0  Configures 1 stop bit.    U1BRG  5  Sets the Baud Rate to 38400 Baud.    IPC7  17408  Sets the priority level for UART interrupts.    IFS0bits.U1TXIF  0  Clears the transmit interrupt flag.    IEC0bits.U1TXIE  0  Enables the transmit interrupt event.    IFS0bits.U1RXIF  0  Clears the receive interrupt flag.    IEC0bits.U1TXIE  0  Enables the receive interrupt event.    U1MODEbits.UARTEN  1  Turns UART on.    U1STAbits.UTXEN  1  Allows transmission (Tx) to take place.     Note that the only difference between the data link (UART2) and the debugging interface (UART1), is the rate at which information is sent (baud rate).",
            "title": "UART2"
        },
        {
            "location": "/picpilot/spi/",
            "text": "SPI\n\n\nSPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a \nsynchronous\n method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips \nalways\n transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:\n\n\n\n\nNote that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:\n\n\n\n\nIn the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.\n\n\nThe SPI interface transfers 8 bits per packet. The protocol is straight forward:\n\n\n\n\nThe start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.\n\n\nOn the next 8 clock pulses, the slave and master both exchange data (read and write)\n\n\nAfter transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).\n\n\n\n\nThe PIC microcontroller specifications depict the SPI interface as follows:\n\n\n\n\nUnlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the \nStart Condition\n and the \nStop Condition\n, because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).\n\n\nIn the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.\n\n\nIn the code\n\n\nEach dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.\n\n\nThe SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.\n\n\nThis table summarizes the configuration:\n\n\n\n\n\n\n\n\n\n\nSPI1\n\n\nSPI2\n\n\nSPI2\n\n\n\n\n\n\n\n\n\n\nUse\n\n\nInterchip Communication\n\n\nGPS Communication\n\n\nVectorNav Communication\n\n\n\n\n\n\nChip\n\n\nBoth chips\n\n\nSecondary (Path Managing) Chip\n\n\nPrimary (Attitude Managing) Chip\n\n\n\n\n\n\nFunction\n\n\nIn InterchipDMA.c,Init_SPI1()\n\n\nIn InterchipDMA.c,Init_SPI2()\n\n\nIn VN100.c,VN100_initSPI()\n\n\n\n\n\n\n\n\nFor detailed register maps and specifications of the SPI interface, see the \ndspic33fj256gp710A\n datasheet.\n\n\nThe most important settings are listed below.\n\n\nSPI1 \u2013 DMA and SPI2 - GPS\n\n\n//Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;\n\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIFS0bits.SPI1IF\n\n\n0\n\n\nThis is the interrupt flag for the SPI1 interface.\n\n\n\n\n\n\nIEC0bits.SPI1IE\n\n\n1 (0 for GPS)\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.\n\n\n\n\n\n\nIPC2bits.SPI1IP\n\n\n4 (0 for GPS)\n\n\nThis determines the priority of every interrupt that occurs from the SPI1 interface.\n\n\n\n\n\n\nSPI1BUF\n\n\n0\n\n\nThis is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.\n\n\n\n\n\n\nSPI1CON1bits.DISSCK\n\n\n0\n\n\nThis bit allows the SPI1 module to control the clock.\n\n\n\n\n\n\nSPI1CON1bits.DISSDO\n\n\n0\n\n\nThis bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.\n\n\n\n\n\n\nSPI1CON1bits.MODE16\n\n\n1\n\n\nThis allows 16 bits to be transmitted per message.\n\n\n\n\n\n\nSPI1CON1bits.MSTEN\n\n\n0 or 1\n\n\nThis determines if the chip is the master (attitude manager) or the slave (path manager).\n\n\n\n\n\n\nSPI1CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI1CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI1CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI1CON1bits.CKP\n\n\n0\n\n\nDetermines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.\n\n\n\n\n\n\nSPI1STATbits.SPIEN\n\n\n1\n\n\nEnables the entire SPI module.\n\n\n\n\n\n\n\n\nSPI2 - VectorNav\n\n\nThe VectorNav SPI configuration is very similar. The differences are listed below:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nIEC0bits.SPI2IE\n\n\n0\n\n\nThis is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.\n\n\n\n\n\n\nSPI2CON1bits.MODE16\n\n\n0\n\n\nThis allows 8 bits to be transmitted per message.\n\n\n\n\n\n\nSPI2CON1bits.MSTEN\n\n\n1\n\n\nThis determines that the chip is the master and the VectorNav is the slave.\n\n\n\n\n\n\nSPI2CON1bits.SSEN\n\n\n0\n\n\nThis value enables the slave select pin.\n\n\n\n\n\n\nSPI2CON1bits.SMP\n\n\n0\n\n\nThis determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.\n\n\n\n\n\n\nSPI2CON1bits.CKE\n\n\n0\n\n\nThis bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.CKP\n\n\n1\n\n\nDetermines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.\n\n\n\n\n\n\nSPI2CON1bits.PPRE\n\n\n2\n\n\nPrescales the clock. It reduces the clock frequency at a 4:1 ratio.\n\n\n\n\n\n\nSPI2CON1bits.SPRE\n\n\n6\n\n\nThe secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.",
            "title": "SPI"
        },
        {
            "location": "/picpilot/spi/#spi",
            "text": "SPI stands for Serial Peripheral Interface. It is similar to UART, with the exception that it is a  synchronous  method of communication. Once again, SPI is a protocol for chips to be able to communicate between on another through serial connections (data on a single wire). It always operates in full duplex mode. This means that both chips  always  transmit and receive at the same time. The minimum hardware requirements include a clock line (SCLK), a Master Out/Slave In (MOSI), a Master In/Slave Out (MISO), and a Slave Select (SS). The Master Out/In and Slave In/Out refer to the transmit and receive pins on both chips. The connections should looks like this:   Note that there is a \"Master\" and a \"Slave\". The master always initiates communication. The slave always responds first. The SCLK (clock) line counts pulses, which are synchronized to the data bits on the MOSI and MISO lines. The SS (Slave Select) line is used to notify an external chip that communication is taking place. This enables multiple chips to be connected on the same data and clock lines. This is depicted here:   In the PICpilot, there is never more than one slave per data port. In other words, one does not have to worry about scenarios (multiple slaves) such as the one depicted above.  The SPI interface transfers 8 bits per packet. The protocol is straight forward:   The start condition is initiated. The clock starts and the (selected) slave prepares to read and the master prepares to write.  On the next 8 clock pulses, the slave and master both exchange data (read and write)  After transmission, the stop condition is set. This occurs when the clock stops (high or low depending on the settings).   The PIC microcontroller specifications depict the SPI interface as follows:   Unlike UART, there is no parity bits, start bits, or stop bits. The beginning and the end of the message are commonly referred to as the  Start Condition  and the  Stop Condition , because they don't actually refer to any bits, but instead they refer to the signal of multiple lines (CLK, SS).  In the PICpilot, SPI is used for communication with the GPS, VectorNav (IMU), and the two individual cores (CPU/Microcontrollers). The GPS uses SPI2, the VectorNav uses SPI2, and the crosstalk between chips uses SPI1.",
            "title": "SPI"
        },
        {
            "location": "/picpilot/spi/#in-the-code",
            "text": "Each dspic33fj256gp710a has two SPI interfaces. They are labeled SPI1 and SPI2. In the code, you won't find any SPI files present. The initialization functions are embedded in the corresponding peripheral files. The SPI1 configuration can be found on both chips, in the file, InterchipDMA.c, as well as the corresponding .h file. The function in those files is init_SPI1. In addition, on the secondary chip (in other words, the path management chip), the SPI2 (GPS) interface is also enabled in the InterchipDMA.c file, as well as the header file. The function is called init_SPI2.  The SPI2 configuration on the main chip (or more precisely, the attitude management chip) can be found in the VN100.c file, as well as the corresponding header file. The function name is VN100_initSPI. It initializes SPI2.  This table summarizes the configuration:      SPI1  SPI2  SPI2      Use  Interchip Communication  GPS Communication  VectorNav Communication    Chip  Both chips  Secondary (Path Managing) Chip  Primary (Attitude Managing) Chip    Function  In InterchipDMA.c,Init_SPI1()  In InterchipDMA.c,Init_SPI2()  In VN100.c,VN100_initSPI()     For detailed register maps and specifications of the SPI interface, see the  dspic33fj256gp710A  datasheet.  The most important settings are listed below.",
            "title": "In the code"
        },
        {
            "location": "/picpilot/spi/#spi1-dma-and-spi2-gps",
            "text": "//Set interrupts\n\nIFS0bits.SPI1IF = 0;\n\nIEC0bits.SPI1IE = 1;\n\nIPC2bits.SPI1IP = 4;\n\nSPI1BUF = 0;\n\n//SPI clock controlled by this module\n\nSPI1CON1bits.DISSCK = 0;\n\n//Output pins are controlled by this module\n\nSPI1CON1bits.DISSDO = 0;\n\n//16/8 bit communication mode (1/0)\n\nSPI1CON1bits.MODE16 = 1; //16\n\n//Master mode(1)/Slave mode(0)\n\nSPI1CON1bits.MSTEN = 0; //Slave\n\n//Enable Slave Select\n\nSPI1CON1bits.SSEN = 0;\n\n//Sample Phase (end/middle)\n\nSPI1CON1bits.SMP = 0; //Sample the input at the middle of the square wave\n\n//Clock Edge Select\n\nSPI1CON1bits.CKE = 0; //Output data changes from idle state to active clock state (1 is the opposite)\n\n//Clock Polarity\n\nSPI1CON1bits.CKP = 0; //Idle clock state is low, active clock state is high\n\n//Enable SPI\n\nSPI1STATbits.SPIEN = 1;     Register  Value  Function      IFS0bits.SPI1IF  0  This is the interrupt flag for the SPI1 interface.    IEC0bits.SPI1IE  1 (0 for GPS)  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur.    IPC2bits.SPI1IP  4 (0 for GPS)  This determines the priority of every interrupt that occurs from the SPI1 interface.    SPI1BUF  0  This is the buffer that is used for sending and receiving data. This is buffer is for both reading and writing.    SPI1CON1bits.DISSCK  0  This bit allows the SPI1 module to control the clock.    SPI1CON1bits.DISSDO  0  This bit allows the SPI1 module to convert the usual GPIO pins into SPI1 pins.    SPI1CON1bits.MODE16  1  This allows 16 bits to be transmitted per message.    SPI1CON1bits.MSTEN  0 or 1  This determines if the chip is the master (attitude manager) or the slave (path manager).    SPI1CON1bits.SSEN  0  This value enables the slave select pin.    SPI1CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI1CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI1CON1bits.CKP  0  Determines the clock polarity. 0 means that active clock state is high, idle state is low. 1 is the opposite.    SPI1STATbits.SPIEN  1  Enables the entire SPI module.",
            "title": "SPI1 \u2013 DMA and SPI2 - GPS"
        },
        {
            "location": "/picpilot/spi/#spi2-vectornav",
            "text": "The VectorNav SPI configuration is very similar. The differences are listed below:     Register  Value  Function      IEC0bits.SPI2IE  0  This is the interrupt enable bit for the SPI1 interface. This allows interrupts to occur. The interrupt is disabled here.    SPI2CON1bits.MODE16  0  This allows 8 bits to be transmitted per message.    SPI2CON1bits.MSTEN  1  This determines that the chip is the master and the VectorNav is the slave.    SPI2CON1bits.SSEN  0  This value enables the slave select pin.    SPI2CON1bits.SMP  0  This determines the sampling time of the SPI interface. 0 forces sampling in the middle of the square wave, 1 forces sampling at the end of the square wave.    SPI2CON1bits.CKE  0  This bit determines when the transmitted square wave changes states. 0 means it changes from clock low to high. 1 is the opposite.    SPI2CON1bits.CKP  1  Determines the clock polarity. 1 means that active clock state is low, idle state is high. 0 is the opposite.    SPI2CON1bits.PPRE  2  Prescales the clock. It reduces the clock frequency at a 4:1 ratio.    SPI2CON1bits.SPRE  6  The secondary prescaler, prescales the output frequency from the primary prescaler. This one is set to reduce the frequency at a ratio of 2:1.",
            "title": "SPI2 - VectorNav"
        },
        {
            "location": "/picpilot/direct-memory-access/",
            "text": "Direct Memory Access\n\n\nDirect Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.\n\n\nDMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.\n\n\nOne DMA cycle follows this procedure:\n\n\n\n\nIn the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.\n\n\nWhen a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.\n\n\nIn the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.\n\n\nIt should be noted that DMA is also used between the path manager chip and the GPS.\n\n\nOn the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.\n\n\nIn the code\n\n\nIn order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).\n\n\nThe GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nIn order to properly configure this connection the following code is used:\n\n\nGPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset(&gpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int) &SPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nNote how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:\n\n\n\n\n\n\n\n\nRegister\n\n\nValue\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nDMA2CONbits.AMODE\n\n\n0\n\n\nThis enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).\n\n\n\n\n\n\nDMA2CONbits.DIR\n\n\n0\n\n\nThis indicates the direction that data travels on the bus. In this case, the data is always \nincoming\n. Therefore, it is copied from the SPI interface to the DSPRAM.\n\n\n\n\n\n\nDMA2CONbits.MODE\n\n\n0\n\n\nThis indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.\n\n\n\n\n\n\nDMA2CONbits.SIZE\n\n\n1\n\n\nIndicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.\n\n\n\n\n\n\nDMA2STA\n\n\n&gpsData with an added DMA offset\n\n\nThis indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.\n\n\n\n\n\n\nDMA2PAD\n\n\n&SPI2BUF\n\n\nThis stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).\n\n\n\n\n\n\nDMA2CNT\n\n\nNumber of bytes in GPSData - 1\n\n\nThis is a counter variable, which indicates the number of transfers that need to be completed per DMA request.\n\n\n\n\n\n\nDMA2REQ\n\n\n0b0100001\n\n\nThis is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.\n\n\n\n\n\n\nDMA2CONbits.CHEN\n\n\n1\n\n\nEnables the DMA channel.\n\n\n\n\n\n\n\n\nOn the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.\n\n\nThe data being sent to the PM chip from the AM chip is in the form of:\n\n\ntypedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;\n\n\n\nVice-versa, the data being sent to the AM chip from the PM chip is in the form of:\n\n\ntypedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;\n\n\n\nThe initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset(&amData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset(&pmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int) &SPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset(&pmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset(&amData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int) &SPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}\n\n\n\nThe above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.\n\n\nAlso, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:\n\n\n#if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif\n\n\n\nA DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).",
            "title": "Direct Memory Access"
        },
        {
            "location": "/picpilot/direct-memory-access/#direct-memory-access",
            "text": "Direct Memory Access (or DMA), is a microcontroller feature, which allows peripheral interfaces to directly access memory, completely bypassing the CPU. The CPU only needs to setup the transfer of data. The rest of the process is done without it.  DMA is a commonly used in graphic, network, and sound cards. More importantly, it is used in multi-core processors, which is essentially the usage of DMA in the PICpilot.  One DMA cycle follows this procedure:   In the PICpilot, the only peripheral that uses DMA is the SPI interface, although many other ones are supported.  When a DMA transfer occurs, first a peripheral makes a request to the DMA controller (based on a predefined channel number). The request causes the DMA controller to read or write to a preconfigured peripheral address. Once this is completed, the DMA controller writes the data to the DPSRAM location (this is RAM dedicated to the DMA controller) or reads from it. The direction in which this transfer occurs depends on the register value corresponding to the predefined settings of the DMA controller.  In the PICpilot, the Direct Memory Access module is constantly active through the SPI1 module. This means that the data transmission is continuous between both chips. Essentially, when this process is continuous it provides a way to share global variables between two physical microcontrollers simultaneously. This is how path data gets transmitted to the attitude manager. The path data is made global between the two chips.  It should be noted that DMA is also used between the path manager chip and the GPS.  On the PIC microcontroller, the DMA must only be initialized. The DMA controller continues operation automatically without direct processor input. The code to initialize the interface is below.",
            "title": "Direct Memory Access"
        },
        {
            "location": "/picpilot/direct-memory-access/#in-the-code",
            "text": "In order to transfer data using DMA, both chips must have been initialized. In the PICpilot, only the DMA interface is initialized for data transfer between the GPS and the Path Management Chip (PM Chip), as well as the PM Chip and the Attitude Management Chip (AM Chip). Both of these connections are enabled using SPI (see previous section).  The GPS continuously sends data as soon as it is plugged in. It sends data in the following data format:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  In order to properly configure this connection the following code is used:  GPSData gpsData __attribute__((space(dma)));\n\n/*\n\n *\n\n */\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA2Interrupt(void){\n\n    newGPSDataAvailable = 1;\n\n    IFS1bits.DMA2IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA2(){\n\n    IFS1bits.DMA2IF = 0;\n\n    IEC1bits.DMA2IE = 1;\n\n    DMA2CONbits.AMODE = 0b00; //Register Indirect Mode\n\n    DMA2CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA2CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA2CONbits.SIZE = 1; //Transfer bytes (8 bits)\n\n    DMA2STA = __builtin_dmaoffset(&gpsData); //Primary Transfer Buffer\n\n    DMA2PAD = (volatile unsigned int) &SPI2BUF; //Peripheral Address\n\n    DMA2CNT = sizeof(GPSData) - 1; //+1 for checksum //DMA Transfer Count Length\n\n    DMA2REQ = 0b0100001; //IRQ code for SPI2\n\n    DMA2CONbits.CHEN = 1; //Enable the channel\n\n}  Note how a block of memory (\"GPSData\") is reserved for the incoming data from the GPS unit.  The register values are configured as follows:     Register  Value  Function      DMA2CONbits.AMODE  0  This enables Register Indirect with Post Increment Mode. This enables data to be stored in chunks one after another (incremented locations).    DMA2CONbits.DIR  0  This indicates the direction that data travels on the bus. In this case, the data is always  incoming . Therefore, it is copied from the SPI interface to the DSPRAM.    DMA2CONbits.MODE  0  This indicates if the transfer occurs a single time, or continuously, and whether a ping pong buffer should be used. It is currently enabled for continuous usage without a ping pong buffer.    DMA2CONbits.SIZE  1  Indicates if each DMA transfer is 8 bits or 16 bits. In this case, it is 8 bits.    DMA2STA  &gpsData with an added DMA offset  This indicates where the primary buffer is located. This memory block was initialized at the beginning of the above code snippet, where \"space(dma)\" is called.    DMA2PAD  &SPI2BUF  This stores the referenced location from where the data is obtained. (This DMA channel will use the SPI2 buffer to get the data).    DMA2CNT  Number of bytes in GPSData - 1  This is a counter variable, which indicates the number of transfers that need to be completed per DMA request.    DMA2REQ  0b0100001  This is the IRQ (Interrupt Request) code for the SPI2 interface. This allows the peripheral to send an interrupt request to the DMA controller instead of the CPU.    DMA2CONbits.CHEN  1  Enables the DMA channel.     On the other hand, the setup between the PM chip and the AM chip is slightly different. These two chips communicate with each other simultaneously through the SPI1 interface. The code controlling the initialization found in InterchipDMA.c/.h.  The data being sent to the PM chip from the AM chip is in the form of:  typedef struct _AMData {\n\n    WaypointWrapper waypoint;\n\n    float pathGain;\n\n    float orbitGain;\n\n    float calibrationHeight;\n\n    char command;\n\n    char checksum;\n\n} AMData;  Vice-versa, the data being sent to the AM chip from the PM chip is in the form of:  typedef struct _PMData {\n\n    float time;     //4 Bytes   -  hhmmss.ssss\n\n    long double latitude;  //8 Bytes - ddd.mmmmmm\n\n    long double longitude; //8 Bytes - ddd.mmmmmm\n\n    float speed;    //KM/H\n\n    float altitude;\n\n    int sp_Altitude; // Meters\n\n    int heading;  //Degrees\n\n    int sp_Heading; //Degrees\n\n    char satellites;    //1 Byte\n\n    char positionFix;   //0 = No GPS, 1 = GPS fix, 2 = DGSP Fix\n\n    char targetWaypoint;\n\n    char batteryLevel;\n\n } PMData;  The initialization process is extremely similar for both chips (PM and AM). Each chip requires a DMA channel to read the incoming data, as well as to write the outgoing data. As a result, both the AM chip and the PM chip have the same setup with a few different variables names:  void __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){\n\n#if !PATH_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n#endif\n\n    newDataAvailable = 1;\n\n    IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _DMA1Interrupt(void){\n\n    IFS0bits.DMA1IF = 0;// Clear the DMA0 Interrupt Flag\n\n}\n\nvoid init_DMA0(){\n\n    IFS0bits.DMA0IF = 0;\n\n    IEC0bits.DMA0IE = 1;\n\n    IPC1bits.DMA0IP = 7; //Highest Priority\n\n    DMACS0 = 0; //Clear any IO error flags\n\n    DMA0CONbits.DIR = 0; //Transfer from SPI to DSPRAM\n\n    DMA0CONbits.AMODE = 0b00; //With post increment mode\n\n    DMA0CONbits.MODE = 0b00; //Transfer continuously\n\n    DMA0CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA0STA = __builtin_dmaoffset(&amData); //Primary Transfer Buffer\n\n#else\n\n    DMA0STA = __builtin_dmaoffset(&pmData); //Primary Transfer Buffer\n\n#endif\n\n    DMA0PAD = (volatile unsigned int) &SPI1BUF; //Peripheral Address\n\n    DMA0CNT = PATH_MANAGER?(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1):(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA0REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA0CONbits.CHEN = 1; //Enable the channel\n\n}\n\nvoid init_DMA1(){\n\n    IFS0bits.DMA1IF = 0;\n\n    IEC0bits.DMA1IE = 1;\n\n    IPC3bits.DMA1IP = 7;\n\n    DMACS1 = 0; //Clear any IO error flags\n\n    DMA1CONbits.DIR = 1; //Transfer from DSPRAM to SPI\n\n    DMA1CONbits.AMODE = 0b00; //Without post increment mode\n\n    DMA1CONbits.MODE = 0b00; //Transfer continuously, ping ponging between buffers\n\n    DMA1CONbits.SIZE = 0; //Transfer words (16 bits)\n\n#if PATH_MANAGER\n\n    DMA1STA = __builtin_dmaoffset(&pmData); //Primary Transfer Buffer\n\n#else\n\n    DMA1STA = __builtin_dmaoffset(&amData); //Primary Transfer Buffer\n\n#endif\n\n    DMA1PAD = (volatile unsigned int) &SPI1BUF; //Peripheral Address\n\n    DMA1CNT = PATH_MANAGER?(sizeof(PMData)/2 + sizeof(PMData) % 2 - 1):(sizeof(AMData)/2 + sizeof(AMData) % 2 - 1); //+1 for checksum //DMA Transfer Count Length\n\n    DMA1REQ = 0x000A;//0b0100001; //IRQ code for SPI1\n\n    DMA1CONbits.CHEN = 1; //Enable the channel\n\n}  The above code is very similar to the first example with the GPS. The differences include the direction of data transfer, the buffer variables, the IRQ codes, as well as the 16 bit mode interfacing.  Also, in order to initialize transfer, the SPI master must send the first packet. This is evident in the DMA0 interrupt routine:  #if !PATH\\_MANAGER\n\n    if (!transmitInitialized){\n\n        transmitInitialized = 1;\n\n        DMA1REQbits.FORCE = 1;\n\n    while (DMA1REQbits.FORCE == 1);\n\n    }\n\n #endif  A DMA request is forced by setting the DMA1REQbits.FORCE bit to 1. The following sets of data do not need to be forced, they happen automatically (since continuous mode was enabled).",
            "title": "In the code"
        },
        {
            "location": "/picpilot/i2c/",
            "text": "I2C\n\n\nI2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a \nsynchronous\n method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:\n\n\n\n\nThis protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.\n\n\nIn a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.\n\n\nThere are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.\n\n\nThe write message is structured in the following order:\n\n\n\n\nStart condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)\n\n\nAn 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).\n\n\nThe master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.\n\n\nAt this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).\n\n\nThe stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)\n\n\n\n\nThe read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.\n\n\nAssuming that the write message from above was never stopped, the read message would be as follows:\n\n\n\n\nExecute a repeated restart.\n\n\nSend the slave address with a read bit (1).\n\n\nThe slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.\n\n\nThe master will not acknowledge (Yes I know, laugh all you want)\n\n\nThe stop condition or a repeated restart is executed.\n\n\n\n\nA visual depiction of a common I2C message is below:\n\n\n\n\nOn the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.\n\n\nIn the code\n\n\nThe initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:\n\n\nI2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;\n\n\n\nAs you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.\n\n\nSecondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.\n\n\nAt this point reading and writing can take place. The function to do so is called \nsendMessage()\n:\n\n\nchar sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address & write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress << 1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}\n\n\n\nIn the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:\n\n\nwhile((I2C2CON & 0x1F ) || I2C2STATbits.TRSTAT == 1);\n\n\n\nIn the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the \nI2C2TRN\n transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.\n\n\nThe write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.\n\n\nvoid writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i < length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}\n\n\n\nNote, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.\n\n\nOn the contrary the read message is a bit more complicated:\n\n\nchar readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress << 1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}\n\n\n\nThe register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.\n\n\nThe device and register addresses depend on the device and its functionality.",
            "title": "I2C"
        },
        {
            "location": "/picpilot/i2c/#i2c",
            "text": "I2C stands for Inter-Integrated Circuit. It is pronounced \"I-two-C\" or \"I-squared-C\". It is similar to SPI, with the exception that it does not require a slave select line. All communication takes place on one data line, and one clock line. I2C is a  synchronous  method of communication, indicating that a clock line is present. Once again, I2C is a protocol for chips to be able to communicate between one another through serial connections (data on a single wire). It cannot operate in full duplex mode, unlike SPI. This means that both chips take turns transmitting and receiving and cannot do so at the same time. The minimum hardware requirements include a clock line (SCL), a data line (SDA), and both lines connected to Vdd via a pull-up resistor. The connections should looks like this:   This protocol is extremely simple from a hardware point of view. However, it is significantly slower than SPI, which is the main disadvantage. If you require high speed communication, I2C is not the best choice.  In a similar fashion to SPI, I2C also has Master and Slave devices. I2C protocol dictates that the master must always initialize communication.  There are two types of messages that a master device can send. It can be a read or a write message. Both messages are similar in structure; however, the read message requires the slave to respond, whereas the write message does not.  The write message is structured in the following order:   Start condition is specified on SDA and SCL (depends on the settings but typically involves the master pulling the data line low, shortly followed by the clock line being pulled low)  An 8-bit message is then sent, which contains a 7-bit (unique) identifying address, which determines what slave will engage in the data transfer. The 8th bit of the message is a read or write bit. When the bit is low (0), this indicates a write. When the bit is high (1), this indicates a read. In this scenario, we express the write bit (0).  The master waits for an acknowledgment from the slave. The acknowledgment is the slave pulling the data line low (0), while the master listens. If the acknowledgment is not received, there is likely a problem with the device or the connection.  At this point data is written 8 bits at a time, until the stop condition is expressed by the master. After each bit, the slave must acknowledge (ACK).  The stop condition is expressed. (SDA is pulled low, then the SCL is pulled high and it stops pulsing. The SDA is then also pulled high.)   The read message is very similar to the write message. The start condition and the first byte (address and write bit) must always be present. If a read condition is to exist, a repeated restart must be executed followed by the address of the slave with the read bit (1). The second byte/message may be a command message. Following the message, for the next 8 bytes, the master will expect a response to the command.  Assuming that the write message from above was never stopped, the read message would be as follows:   Execute a repeated restart.  Send the slave address with a read bit (1).  The slave will respond with 8 bits of data. These 8 bits of data depend on the message sent prior to the repeated restart.  The master will not acknowledge (Yes I know, laugh all you want)  The stop condition or a repeated restart is executed.   A visual depiction of a common I2C message is below:   On the PICpilot, the only I2C peripheral currently in use is the altimeter. The altimeter is connected to the path managing chip.",
            "title": "I2C"
        },
        {
            "location": "/picpilot/i2c/#in-the-code",
            "text": "The initialization of I2C on the dspic33fj256710a is very simple. There are only a few necessary choices to make:  I2C2CONbits.A10M = 0;   //7 bit address mode\n\nI2C2CONbits.DISSLW = 1; //Slew Rate control disabled for 100KHz\n\nI2C2CONbits.SMEN = 0;   //Do NOT use SMBus voltage configuration\n\n///I2C1BRG  - BAUD RATE GENERATOR\n\n///MPL3115A2 requires Max 4MHz\n\nI2C2BRG = 19;           //~118KHz clock rate; FCY = 4MHz\n\n//Enable the I2C module\n\nI2C2CONbits.I2CEN = 1;  As you can see, there are only a few important distinctions to make. Firstly, you can have a 10 bit addressing mode or a 7 bit addressing mode. On the PICpilot we use the 7 bit mode.  Secondly, the clock rate is set via the I2C2BRG register. This could be upgraded to a faster communication speed in the future. The I2C module is then enabled.  At this point reading and writing can take place. The function to do so is called  sendMessage() :  char sendMessage(char devAddress, char address, char\\* data, char length, char rw)\n\n{\n\n    char rData = 0;\n\n    I2CIdle();\n\n    I2C2CONbits.SEN = 1;  //Send Start condition\n\n    I2CIdle();\n\n    //SET Slave Address & write (Address shifted one bit left and then the write(0) bit is added)\n\n    I2C2TRN = devAddress << 1; //If reading, the read process is specified after the dummy bytes.\n\n    if (rw == READ) //If in reading mode\n\n    {\n\n        rData = readMessage(devAddress, address);\n\n    }\n\n    else //Otherwise go into writing mode\n\n    {\n\n       writeMessage(address,data, length);\n\n    }\n\n    I2CIdle();\n\n    I2C2CONbits.PEN = 1; //Send Stop condition\n\n    I2CIdle();\n\n    return rData;\n\n}  In the above code, the I2CIdle(); command is a while loop, which waits until the module is ready to transmit:  while((I2C2CON & 0x1F ) || I2C2STATbits.TRSTAT == 1);  In the code, it is evident that the start condition is asserted (using control register 2), followed by loading the device address and the write bit into the  I2C2TRN  transmit buffer. At this point the read or write functions are executed, depending on the request, before finally sending the stop condition.  The write command is extremely simple. It simply loops through the data, waiting for an acknowledgment after each one.  void writeMessage(char address, char\\* data, char length)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the address.\n\n    //Write each byte of data\n\n    int i = 0;\n\n    for(i = 0; i < length; i++)\n\n    {\n\n        I2CIdle();//Check until transmition was completed\n\n        I2C2TRN = (char)data[i];\n\n    }\n\n}  Note, that the register address is first specified, followed by the iteration of bits that is sent to the buffer.  On the contrary the read message is a bit more complicated:  char readMessage(char devAddress, char address)\n\n{\n\n    I2CIdle();\n\n    I2C2TRN = address;  //Then after it is free, write the local address.\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2CONbits.RSEN = 1; //Resend the start condition\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    I2C2TRN = (devAddress << 1) + 1; //Shift and add the read bit(1) - Prep for restart\n\n    I2CIdle(); //Wait until acknowledge is sent from the slave\n\n    ///THE MESSAGE FROM THE SLAVE IS SENT HERE\n\n    I2C2CONbits.RCEN = 1; //Enable receive mode\n\n    I2CIdle(); //Wait until all 8 bits have been acquired\n\n    while (I2C2STATbits.RBF != 1);\n\n    char data = I2C2RCV;\n\n    //Send back a NACK\n\n    I2C2CONbits.ACKDT = 1; //Send NACK\n\n    I2C2CONbits.ACKEN = 1; //Start the acknowledge sequence\n\n    I2CIdle(); //Wait until done\n\n    return data;\n\n}  The register address is sent, which is followed by a restart condition. Then the device address is sent, BUT this time, the read bit is sent. At this point, the master enables receiving and waits until all data is received. A NACK (Not Acknowledgement) is sent prior to returning the data.  The device and register addresses depend on the device and its functionality.",
            "title": "In the code"
        },
        {
            "location": "/picpilot/datalink/",
            "text": "Datalink\n\n\nThe datalink is one of the most important peripheral components in an unmanned\nsystem. It provides information on the status of the aircraft (telemetry) and\nprovides the crucial functionality of an uplink, in order to be able to\ncommunicate with the system and make changes to its overall functionality.\n\n\nMake note that the details of this system can change frequently due to the\nrequirements of each user. The telemetry data may change from the ones present\nin this document. Likewise, uplink commands may change based on newly\nimplemented features and requirements. Although, this document should be updated\nwhenever there is a change, this may not always occur. Therefore, be careful\nwhen referencing data in this section.\n\n\nTelemetry (Downlink) Data\n\n\nThe Picpilot sends down packets based on priorities. There are 3 priorities of\npackets.\n\n\n\n\nPriority 1\n: \nHigh frequency - multiple times a second\n\n\nPriority 2\n: \nMedium frequency - once every second\n\n\nPriority 3\n: \nLow frequency - have to be triggered from a relevant update\n\n\n\n\nThe implementation of packets is due to the 100 byte limit that we can send data\ndown the Xbees. The PicPilot will send each of the three packets seperately, and\nat different intervals. For Priority 3 packets, an update event will trigger\nthe packet to be sent down. For example, if gains were updated, a priority 3\npacket will be sent back since it contains information on the gains.\n\n\nPriority 1 Packet Reference\n\n\nNote\n:\n\n\n\n\nlong double\n is 64-bit\n\n\nfloat\n is 32-bit\n\n\nint\n is 32-bit\n\n\nchar\n is 8-bit or 1 byte\n\n\n\n\n\n\n\n\n\n\nData\n\n\nHeader Name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLatitude\n\n\nlat\n\n\nlong double\n\n\nLatitude location of the airplane in degrees\n\n\n\n\n\n\nLongitude\n\n\nlon\n\n\nlong double\n\n\nLongitude location of the airplane in degrees\n\n\n\n\n\n\nElapsed Time\n\n\nsys_time\n\n\nlong int\n\n\nTime elapsed since the picpilot was started in seconds\n\n\n\n\n\n\nCurrent Time\n\n\ntime\n\n\nfloat\n\n\nThe time as a UTC time stamp (seconds from Jan 1, 1970)\n\n\n\n\n\n\nPitch\n\n\npitch\n\n\nfloat\n\n\nPitch of the aircraft in degrees\n\n\n\n\n\n\nRoll\n\n\nroll\n\n\nfloat\n\n\nRoll of the aircraft in degrees\n\n\n\n\n\n\nYaw\n\n\nyaw\n\n\nfloat\n\n\nYaw according to magnetometer on the IMU in degrees.\n\n\n\n\n\n\nPitch Rate\n\n\npitch_rate\n\n\nfloat\n\n\nFrom the gyroscope. In radians/s\n\n\n\n\n\n\nRoll Rate\n\n\nroll_rate\n\n\nfloat\n\n\nFrom the gyroscope. In radians/s\n\n\n\n\n\n\nYaw Rate\n\n\nyaw_rate\n\n\nfloat\n\n\nFrom the gyroscope. In radians/s\n\n\n\n\n\n\nHeading\n\n\nheading\n\n\nint\n\n\nGPS heading of the aircraft in degrees ranging from 0 to 360.\n\n\n\n\n\n\nAltitude\n\n\naltitude\n\n\nfloat\n\n\nAltitude of the plane above the mean sea level (in meters)\n\n\n\n\n\n\nAir Speed\n\n\nairspeed\n\n\nfloat\n\n\nCurrent speed of the aircraft based on the airspeed sensor in m/s\n\n\n\n\n\n\nGround Speed\n\n\nground_speed\n\n\nfloat\n\n\nGround speed of the aircraft in m/s\n\n\n\n\n\n\nPitch Setpoint\n\n\npitch_setpoint\n\n\nint\n\n\nCurrent pitch setpoint in degrees\n\n\n\n\n\n\nRoll Setpoint\n\n\nroll_setpoint\n\n\nint\n\n\nCurrent roll setpoint in degrees.\n\n\n\n\n\n\nPitch Rate Setpoint\n\n\npitch_rate_setpoint\n\n\nint\n\n\nCurrent pitch rate setpoint in rad/s\n\n\n\n\n\n\nRoll Rate Setpoint\n\n\nroll_rate_setpoint\n\n\nint\n\n\nCurrent roll rate setpoint in rad/s\n\n\n\n\n\n\nThrottle Setpoint\n\n\nthrottle_setpoint\n\n\nint\n\n\nCurrent throttle pwm value. Ranges from -1024 to 1024, with 0 being at %50\n\n\n\n\n\n\n\n\nPriority 2 Packet Reference\n\n\n\n\n\n\n\n\nData\n\n\nHeader Name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRoll KD Gain\n\n\nroll_kd\n\n\nfloat\n\n\nDerivative gain for roll\n\n\n\n\n\n\nRoll KP Gain\n\n\nroll_kp\n\n\nfloat\n\n\nProportional gain for roll\n\n\n\n\n\n\nPitch KD Gain\n\n\npitch_kd\n\n\nfloat\n\n\nDerivative gain for pitch\n\n\n\n\n\n\nPitch KP Gain\n\n\npitch_kp\n\n\nfloat\n\n\nProportional gain for pitch\n\n\n\n\n\n\nYaw KP Gain\n\n\nyaw_kp\n\n\nfloat\n\n\nProportional gain for yaw\n\n\n\n\n\n\nYaw KD Gain\n\n\nyaw_kd\n\n\nfloat\n\n\nDerivative gain for yaw\n\n\n\n\n\n\nYaw Rate Setpoint\n\n\nyaw_rate_setpoint\n\n\nint\n\n\nCurrent yaw rate setpoint in rad/s\n\n\n\n\n\n\nHeading Setpoint\n\n\nheading_setpoint\n\n\nint\n\n\nCurrent heading setpoint in degrees\n\n\n\n\n\n\nAltitude Setpoint\n\n\naltitude_setpoint\n\n\nint\n\n\nCurrent altitude setpoint in m\n\n\n\n\n\n\nFlap Setpoint\n\n\nflap_setpoint\n\n\nint\n\n\nCurrent flap setpoint pwm value. Ranges from -1024 to 1024, with 0 being in middle\n\n\n\n\n\n\nLast Command Sent (0)\n\n\nlast_command_sent0\n\n\nint\n\n\nID of the most recent command sent\n\n\n\n\n\n\nLast Command Sent (1)\n\n\nlast_command_sent1\n\n\nint\n\n\nID of the most 2nd most recent command sent\n\n\n\n\n\n\nLast Command Sent (2)\n\n\nlast_command_sent2\n\n\nint\n\n\nID of the most 3rd most recent command sent\n\n\n\n\n\n\nLast Command Sent (3)\n\n\nlast_command_sent3\n\n\nint\n\n\nID of the most 4th most recent command sent\n\n\n\n\n\n\nBattery 1 Level\n\n\nbattery_level1\n\n\nint\n\n\nPWM voltage of motor battery. Ranges from -1024 to 1024, with 1024 being full voltage\n\n\n\n\n\n\nBattery 2 Level\n\n\nbattery_level2\n\n\nint\n\n\nPWM voltage of autopilot battery. Ranges from -1024 to 1024, with 1024 being full voltage\n\n\n\n\n\n\nCamera Status\n\n\ncamera_status\n\n\nint\n\n\nCurrent number of photos taken by the camera\n\n\n\n\n\n\nWireless Connection Status\n\n\nwireless_connection\n\n\nint\n\n\nWhether the plane has UHF and is in manual (full rc) or autopilot mode. Read below for bitmask guide\n\n\n\n\n\n\nAutopilot Active Status\n\n\nautopilot_active\n\n\nint\n\n\nCurrent autopilot state. ie. Initializing, Armed, etc. Read below for bitmask guide\n\n\n\n\n\n\nGPS Status\n\n\ngpsStatus\n\n\nint\n\n\nIndicates # of satellites connected, as well as gps fix. Check bellow for how to parse the value\n\n\n\n\n\n\nNumber of Waypoints\n\n\nwaypoint_count\n\n\nint\n\n\nCurrent number of waypoints\n\n\n\n\n\n\nPath Following Status\n\n\npath_following\n\n\nchar\n\n\nWhether path following has been turned on. 1 if on\n\n\n\n\n\n\nPath Checksum\n\n\npath_checksum\n\n\nfloat\n\n\nChecksum to verify path. Calculated by adding altitude, lat, lon and radius of all waypoints\n\n\n\n\n\n\nChannel 1 Input\n\n\nch1In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 2 Input\n\n\nch2In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 3 Input\n\n\nch3In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 4 Input\n\n\nch4In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 5 Input\n\n\nch5In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 6 Input\n\n\nch6In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 7 Input\n\n\nch7In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 8 Input\n\n\nch8In\n\n\nint\n\n\nInput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 1 Output\n\n\nch1out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 2 Output\n\n\nch2out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 3 Output\n\n\nch3out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 4 Output\n\n\nch4out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 5 Output\n\n\nch5out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 6 Output\n\n\nch6out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 7 Output\n\n\nch7out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\nChannel 8 Output\n\n\nch8out\n\n\nint\n\n\nOutput from RC Controller. Integer value usually from -1024 to 1024, and -3072\n\n\n\n\n\n\n\n\nPriority Packet 3 Reference\n\n\n\n\n\n\n\n\nData\n\n\nHeader Name\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRoll KI Gain\n\n\nroll_ki\n\n\nfloat\n\n\nIntegral gain for roll\n\n\n\n\n\n\nPitch KI Gain\n\n\npitch_ki\n\n\nfloat\n\n\nIntegral gain for pitch\n\n\n\n\n\n\nYaw KI Gain\n\n\nyaw_ki\n\n\nfloat\n\n\nIntegral gain for yaw\n\n\n\n\n\n\nHeading KD Gain\n\n\nheading_kd\n\n\nfloat\n\n\nDerivative gain for heading\n\n\n\n\n\n\nHeading KI Gain\n\n\nheading_ki\n\n\nfloat\n\n\nIntegral gain for heading\n\n\n\n\n\n\nAltitude KD Gain\n\n\naltitude_kd\n\n\nfloat\n\n\nDerivative gain for altitude\n\n\n\n\n\n\nAltitude KP Gain\n\n\naltitude_kp\n\n\nfloat\n\n\nProportional gain for altitude\n\n\n\n\n\n\nAltitude KI Gain\n\n\naltitude_ki\n\n\nfloat\n\n\nIntegral gain for altitude\n\n\n\n\n\n\nThrottle KD Gain\n\n\nthrottle_kd\n\n\nfloat\n\n\nDerivative gain for throttle\n\n\n\n\n\n\nThrottle KI Gain\n\n\nthrottle_ki\n\n\nfloat\n\n\nIntegral gain for throttle\n\n\n\n\n\n\nThrottle KP Gain\n\n\nthrottle_kp\n\n\nfloat\n\n\nProportional gain for throttle\n\n\n\n\n\n\nFlap KD Gain\n\n\nflap_kd\n\n\nfloat\n\n\nDerivative gain for flap\n\n\n\n\n\n\nFlap KP Gain\n\n\nflap_kp\n\n\nfloat\n\n\nProportional gain for flap\n\n\n\n\n\n\nFlap KI Gain\n\n\nflap_ki\n\n\nfloat\n\n\nIntegral gain for flap\n\n\n\n\n\n\nPath Gain\n\n\npath_gain\n\n\nfloat\n\n\nProportional Path gain. How hard the aircraft adjust to follow the path\n\n\n\n\n\n\nOrbital Gain\n\n\norbit_gain\n\n\nfloat\n\n\nProportional Orbital gain. How hard the aircraft turn around waypoints\n\n\n\n\n\n\nAutonomous Level\n\n\nautonomousLevel\n\n\nint\n\n\nAutonomous level of the aircraft. Read below for how to interpret the value\n\n\n\n\n\n\nStartup Error Codes\n\n\nstartup_error_codes\n\n\nint\n\n\nStartup error codes for the autopilot. Read below for how to interpret it\n\n\n\n\n\n\nStartup Settings\n\n\nstartupSettings\n\n\nint\n\n\nWhether the aircraft is in plane or quad mode. Read below for bitmask guide\n\n\n\n\n\n\nProbe Status\n\n\nprobe_status\n\n\nint\n\n\nBitmask for determining which of the 3 probes have been released\n\n\n\n\n\n\n\n\nNote that all telemetry data must be visible within the scope of the AttitudeManager.c file.\n\n\nCommand (Uplink) Data\n\n\nEvery command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.\n\n\n\n\n\n\n\n\nID\n\n\nSocket Command\n\n\nFormat\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n0\n\n\ndebug:\ndata\n\n\n`char[]\n\n\nThe debugging command, which writes to the UART1 port.\n\n\n\n\n\n\n1\n\n\nset_pitchKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for pitch control.\n\n\n\n\n\n\n2\n\n\nset_rollKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for roll control.\n\n\n\n\n\n\n3\n\n\nset_yawKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for yaw control.\n\n\n\n\n\n\n4\n\n\nset_pitchKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for pitch control.\n\n\n\n\n\n\n5\n\n\nset_rollKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n6\n\n\nset_yawKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n7\n\n\nset_pitchKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the integral gain for pitch control.\n\n\n\n\n\n\n8\n\n\nset_rollKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for roll control.\n\n\n\n\n\n\n9\n\n\nset_yawKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for yaw control.\n\n\n\n\n\n\n10\n\n\nset_headingKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for heading control.\n\n\n\n\n\n\n11\n\n\nset_headingKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for heading control.\n\n\n\n\n\n\n12\n\n\nset_headingKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the integral gain for heading control.\n\n\n\n\n\n\n13\n\n\nset_altitudeKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for altitude control.\n\n\n\n\n\n\n14\n\n\nset_altitudeKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the proportional gain for altitude control.\n\n\n\n\n\n\n15\n\n\nset_altitudeKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the integral gain for altitude control.\n\n\n\n\n\n\n16\n\n\nset_throttleKDGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n17\n\n\nset_throttleKPGain:\ndata\n\n\nfloat\n\n\nThe command to set the derivative gain for throttle control (speed).\n\n\n\n\n\n\n18\n\n\nset_throttleKIGain:\ndata\n\n\nfloat\n\n\nThe command to set the integral gain for throttle control (speed).\n\n\n\n\n\n\n19\n\n\nset_pathGain:\ndata\n\n\nfloat\n\n\nThe command used to set the gain that scales lateral positional control around a path.\n\n\n\n\n\n\n20\n\n\nset_orbitGain:\ndata\n\n\nfloat\n\n\nThe command used to set the gain that scales orbital convergence.\n\n\n\n\n\n\n21\n\n\nset_showGain:\ndata\n\n\nchar\n\n\nNOT SUPPORTED ANYMORE\n\n\n\n\n\n\n22\n\n\nset_pitchRate:\ndata\n\n\nint\n\n\nThe user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n23\n\n\nset_rollRate:\ndata\n\n\nint\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n24\n\n\nset_yawRate:\ndata\n\n\nint\n\n\nThe user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.\n\n\n\n\n\n\n25\n\n\nset_pitchAngle:\ndata\n\n\nfloat\n\n\nThe user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n26\n\n\nset_rollAngle:\ndata\n\n\nfloat\n\n\nThe user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n27\n\n\nset_yawAngle:\ndata\n\n\nfloat\n\n\nThe user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.\n\n\n\n\n\n\n28\n\n\nset_altitude:\ndata\n\n\nfloat\n\n\nThe user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.\n\n\n\n\n\n\n29\n\n\nset_heading:\ndata\n\n\nfloat\n\n\nThe user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.\n\n\n\n\n\n\n30\n\n\nset_throttle:\ndata\n\n\nint\n\n\nThe user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.\n\n\n\n\n\n\n31\n\n\nset_autonomousLevel:\ndata\n\n\nint\n\n\nSets the autonomous level (full groundstation, full rc, etc.) Read below for more info\n\n\n\n\n\n\n32\n\n\nset_angularWalkVariance:\ndata\n\n\nfloat\n\n\nSets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.\n\n\n\n\n\n\n34\n\n\nset_magneticVariance:\ndata\n\n\nfloat\n\n\nSets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.\n\n\n\n\n\n\n35\n\n\nset_accelVariance:\ndata\n\n\nfloat\n\n\nSets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.\n\n\n\n\n\n\n36\n\n\nset_scaleFactor:\ndata\n\n\nfloat\n\n\nSets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.\n\n\n\n\n\n\n37\n\n\ncalibrate_altimeter:\ndata\n\n\nfloat\n\n\nThis sets the reference height on the altimeter to a predefined value. This allows one to choose a \nrelative\n value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.\n\n\n\n\n\n\n38\n\n\nclear_waypoints:\ndata\n\n\nbyte\n\n\nThis command clears ALL waypoints. The \ndata\n is just a dummy variable.\n\n\n\n\n\n\n39\n\n\nremove_waypoint:\ndata\n\n\nbyte\n\n\nThis command removes a specific waypoint given a specific ID as the parameter.\n\n\n\n\n\n\n40\n\n\nset_targetWaypoint:\ndata\n\n\nbyte\n\n\nThe target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The \ndata\n is the specified ID for the new target.\n\n\n\n\n\n\n41\n\n\nreturn_home:\ndata\n\n\nbyte\n\n\nThis tells the plane to go to the \"home\" coordinates. The \ndata\n is just a dummy variable.\n\n\n\n\n\n\n42\n\n\ncancel_returnHome:\ndata\n\n\nbyte\n\n\nThis tells the plane to return back to its original path after being called to the \"home\" coordinates.\n\n\n\n\n\n\n43\n\n\nsend_heartbeat:\ndata\n\n\nbyte\n\n\nThis sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.\n\n\n\n\n\n\n44\n\n\ntrigger_camera:\ndata\n\n\nint\n\n\nThis manually triggers the camera via a \"fake\" PWM signal. The \ndata\n is the integer value of the PWM signal.\n\n\n\n\n\n\n45\n\n\nset_triggerDistance:\ndata\n\n\nfloat\n\n\nThis sets the trigger distance (how often a picture is taken based on distance). This \ndata\n is a value in meters.\n\n\n\n\n\n\n46\n\n\nset_gimbleOffset:\ndata\n\n\nint\n\n\nThis provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.\n\n\n\n\n\n\n47\n\n\nkill_plane:\ndata\n\n\nint\n\n\nThis crashes the plane into the ground (in emergencies). This requires a password (\ndata\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n48\n\n\nunkill_plane:\ndata\n\n\nint\n\n\nThis changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password (\ndata\n = \"1234\") to ensure this isn't an accident.\n\n\n\n\n\n\n128\n\n\nnew_waypoint:\nlon\n,\nlat\n,\nalt\n,\nradius\n ,\ntype\n\n\n2x\ndouble\n,2x\nfloat\n,\nchar\n\n\nThis uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. Type \n1\n for probe drop, type \n0\n for regular waypoint\n\n\n\n\n\n\n129\n\n\ninsert_Waypoint:\nlon\n,\nlat\n,\nalt\n,\nradius\n,\ntype\n, \nprev_id\n,\nnext_id\n\n\n2x\ndouble\n,2x\nfloat\n,3x\nchar\n\n\nThis uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions.\n\n\n\n\n\n\n130\n\n\nset_ReturnHomeCoordinates:\nlon\n,\nlat\n,\nalt\n\n\n3x\nfloat\n\n\nThis sets the home coordinates, to which the plane will return in case of an emergency.\n\n\n\n\n\n\n131\n\n\ntare_IMU:\ndata\n,\ndata\n,\ndata\n\n\n3x\nfloat\n\n\nThis adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.\n\n\n\n\n\n\n132\n\n\nset_IMU:\ndata\n,\ndata\n,\ndata\n\n\n3x\nfloat\n\n\nThis is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.\n\n\n\n\n\n\n132\n\n\nfollow_path:\ndata\n,\ndata\n,\ndata\n\n\n3x\nfloat\n\n\nThis is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.\n\n\n\n\n\n\n132\n\n\ndrop_probe:\ndata\n,\ndata\n,\ndata\n\n\n3x\nfloat\n\n\nThis is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.\n\n\n\n\n\n\n\n\nInterpretting startup settings\n\n\nInterpreting GPS\n\n\nEg. 0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites\n\n\nvar checkGPS = function (data) {\n   if(data !== null) {\n     var connection_status = ((data & 0xf0) >> 4) > 0; // if theres at least 1 fix\n     if (connection_status !== this.gps.status) { //if its a different status\n       this.gps.status = connection_status;\n       StatusManager.setStatusCode('GPS_LOST', !this.gps.status);\n       if (this.gps.status === false) { //if it was set to false, start the timer\n         this.gps.timeSinceLost = Date.now();\n       }\n       else {\n         this.gps.timeSinceLost = null;\n       }\n     }\n   }\n  }.bind(this);\n\n\n\n\nInterpreting autopilot_active\n\n\nvar checkPlaneStatus = function (number) {\n    if(number !== null){\n      this.initializing = (number === 0);\n      if (number === 1) { //only set armed to false if the number is ONLY 1\n        this.armed = false;\n      }\n      this.armed = (number === 2);\n      this.running = (number === 3);\n      this.killModeWarning = (number === 4);\n      this.killModeActive = (number === 5);\n\n      StatusManager.setStatusCode('AIRCRAFT_INITIALIZE', this.initializing);\n      StatusManager.setStatusCode('AIRCRAFT_UNARMED', !this.armed);\n      StatusManager.setStatusCode('AIRCRAFT_ARMED', this.armed);\n      StatusManager.setStatusCode('AIRCRAFT_RUNNING', this.running);\n      StatusManager.setStatusCode('AIRCRAFT_KILLMODE_WARNING', this.killModeWarning);\n      StatusManager.setStatusCode('AIRCRAFT_KILLMODE', this.killModeActive);\n    }\n  }.bind(this);\n  ```\n### Interpreting wireless connection\n\n\n\n\nvar checkUHFStatus = function (data) {\n    if(data !== null){\n      var bitmask = new Bitmask(data);\n      this.uhf.status = bitmask.getBit(1);\n\n\n  if (this.uhf.status) { //has been turned to true\n    this.uhf.timeSinceLost = null;\n  }\n  else { //has been turned to false\n    this.uhf.timeSinceLost = Date.now();\n  }\n  StatusManager.setStatusCode('UHF_LOST', !this.uhf.status);\n}\n\n\n\n}.bind(this);\n\n\nvar checkManualMode = function (data) {\n    if(data !== null){\n      var bitmask = new Bitmask(data);\n      this.manualMode = !bitmask.getBit(0);\n      StatusManager.setStatusCode('MANUAL_MODE', this.manualMode);\n    }\n  }.bind(this);\n\n\n### Interpreting Autonotmous level\n```javascript\nif (alevel.getBit(0)) {\n        this.ui.remote_pitch_type.text('Angle');\n      }\n      else {\n        this.ui.remote_pitch_type.text('Rate');\n      }\n      if (alevel.getBit(1)) {\n        this.ui.remote_pitch_source.text('Ground Station');\n      }\n      else {\n        this.ui.remote_pitch_source.text('Controller');\n      }\n      if (alevel.getBit(2)) {\n        this.ui.remote_roll_type.text('Angle');\n      }\n      else {\n        this.ui.remote_roll_type.text('Rate');\n      }\n      if (alevel.getBit(3)) {\n        this.ui.remote_roll_source.text('Ground Station');\n      }\n      else {\n        this.ui.remote_roll_source.text('Controller');\n      }\n      if (alevel.getBit(5)) {\n        this.ui.remote_throttle_source.text('Autopilot');\n      }\n      else if (alevel.getBit(4)) {\n        this.ui.remote_throttle_source.text('Groundstation');\n      }\n      else {\n        this.ui.remote_throttle_source.text('Controller');\n      }\n      if (alevel.getBit(6)) {\n        this.ui.remote_altitude_source.text('Autopilot');\n      }\n      else {\n        this.ui.remote_altitude_source.text('Groundstation');\n      }\n      if (alevel.getBit(7)) {\n        this.ui.remote_altitude_toggle.text('On');\n      }\n      else {\n        this.ui.remote_altitude_toggle.text('Off');\n      }\n      if (alevel.getBit(8)) {\n        this.ui.remote_heading_source.text('Autopilot');\n      }\n      else {\n        this.ui.remote_heading_source.text('Groundstation');\n      }\n      if (alevel.getBit(9)) {\n        this.ui.remote_heading_toggle.text('On');\n      }\n      else {\n        this.ui.remote_heading_toggle.text('Off');\n      }\n      if (alevel.getBit(11)) {\n        this.ui.remote_flap_source.text('Autopilot');\n      }\n      else if (alevel.getBit(10)) {\n        this.ui.remote_flap_source.text('Groundstation');\n      }\n      else {\n        this.ui.remote_flap_source.text('Controller');\n      }\n    },\n\n\n\n\nInterpreting error codes\n\n\nSignals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)\n\n\nIn the code\n\n\nPrior to usage, the datalink must be initialized.  This is done so in \nmain.c _using _initDataLink()\n. This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.\n\n\nAfter initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.\n\n\nIn the code \u2013 Downlink/Telemetry\n\n\nData is exported to the data link at a certain frequency (according to a clock). This is done by calling \nwriteDatalink(frequency)\n, where frequency is the time between packets. This subroutine creates a structure (defined in \nnet.h\n) which contains memory locations for every variable. This data is then pushed to be processed in \nnet_outbound.c\n.\n\n\nif (time - lastTime > frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData->lat = gps_Latitude;\n\n    statusData->lon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}\n\n\n\nWhen all the data is assembled in the struct, \npushOutboundTelemetryQueue(statusData)\n is called. This pushes the data onto a queue to be processed later:\n\n\nint pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength() >= OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}\n\n\n\nNote that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.\n\n\nEvery once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is \noutboundBufferMaintenance()\n:\n\n\nif ( stagingBuffer.sendIndex >= PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0 && getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}\n\n\n\nNote that the structure of \nstagingBuffer\n is as follows:\n\n\nstruct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};\n\n\n\nNote that the \nstagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer\n structure. The 4th component is the \nsendIndex\n variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.\n\n\nAfter sufficient error checking (making sure \nsendIndex\n is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent. \nstageTelemetryBlock()\n is responsible for converting the telemetry data into a \ntelem_buffer\n structure.\n\n\nvoid stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}\n\n\n\nThe first line of the subroutine adds the data into the packet. The second line (\ngenerateApiHeader(stagingBuffer.header,0))\n creates an appropriate header in the \nstagingBuffer.header\n memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the \nchecksum\n and \nsendIndex\n are explicitly reset, the sending process begins with \nsendNextByte()\n:\n\n\nvoid sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex < API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex] & 0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex >= 3) {\n\n            stagingBuffer.checksum += sendByte & 0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex < PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH] & 0xFF;\n\n        stagingBuffer.checksum += sendByte & 0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum & 0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}\n\n\n\nAll the \"\nif\n\" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum & 0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling \nsendNextByte()\n, until there is no more data left:\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}\n\n\n\nThe process can be described through this flowchart:\n\n\n\n\nIn the code \u2013 Uplink\n\n\nOnce every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command \npopCommand()\n is called. If any new commands have been received, \npopCommand()\n will return a \ncommand\n struct (defined in \nnet.h\n):\n\n\nstruct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};\n\n\n\nIt is fairly straight forward. The structure contains a \ncmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c\n):\n\n\nstruct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd->cmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd->cmd * 100;\n\n    }\n\n    switch (cmd->cmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)(&cmd->data) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}\n\n\n\nThe throttle ends up being set to the value indicated in the \ncmd.data\n location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.\n\n\nThe \npopCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE\n variable). If the command doesn't exist, it exits the function.\n\n\nIn order for the command structure to exist, the \nU2RXInterrupt\n must have been triggered. This occurs when new data is sent.\n\n\nvoid __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length < 100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos && payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}\n\n\n\nThe first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A \nif statement\n is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current \npacketPos\n marked busy.\n\n\nIf the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.\n\n\nFirstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the \ndata\n is read into a 2d array called \nrawPackets\n. This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as \nREADY\n, and the next one is marked \nBUSY\n if it is \nEMPTY\n, and the processing of the data begins on the next maintenance cycle when \ninboundBufferMaintenance()\n is called from \nmain.c\n:\n\n\nvoid inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i < RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY && checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}\n\n\n\nThis subroutine iterates through each buffer location and checks for any \nREADY\n packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the \ncreateCommand(rawPackets[i])\n method. Once this is done, the previous spot is marked \nEMPTY\n. The first buffer is always primed if it is empty.",
            "title": "Datalink"
        },
        {
            "location": "/picpilot/datalink/#datalink",
            "text": "The datalink is one of the most important peripheral components in an unmanned\nsystem. It provides information on the status of the aircraft (telemetry) and\nprovides the crucial functionality of an uplink, in order to be able to\ncommunicate with the system and make changes to its overall functionality.  Make note that the details of this system can change frequently due to the\nrequirements of each user. The telemetry data may change from the ones present\nin this document. Likewise, uplink commands may change based on newly\nimplemented features and requirements. Although, this document should be updated\nwhenever there is a change, this may not always occur. Therefore, be careful\nwhen referencing data in this section.",
            "title": "Datalink"
        },
        {
            "location": "/picpilot/datalink/#telemetry-downlink-data",
            "text": "The Picpilot sends down packets based on priorities. There are 3 priorities of\npackets.   Priority 1 :  High frequency - multiple times a second  Priority 2 :  Medium frequency - once every second  Priority 3 :  Low frequency - have to be triggered from a relevant update   The implementation of packets is due to the 100 byte limit that we can send data\ndown the Xbees. The PicPilot will send each of the three packets seperately, and\nat different intervals. For Priority 3 packets, an update event will trigger\nthe packet to be sent down. For example, if gains were updated, a priority 3\npacket will be sent back since it contains information on the gains.",
            "title": "Telemetry (Downlink) Data"
        },
        {
            "location": "/picpilot/datalink/#priority-1-packet-reference",
            "text": "Note :   long double  is 64-bit  float  is 32-bit  int  is 32-bit  char  is 8-bit or 1 byte      Data  Header Name  Type  Description      Latitude  lat  long double  Latitude location of the airplane in degrees    Longitude  lon  long double  Longitude location of the airplane in degrees    Elapsed Time  sys_time  long int  Time elapsed since the picpilot was started in seconds    Current Time  time  float  The time as a UTC time stamp (seconds from Jan 1, 1970)    Pitch  pitch  float  Pitch of the aircraft in degrees    Roll  roll  float  Roll of the aircraft in degrees    Yaw  yaw  float  Yaw according to magnetometer on the IMU in degrees.    Pitch Rate  pitch_rate  float  From the gyroscope. In radians/s    Roll Rate  roll_rate  float  From the gyroscope. In radians/s    Yaw Rate  yaw_rate  float  From the gyroscope. In radians/s    Heading  heading  int  GPS heading of the aircraft in degrees ranging from 0 to 360.    Altitude  altitude  float  Altitude of the plane above the mean sea level (in meters)    Air Speed  airspeed  float  Current speed of the aircraft based on the airspeed sensor in m/s    Ground Speed  ground_speed  float  Ground speed of the aircraft in m/s    Pitch Setpoint  pitch_setpoint  int  Current pitch setpoint in degrees    Roll Setpoint  roll_setpoint  int  Current roll setpoint in degrees.    Pitch Rate Setpoint  pitch_rate_setpoint  int  Current pitch rate setpoint in rad/s    Roll Rate Setpoint  roll_rate_setpoint  int  Current roll rate setpoint in rad/s    Throttle Setpoint  throttle_setpoint  int  Current throttle pwm value. Ranges from -1024 to 1024, with 0 being at %50",
            "title": "Priority 1 Packet Reference"
        },
        {
            "location": "/picpilot/datalink/#priority-2-packet-reference",
            "text": "Data  Header Name  Type  Description      Roll KD Gain  roll_kd  float  Derivative gain for roll    Roll KP Gain  roll_kp  float  Proportional gain for roll    Pitch KD Gain  pitch_kd  float  Derivative gain for pitch    Pitch KP Gain  pitch_kp  float  Proportional gain for pitch    Yaw KP Gain  yaw_kp  float  Proportional gain for yaw    Yaw KD Gain  yaw_kd  float  Derivative gain for yaw    Yaw Rate Setpoint  yaw_rate_setpoint  int  Current yaw rate setpoint in rad/s    Heading Setpoint  heading_setpoint  int  Current heading setpoint in degrees    Altitude Setpoint  altitude_setpoint  int  Current altitude setpoint in m    Flap Setpoint  flap_setpoint  int  Current flap setpoint pwm value. Ranges from -1024 to 1024, with 0 being in middle    Last Command Sent (0)  last_command_sent0  int  ID of the most recent command sent    Last Command Sent (1)  last_command_sent1  int  ID of the most 2nd most recent command sent    Last Command Sent (2)  last_command_sent2  int  ID of the most 3rd most recent command sent    Last Command Sent (3)  last_command_sent3  int  ID of the most 4th most recent command sent    Battery 1 Level  battery_level1  int  PWM voltage of motor battery. Ranges from -1024 to 1024, with 1024 being full voltage    Battery 2 Level  battery_level2  int  PWM voltage of autopilot battery. Ranges from -1024 to 1024, with 1024 being full voltage    Camera Status  camera_status  int  Current number of photos taken by the camera    Wireless Connection Status  wireless_connection  int  Whether the plane has UHF and is in manual (full rc) or autopilot mode. Read below for bitmask guide    Autopilot Active Status  autopilot_active  int  Current autopilot state. ie. Initializing, Armed, etc. Read below for bitmask guide    GPS Status  gpsStatus  int  Indicates # of satellites connected, as well as gps fix. Check bellow for how to parse the value    Number of Waypoints  waypoint_count  int  Current number of waypoints    Path Following Status  path_following  char  Whether path following has been turned on. 1 if on    Path Checksum  path_checksum  float  Checksum to verify path. Calculated by adding altitude, lat, lon and radius of all waypoints    Channel 1 Input  ch1In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 2 Input  ch2In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 3 Input  ch3In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 4 Input  ch4In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 5 Input  ch5In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 6 Input  ch6In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 7 Input  ch7In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 8 Input  ch8In  int  Input from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 1 Output  ch1out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 2 Output  ch2out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 3 Output  ch3out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 4 Output  ch4out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 5 Output  ch5out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 6 Output  ch6out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 7 Output  ch7out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072    Channel 8 Output  ch8out  int  Output from RC Controller. Integer value usually from -1024 to 1024, and -3072",
            "title": "Priority 2 Packet Reference"
        },
        {
            "location": "/picpilot/datalink/#priority-packet-3-reference",
            "text": "Data  Header Name  Type  Description      Roll KI Gain  roll_ki  float  Integral gain for roll    Pitch KI Gain  pitch_ki  float  Integral gain for pitch    Yaw KI Gain  yaw_ki  float  Integral gain for yaw    Heading KD Gain  heading_kd  float  Derivative gain for heading    Heading KI Gain  heading_ki  float  Integral gain for heading    Altitude KD Gain  altitude_kd  float  Derivative gain for altitude    Altitude KP Gain  altitude_kp  float  Proportional gain for altitude    Altitude KI Gain  altitude_ki  float  Integral gain for altitude    Throttle KD Gain  throttle_kd  float  Derivative gain for throttle    Throttle KI Gain  throttle_ki  float  Integral gain for throttle    Throttle KP Gain  throttle_kp  float  Proportional gain for throttle    Flap KD Gain  flap_kd  float  Derivative gain for flap    Flap KP Gain  flap_kp  float  Proportional gain for flap    Flap KI Gain  flap_ki  float  Integral gain for flap    Path Gain  path_gain  float  Proportional Path gain. How hard the aircraft adjust to follow the path    Orbital Gain  orbit_gain  float  Proportional Orbital gain. How hard the aircraft turn around waypoints    Autonomous Level  autonomousLevel  int  Autonomous level of the aircraft. Read below for how to interpret the value    Startup Error Codes  startup_error_codes  int  Startup error codes for the autopilot. Read below for how to interpret it    Startup Settings  startupSettings  int  Whether the aircraft is in plane or quad mode. Read below for bitmask guide    Probe Status  probe_status  int  Bitmask for determining which of the 3 probes have been released     Note that all telemetry data must be visible within the scope of the AttitudeManager.c file.",
            "title": "Priority Packet 3 Reference"
        },
        {
            "location": "/picpilot/datalink/#command-uplink-data",
            "text": "Every command that is sent to the UAV must be predefined with an ID, as well as an associated function. Some commands only change variable values, whereas some call functions with the associated data as a parameter.     ID  Socket Command  Format  Description      0  debug: data  `char[]  The debugging command, which writes to the UART1 port.    1  set_pitchKDGain: data  float  The command to set the derivative gain for pitch control.    2  set_rollKDGain: data  float  The command to set the derivative gain for roll control.    3  set_yawKDGain: data  float  The command to set the derivative gain for yaw control.    4  set_pitchKPGain: data  float  The command to set the proportional gain for pitch control.    5  set_rollKPGain: data  float  The command to set the proportional gain for roll control.    6  set_yawKPGain: data  float  The command to set the proportional gain for yaw control.    7  set_pitchKIGain: data  float  The command to set the integral gain for pitch control.    8  set_rollKIGain: data  float  The command to set the proportional gain for roll control.    9  set_yawKIGain: data  float  The command to set the proportional gain for yaw control.    10  set_headingKDGain: data  float  The command to set the derivative gain for heading control.    11  set_headingKPGain: data  float  The command to set the proportional gain for heading control.    12  set_headingKIGain: data  float  The command to set the integral gain for heading control.    13  set_altitudeKDGain: data  float  The command to set the derivative gain for altitude control.    14  set_altitudeKPGain: data  float  The command to set the proportional gain for altitude control.    15  set_altitudeKIGain: data  float  The command to set the integral gain for altitude control.    16  set_throttleKDGain: data  float  The command to set the derivative gain for throttle control (speed).    17  set_throttleKPGain: data  float  The command to set the derivative gain for throttle control (speed).    18  set_throttleKIGain: data  float  The command to set the integral gain for throttle control (speed).    19  set_pathGain: data  float  The command used to set the gain that scales lateral positional control around a path.    20  set_orbitGain: data  float  The command used to set the gain that scales orbital convergence.    21  set_showGain: data  char  NOT SUPPORTED ANYMORE    22  set_pitchRate: data  int  The user input for the pitch rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]). Note you must set command 32 greater than 4 to use this.    23  set_rollRate: data  int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    24  set_yawRate: data  int  The user input for the roll rate in PWM timer tick units. (Normal values range from 470 to 941 [dependent on setup]) Note you must set command 32 greater than 4 to use this.    25  set_pitchAngle: data  float  The user input for the pitch angle in degrees. Note you must set command 32 greater than 5 to use this.    26  set_rollAngle: data  float  The user input for the roll angle in degrees. Note you must set command 32 greater than 5 to use this.    27  set_yawAngle: data  float  The user input for the yaw angle in degrees. WILL LIKELY BE REMOVED IN THE FUTURE IF UNEEDED. Note you must set command 32 greater than 5 to use this.    28  set_altitude: data  float  The user input for the altitude in meters above sea level. Note you must set command 32 greater than 6 to use this.    29  set_heading: data  float  The user input for the heading in standard compass bearing degrees. Note you must set command 32 greater than 7 to use this.    30  set_throttle: data  int  The user input for the throttle as a percentage. Note you must set command 32 to 8 to use this.    31  set_autonomousLevel: data  int  Sets the autonomous level (full groundstation, full rc, etc.) Read below for more info    32  set_angularWalkVariance: data  float  Sets the Kalman filter parameter that determines the weighting of the gryo in the attitude estimates of the plane.    34  set_magneticVariance: data  float  Sets the Kalman filter parameter that determines the weighting of the magnetometers in the attitude estimates of the plane.    35  set_accelVariance: data  float  Sets the Kalman filter parameter that determines the weighting of the accelerometers in the attitude estimates of the plane.    36  set_scaleFactor: data  float  Sets the value for the feed-forward term of pitch, when the aircraft is turning. In other words, when the aircraft is turning, this proportion is added to the elevators to prevent the airplane from losing altitude.    37  calibrate_altimeter: data  float  This sets the reference height on the altimeter to a predefined value. This allows one to choose a  relative  value for the height aircraft. For example, one may set 0m to refer to the starting or landing terrain height.    38  clear_waypoints: data  byte  This command clears ALL waypoints. The  data  is just a dummy variable.    39  remove_waypoint: data  byte  This command removes a specific waypoint given a specific ID as the parameter.    40  set_targetWaypoint: data  byte  The target waypoint is the waypoint which the UAV is trying to currently get to. If this command is called, it can be used to skip waypoints, or return to waypoints. The  data  is the specified ID for the new target.    41  return_home: data  byte  This tells the plane to go to the \"home\" coordinates. The  data  is just a dummy variable.    42  cancel_returnHome: data  byte  This tells the plane to return back to its original path after being called to the \"home\" coordinates.    43  send_heartbeat: data  byte  This sends a \"heartbeat\" (verification ping) to the plane to tell it that a data connection is still present. If this command is not received after a certain amount of time, emergency maneuvers will be used.    44  trigger_camera: data  int  This manually triggers the camera via a \"fake\" PWM signal. The  data  is the integer value of the PWM signal.    45  set_triggerDistance: data  float  This sets the trigger distance (how often a picture is taken based on distance). This  data  is a value in meters.    46  set_gimbleOffset: data  int  This provides an offset to the gimbal. If the gimbal is misaligned on start up, this function can correct it.    47  kill_plane: data  int  This crashes the plane into the ground (in emergencies). This requires a password ( data  = \"1234\") to ensure this isn't an accident.    48  unkill_plane: data  int  This changes the state of the plane from \"I'm crashing\" to \"Nevermind, this was just a test\". This requires a password ( data  = \"1234\") to ensure this isn't an accident.    128  new_waypoint: lon , lat , alt , radius  , type  2x double ,2x float , char  This uploads and appends a waypoint to the aircraft based on corresponding gps coordinates and path instructions. Type  1  for probe drop, type  0  for regular waypoint    129  insert_Waypoint: lon , lat , alt , radius , type ,  prev_id , next_id  2x double ,2x float ,3x char  This uploads and inserts a waypoint to the aircraft based on corresponding gps coordinates and path instructions.    130  set_ReturnHomeCoordinates: lon , lat , alt  3x float  This sets the home coordinates, to which the plane will return in case of an emergency.    131  tare_IMU: data , data , data  3x float  This adds a bias adjustment to the matrix based on the last setting. The 3 data values are the x,y,z components of the aircraft.    132  set_IMU: data , data , data  3x float  This is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.    132  follow_path: data , data , data  3x float  This is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.    132  drop_probe: data , data , data  3x float  This is used to set the reference frame of the aircraft's IMU unit. The input values are the x,y,z values of the IMU's rotation respectively.",
            "title": "Command (Uplink) Data"
        },
        {
            "location": "/picpilot/datalink/#interpretting-startup-settings",
            "text": "",
            "title": "Interpretting startup settings"
        },
        {
            "location": "/picpilot/datalink/#interpreting-gps",
            "text": "Eg. 0x00 = No GPS Fix, 0 Satellites0x1A = GPS Fix, 10 Satellites0x24 = DGPS Fix, 4 Satellites  var checkGPS = function (data) {\n   if(data !== null) {\n     var connection_status = ((data & 0xf0) >> 4) > 0; // if theres at least 1 fix\n     if (connection_status !== this.gps.status) { //if its a different status\n       this.gps.status = connection_status;\n       StatusManager.setStatusCode('GPS_LOST', !this.gps.status);\n       if (this.gps.status === false) { //if it was set to false, start the timer\n         this.gps.timeSinceLost = Date.now();\n       }\n       else {\n         this.gps.timeSinceLost = null;\n       }\n     }\n   }\n  }.bind(this);",
            "title": "Interpreting GPS"
        },
        {
            "location": "/picpilot/datalink/#interpreting-autopilot_active",
            "text": "var checkPlaneStatus = function (number) {\n    if(number !== null){\n      this.initializing = (number === 0);\n      if (number === 1) { //only set armed to false if the number is ONLY 1\n        this.armed = false;\n      }\n      this.armed = (number === 2);\n      this.running = (number === 3);\n      this.killModeWarning = (number === 4);\n      this.killModeActive = (number === 5);\n\n      StatusManager.setStatusCode('AIRCRAFT_INITIALIZE', this.initializing);\n      StatusManager.setStatusCode('AIRCRAFT_UNARMED', !this.armed);\n      StatusManager.setStatusCode('AIRCRAFT_ARMED', this.armed);\n      StatusManager.setStatusCode('AIRCRAFT_RUNNING', this.running);\n      StatusManager.setStatusCode('AIRCRAFT_KILLMODE_WARNING', this.killModeWarning);\n      StatusManager.setStatusCode('AIRCRAFT_KILLMODE', this.killModeActive);\n    }\n  }.bind(this);\n  ```\n### Interpreting wireless connection  var checkUHFStatus = function (data) {\n    if(data !== null){\n      var bitmask = new Bitmask(data);\n      this.uhf.status = bitmask.getBit(1);    if (this.uhf.status) { //has been turned to true\n    this.uhf.timeSinceLost = null;\n  }\n  else { //has been turned to false\n    this.uhf.timeSinceLost = Date.now();\n  }\n  StatusManager.setStatusCode('UHF_LOST', !this.uhf.status);\n}  }.bind(this);  var checkManualMode = function (data) {\n    if(data !== null){\n      var bitmask = new Bitmask(data);\n      this.manualMode = !bitmask.getBit(0);\n      StatusManager.setStatusCode('MANUAL_MODE', this.manualMode);\n    }\n  }.bind(this);  ### Interpreting Autonotmous level\n```javascript\nif (alevel.getBit(0)) {\n        this.ui.remote_pitch_type.text('Angle');\n      }\n      else {\n        this.ui.remote_pitch_type.text('Rate');\n      }\n      if (alevel.getBit(1)) {\n        this.ui.remote_pitch_source.text('Ground Station');\n      }\n      else {\n        this.ui.remote_pitch_source.text('Controller');\n      }\n      if (alevel.getBit(2)) {\n        this.ui.remote_roll_type.text('Angle');\n      }\n      else {\n        this.ui.remote_roll_type.text('Rate');\n      }\n      if (alevel.getBit(3)) {\n        this.ui.remote_roll_source.text('Ground Station');\n      }\n      else {\n        this.ui.remote_roll_source.text('Controller');\n      }\n      if (alevel.getBit(5)) {\n        this.ui.remote_throttle_source.text('Autopilot');\n      }\n      else if (alevel.getBit(4)) {\n        this.ui.remote_throttle_source.text('Groundstation');\n      }\n      else {\n        this.ui.remote_throttle_source.text('Controller');\n      }\n      if (alevel.getBit(6)) {\n        this.ui.remote_altitude_source.text('Autopilot');\n      }\n      else {\n        this.ui.remote_altitude_source.text('Groundstation');\n      }\n      if (alevel.getBit(7)) {\n        this.ui.remote_altitude_toggle.text('On');\n      }\n      else {\n        this.ui.remote_altitude_toggle.text('Off');\n      }\n      if (alevel.getBit(8)) {\n        this.ui.remote_heading_source.text('Autopilot');\n      }\n      else {\n        this.ui.remote_heading_source.text('Groundstation');\n      }\n      if (alevel.getBit(9)) {\n        this.ui.remote_heading_toggle.text('On');\n      }\n      else {\n        this.ui.remote_heading_toggle.text('Off');\n      }\n      if (alevel.getBit(11)) {\n        this.ui.remote_flap_source.text('Autopilot');\n      }\n      else if (alevel.getBit(10)) {\n        this.ui.remote_flap_source.text('Groundstation');\n      }\n      else {\n        this.ui.remote_flap_source.text('Controller');\n      }\n    },",
            "title": "Interpreting autopilot_active"
        },
        {
            "location": "/picpilot/datalink/#interpreting-error-codes",
            "text": "Signals any problems that may be occurring or have occurred.This value is retrieved from StartupErrorCodes.c. The possible values are (and any binary combination):0b0000000000000000: No Errors0b0000000000000001:Power on reset occurred.0b0000000000000010:Brown out reset occurred.0b0000000000000100:Idle Mode Reset Occurred.0b0000000000001000:Sleep Mode Reset Occurred.0b0000000000010000:Software Watch Dog Timer Reset Occurred.0b0000000000100000:Software Reset Occurred.0b0000000001000000:External Reset Occurred.0b0000000010000000:Voltage Regulator Reset Occurred.0b0000000100000000:Illegal Opcode Reset Occurred.0b0000001000000000:Trap Reset Occurred.0b1000000000000000:UHF Switch is ON (Can be used to indicate joystick controller connection)",
            "title": "Interpreting error codes"
        },
        {
            "location": "/picpilot/datalink/#in-the-code",
            "text": "Prior to usage, the datalink must be initialized.  This is done so in  main.c _using _initDataLink() . This simply initializes the UART2 interface (see UART section) for appropriate usage with the datalink.  After initialization, the data link can be used. The interface used to queue data to the datalink is present in the AttitudeManager.c file.",
            "title": "In the code"
        },
        {
            "location": "/picpilot/datalink/#in-the-code-downlinktelemetry",
            "text": "Data is exported to the data link at a certain frequency (according to a clock). This is done by calling  writeDatalink(frequency) , where frequency is the time between packets. This subroutine creates a structure (defined in  net.h ) which contains memory locations for every variable. This data is then pushed to be processed in  net_outbound.c .  if (time - lastTime > frequency) {\n\n    lastTime = time;\n\n    struct telem_block* statusData = createTelemetryBlock();\n\n    statusData->lat = gps_Latitude;\n\n    statusData->lon = gps_Longitude;\n\n    ...\n\nreturn pushOutboundTelemetryQueue(statusData);\n\n}  When all the data is assembled in the struct,  pushOutboundTelemetryQueue(statusData)  is called. This pushes the data onto a queue to be processed later:  int pushOutboundTelemetryQueue(struct telem_block *telem) {\n\n    if (getOutboundQueueLength() >= OUTBOUND_QUEUE_SIZE) {\n\n        return -1;\n\n    }\n\n    outBuffer[outbuff_end] = telem;\n\n    outbuff_end++;\n\n    outbuff_end = outbuff_end % OUTBOUND_QUEUE_SIZE;\n\n    return getOutboundQueueLength();\n\n}  Note that this is a circular buffer. When the buffer reaches the OUTBOUND_QUEUE_SIZE, the outbuff_end variable starts from 0 and overwrites the old data.  Every once in a while, the data accumulated must be processed. As a result, every iteration of the program runs a subroutine to maintain and cleanup the circular buffer. For the outgoing buffer, this method is  outboundBufferMaintenance() :  if ( stagingBuffer.sendIndex >= PACKET_LENGTH ) {\n\n    destroyTelemetryBlock(stagingBuffer.telemetry.asStruct);\n\n    if ( getOutboundQueueLength() ) {\n\n        stageTelemetryBlock(popOutboundTelemetryQueue());\n\n    }\n\n} else if ( stagingBuffer.telemetry.asStruct == 0 && getOutboundQueueLength() ) {\n\n    stageTelemetryBlock(popOutboundTelemetryQueue());\n\n}  Note that the structure of  stagingBuffer  is as follows:  struct telem_buffer {\n\n    unsigned int sendIndex;             // index into telemetry to send\n\n    unsigned char header[API_HEADER_LENGTH];    // The header for the telem\n\n    union {\n\n        struct telem_block *asStruct;   // The telemetry block being sent\n\n        unsigned char *asArray;         // The telemetry intepreted as an array\n\n    } telemetry;\n\n    unsigned char checksum;             // The checksum so far\n\n};  Note that the  stagingBuffer _converts the data into a data link friendly format. The data link hardware requires that each data packet must be sent with a header, the data, and a checksum (For more specification see the XBEE section). These are 3 components of the _telem_buffer  structure. The 4th component is the  sendIndex  variable. This value is used to keep track (index) what data has already been sent or still needs to be sent.  After sufficient error checking (making sure  sendIndex  is less than the allowed packet size), stageTelemetryBlock(popOutboundTelemetryQueue()) is called. This method takes (pops) the next struct of data and stages it to be sent.  stageTelemetryBlock()  is responsible for converting the telemetry data into a  telem_buffer  structure.  void stageTelemetryBlock(struct telem_block *telem) {\n\n    stagingBuffer.telemetry.asStruct = telem;\n\n    generateApiHeader(stagingBuffer.header, 0);\n\n    stagingBuffer.checksum = 0;\n\n    // Send index should be reset last for reasons\n\n    stagingBuffer.sendIndex = 0;\n\n    sendNextByte();\n\n}  The first line of the subroutine adds the data into the packet. The second line ( generateApiHeader(stagingBuffer.header,0))  creates an appropriate header in the  stagingBuffer.header  memory address with a data frame of 0. (See the XBEE section for the datasheet). The API header includes information involving which device the packet should be sent to, the length of the packet, as well as acknowledgement options, and packet types (data packet, configuration packet, status packet). After the  checksum  and  sendIndex  are explicitly reset, the sending process begins with  sendNextByte() :  void sendNextByte(void) {\n\n    unsigned char sendByte; // The byte to send\n\n    if ( stagingBuffer.sendIndex < API_HEADER_LENGTH ) {\n\n        //while (U2STAbits.TRMT == 0);\n\n        sendByte = stagingBuffer.header[stagingBuffer.sendIndex] & 0xFF;\n\n        // Compute checksum\n\n        if (stagingBuffer.sendIndex >= 3) {\n\n            stagingBuffer.checksum += sendByte & 0xFF;\n\n        }\n\n    } else if ( stagingBuffer.sendIndex < PACKET_LENGTH - 1 ) {\n\n        sendByte = stagingBuffer.telemetry.asArray[stagingBuffer.sendIndex - API_HEADER_LENGTH] & 0xFF;\n\n        stagingBuffer.checksum += sendByte & 0xFF;\n\n    } else if ( stagingBuffer.sendIndex == PACKET_LENGTH - 1) {\n\n        sendByte = 0xFF - (stagingBuffer.checksum & 0xFF);\n\n    } else {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    stagingBuffer.sendIndex++;\n\n    IFS1bits.U2TXIF = 0;\n\n    U2TXREG = sendByte;\n\n}  All the \" if \" statements above, compile the header, the data and the checksum together. Note that the checksum is the bitwise inverse of the actual sum: sendByte = 0xFF - (stagingBuffer.checksum & 0xFF). The most important part of this process is the last line, where each byte is sent to the UART transmit buffer. Since the UART transmit process is interrupt-based, each interrupt keeps calling  sendNextByte() , until there is no more data left:  void __attribute__((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {\n\n    // Short circuit if nothing in the staging area yet\n\n    if ( stagingBuffer.telemetry.asStruct == 0 ) {\n\n        IFS1bits.U2TXIF = 0;\n\n        return;\n\n    }\n\n    sendNextByte();\n\n}  The process can be described through this flowchart:",
            "title": "In the code \u2013 Downlink/Telemetry"
        },
        {
            "location": "/picpilot/datalink/#in-the-code-uplink",
            "text": "Once every iteration, a command is read from the uplink queue. This is done by calling readDatalink(). The command  popCommand()  is called. If any new commands have been received,  popCommand()  will return a  command  struct (defined in  net.h ):  struct command {\n\n    unsigned char cmd;\n\n    unsigned char data\\_length;\n\n    unsigned char data[101];\n\n};  It is fairly straight forward. The structure contains a  cmd.cmd _which indicates the command ID. This ID corresponds to a certain function that needs to be completed. Following the pop command are a series of case statements (one for each command ID). For instance, if the command ID is 30, the following command is run (in _net_inbound.c ):  struct command* cmd = popCommand();\n\n//TODO: Add rudimentary input validation\n\nif ( cmd ) {\n\n    if (lastCommandSentCode == cmd->cmd){\n\n        lastCommandSentCode++;\n\n    }\n\n    else{\n\n        lastCommandSentCode = cmd->cmd * 100;\n\n    }\n\n    switch (cmd->cmd) {\n\n        ...\n\n        case SET_THROTTLE:\n\n            sp_ThrottleRate = (int)(*(int*)(&cmd->data) / 100.0  * (890 - 454) + 454);\n\n            break;\n\n        ...\n    }\n\n}  The throttle ends up being set to the value indicated in the  cmd.data  location. In addition, the last command read is stored and sent to the ground station as verification that the command was received.  The  popCommand() _function waits and reads the next available command from a circular buffer (note the _INBOUND_QUEUE_SIZE  variable). If the command doesn't exist, it exits the function.  In order for the command structure to exist, the  U2RXInterrupt  must have been triggered. This occurs when new data is sent.  void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {\n\n    unsigned char data = U2RXREG;\n\n    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        IFS1bits.U2RXIF = 0;\n\n        return;\n\n    }\n\n    switch ( payloadPos ) {\n\n        case 0:\n\n            if ( data != START_DELIMITER ) {\n\n                IFS1bits.U2RXIF = 0;\n\n                return;\n\n            }\n\n            break;\n\n        case 1:\n\n            if ( data != 0 ) {\n\n                payloadPos = 0;\n\n                IFS1bits.U2RXIF = 0;\n\n                return;                 // packet length < 100 bytes, so msb == 0\n\n            }\n\n            break;\n\n        case 2:\n\n            payloadLength[packetPos] = data;\n\n            break;\n\n        default:        // Normally, don't do anything special\n\n            break;\n\n    }\n\n    rawPackets[packetPos][payloadPos++] = data;\n\n    if ( payloadPos && payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet\n\n        rawPacketStatus[packetPos] = READY;\n\n        payloadPos = 0;\n\n        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;\n\n        if ( rawPacketStatus[packetPos] == EMPTY ) {\n\n            rawPacketStatus[packetPos] = BUSY;\n\n        }\n\n    }\n\n    IFS1bits.U2RXIF = 0;\n\n}  The first thing that occurs when new data arrives is a check to see if there is enough memory to store the data. A  if statement  is used to check if the buffer (rawPacketStatus) is busy or not.  Note that the interrupt will only record the data, if the current  packetPos  marked busy.  If the buffer is full, the next buffer location is checked. Otherwise, the packet is parsed byte by byte.  Firstly, the start delimiter is looked for using a case statement. Until the start delimiter is found, nothing happens. Secondly, for case 1 and 2, the length of the packet is check and recorded. Once the length of the packet is known, the  data  is read into a 2d array called  rawPackets . This array contains each byte of every packet in the circular buffer. Once all the data is copied into the array, the packet is marked as  READY , and the next one is marked  BUSY  if it is  EMPTY , and the processing of the data begins on the next maintenance cycle when  inboundBufferMaintenance()  is called from  main.c :  void inboundBufferMaintenance(void) {\n\n    int i;\n\n    for ( i = 0; i < RAW_PACKET_BUFFER_SIZE; i++ ) {\n\n        if ( rawPacketStatus[i] == READY && checkPacket(rawPackets[i]) ) {\n\n            struct command\\* cmd = createCommand( rawPackets[i] );\n\n            if ( cmd ) {            // create command was successful ?\n\n                pushCommand( cmd ); // queue it up\n\n                rawPacketStatus[i] = EMPTY;         // buffer is now good for writing another packet\n\n            }\n\n        }\n\n    }\n\n    if ( rawPacketStatus[0] == EMPTY ) {\n\n        rawPacketStatus[0] = BUSY;\n\n    }\n\n}  This subroutine iterates through each buffer location and checks for any  READY  packets. If one is found, and it has been verified through a checksum, the command structure is created from the data using the  createCommand(rawPackets[i])  method. Once this is done, the previous spot is marked  EMPTY . The first buffer is always primed if it is empty.",
            "title": "In the code \u2013 Uplink"
        },
        {
            "location": "/picpilot/analog-to-digital-converter/",
            "text": "Analog to Digital Converter\n\n\nThe Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.\n\n\nThe functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.\n\n\nIn the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).\n\n\nIn the code\n\n\nAll the code for the voltage sensor is available in the \nvoltageSensor.c\n and \n.h\n files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:\n\n\nAD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter\n\n\n\nAfter each interrupt, the battery voltage is updated into the \ncurrentSignal\n variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).",
            "title": "Analog to Digital Converter"
        },
        {
            "location": "/picpilot/analog-to-digital-converter/#analog-to-digital-converter",
            "text": "The Analog to Digital Converter (ADC) on the PICpilot is used for a single purpose, which to monitor and report the battery life remaining for the vehicle and/or the autopilot. The path managing chip is responsible for measuring the battery voltage. Based on the reference voltage, a percentage is determined which indicates the voltage measured in relationship to the reference voltage. This data is transmitted to the attitude manager chip and then it is transmitted wirelessly along with the telemetry data.  The functionality of the ADC is fairly straightforward. The ADC module switches between two states. One of which is the sampling period, whereas the other is the conversion period. During the conversion period, no sampling is performed. Instead, the previously captured data is converted into a 12 bit number. Therefore, in order to attain the voltage percent, you simply divide the data by 4096, the largest possible 12 bit number.  In the PICpilot, the ADC module is triggered through interrupts (although it can also be manually polled).",
            "title": "Analog to Digital Converter"
        },
        {
            "location": "/picpilot/analog-to-digital-converter/#in-the-code",
            "text": "All the code for the voltage sensor is available in the  voltageSensor.c  and  .h  files. The code which controls the ADC module is extremely straight forward. The process mostly involves initializations. Most of the \"magic\" is handled automatically by the module, therefore minimal logical coding is required. A few of the important lines have been included below:  AD1CON1bits.FORM = 0;                // Data Output Format: Unsigned Int\n\nAD1CON1bits.SSRC = 7;                // Internal Counter (SAMC) ends sampling and starts conversion\n\nAD1CON1bits.AD12B = 1;                // 12-bit single channel operation\n\nAD1CON1bits.SAMP = 1;\n\nAD1CON2bits.SMPI=0;                        // Interrupt address every sample/conversion\n\nAD1CON2bits.CHPS = 0;                //We are using channel 0\n\nAD1CON2bits.VCFG = 0;                 //Voltage Reference is 3.3V and Ground Reference is Ground\n\nAD1CON3bits.SAMC=0;                         // Auto Sample Time = 0\\*Tad\n\nAD1CON3bits.ADCS=6;                        // ADC Conversion Clock Tad=Tcy\\*(ADCS+1)= (1/40M)\\*7 = 175nS\n\n\n\nAD1CHS0bits.CH0SA = 0xC;                 //Channel 0 positive input on AN12 (Sample A)\n\nAD1CHS0bits.CH0SB = 0xC;                 //Channel 0 positive input on AN12 (Sample B)\n\nIFS0bits.AD1IF = 0;                        // Clear the A/D interrupt flag bit\n\nIEC0bits.AD1IE = 1;                        // Enable A/D interrupt\n\nAD1CON1bits.ADON = 1;                // Turn on the A/D converter  After each interrupt, the battery voltage is updated into the  currentSignal  variable. When the battery voltage is requested, this integer is multiplied by 100 and divided by 4096 to get a percentage (4096 is 12 bits of data).",
            "title": "In the code"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/",
            "text": "Sensors and Peripherals\n\n\nThere are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.\n\n\nGPS (MEDIATEK-3329)\n\n\nThis GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:\n\n\ntypedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;\n\n\n\nLatitude\n and \nLongitude\n should be in degrees.\n\n\nTime\n should be in 24 hour time, with the decimal portion indicating milliseconds.\n\n\nSpeed\n should be in m/s.\n\n\nAltitude\n should be in m.\n\n\nHeading\n should be in degrees (geographical heading, not magnetic).\n\n\nSatellites\n is the number of connected satellites.\n\n\nPositionFix\n is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)\n\n\nIn the current PICpilot, GPS updates occur 10 times a second.\n\n\nThe data sheets can be retrieved from here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing\n\n\nIMU (VN-100/VectorNav-100)\n\n\nThe VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.\n\n\nI GET IT that was 8 files, not four....moving on...\n\n\nYou will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.\n\n\nIn the PICpilot, the two most commonly called functions are \nVN100_SPI_GetYPR()\n and \nVN100_SPI_GetRates()\n. These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.\n\n\nFor a complete list of functions and settings take a look at the documentation:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing\n\n\nAltimeter (MPL3115A2)\n\n\nThe complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.\n\n\nThere are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.\n\n\nTo see the complete list of functions provided by the altimeter, as well as further details see the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing\n\n\nWireless Link - XBEE PRO S3B\n\n\nThe XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.\n\n\nThe PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.\n\n\nAccording to the packet structure specification in the datasheet below, the data is sent or received in that manner.\n\n\nFor details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing\n\n\nThe above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.\n\n\nThe configuration options for the base station can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing\n\n\nThe configuration options for the aircraft module can be found here:\n\n\nhttps://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing\n\n\nRC Receiver (EzUHF)\n\n\nThe exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.\n\n\nThe current receiver uses the 431-437MHz spectrum.\n\n\nThe documentation can be found here:\n\n\nhttp://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf\n\n\nAirspeed Sensor (WIP)\n\n\nThis has not been implemented yet.\n\n\nUltrasonic Sensor (WIP)\n\n\nThis has not been implemented yet.",
            "title": "Sensors and Peripherals"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#sensors-and-peripherals",
            "text": "There are multiple devices and peripherals currently in use on the PICpilot, however, the purpose of this document is not to document their functionality. Instead, appropriate references are listed below.",
            "title": "Sensors and Peripherals"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#gps-mediatek-3329",
            "text": "This GPS module outputs data in the form of NMEA strings. These are ASCI strings with GPS relevant data embedded in them. A separate program is used to convert these strings to a useable format. The PICpilot expects the data to be in the form of a structure:  typedef struct _GPSData {\n\n    long double latitude;  //8 Bytes\n\n    long double longitude; //8 Bytes\n\n    float time;     //4 Bytes\n\n    float speed;\n\n    int altitude;\n\n    int heading;\n\n    char satellites;    //1 Byte\n\n    char positionFix;\n\n} GPSData;  Latitude  and  Longitude  should be in degrees.  Time  should be in 24 hour time, with the decimal portion indicating milliseconds.  Speed  should be in m/s.  Altitude  should be in m.  Heading  should be in degrees (geographical heading, not magnetic).  Satellites  is the number of connected satellites.  PositionFix  is a number representing the accuracy of the data (0 = no data, 1 = GPS functional, 2 = DGPS functional)  In the current PICpilot, GPS updates occur 10 times a second.  The data sheets can be retrieved from here:  https://drive.google.com/file/d/0BySpWXvmBM4JQXVOR093anI0YXc/view?usp=sharing  https://drive.google.com/file/d/0BySpWXvmBM4JR2xTV3dCcGJWczQ/view?usp=sharing",
            "title": "GPS (MEDIATEK-3329)"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#imu-vn-100vectornav-100",
            "text": "The VectorNav-100 has a Kalman filter implemented within it. All the registers and commands that can be executed on the oldest VectorNav are available in four files within the PICpilot code. This includes the VN100.c/.h files, the VN_user.c/.h files, the VN_lib.c/.h, and the VN_math.c/.h files.  I GET IT that was 8 files, not four....moving on...  You will find the SPI initialization function in the VN100.c file. It initializes the SPI2 interface.  In the PICpilot, the two most commonly called functions are  VN100_SPI_GetYPR()  and  VN100_SPI_GetRates() . These two functions get the rate and angles of rotation along the yaw, pitch, and roll axis of the vehicle.  For a complete list of functions and settings take a look at the documentation:  https://drive.google.com/file/d/0BySpWXvmBM4JYXlSdW85NnlxYkE/view?usp=sharing",
            "title": "IMU (VN-100/VectorNav-100)"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#altimeter-mpl3115a2",
            "text": "The complete functionality of the altimeter can be found in the MPL3115A2.c/.h files.  There are only 3 functions implemented in the code. An initialization, calibration, and sensor read function.  To see the complete list of functions provided by the altimeter, as well as further details see the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JeUE4Y3BhQzVMdkk/view?usp=sharing",
            "title": "Altimeter (MPL3115A2)"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#wireless-link-xbee-pro-s3b",
            "text": "The XBEE PRO S3B is currently the wireless interface used with the PICpilot. Nonetheless, many wireless links can be easily substituted with minimal coding as long as a UART interface is supported.  The PICpilot currently only supports this model currently. This wireless link uses the 900MHz spectrum for communication between devices.  According to the packet structure specification in the datasheet below, the data is sent or received in that manner.  For details on other functions and feature that are part of the XBEE PRO S3B module download the documentation here:  https://drive.google.com/file/d/0BySpWXvmBM4JNzdLWXdCWHlEcGs/view?usp=sharing  The above link also includes details on the packet structure. See page 62 for the Tx packet structure. See page 70 for the Rx packet structure.  The configuration options for the base station can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4JTXZESmFEMG9uZEk/view?usp=sharing  The configuration options for the aircraft module can be found here:  https://drive.google.com/file/d/0BySpWXvmBM4Jdml6Wlg5UFZKWEE/view?usp=sharing",
            "title": "Wireless Link - XBEE PRO S3B"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#rc-receiver-ezuhf",
            "text": "The exact model of the RC Receiver is insignificant to the functionality of the PICpilot. However, the PICpilot has 8 PWM inputs and 8 PWM outputs. Therefore, it would be prudent to have a RC Receiver capable of managing 8 channels.  The current receiver uses the 431-437MHz spectrum.  The documentation can be found here:  http://www.immersionrc.com/downloads/manuals/EzUHFManual_EN_v1.0.pdf",
            "title": "RC Receiver (EzUHF)"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#airspeed-sensor-wip",
            "text": "This has not been implemented yet.",
            "title": "Airspeed Sensor (WIP)"
        },
        {
            "location": "/picpilot/sensors-and-peripherals/#ultrasonic-sensor-wip",
            "text": "This has not been implemented yet.",
            "title": "Ultrasonic Sensor (WIP)"
        },
        {
            "location": "/picpilot/attitude-control/",
            "text": "Attitude Control\n\n\nAttitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.\n\n\nIn the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.\n\n\nThis section mostly deals with the \nAttitudeManager.c\n file, as the name implies.\n\n\nThe attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.\n\n\nInitialization\n\n\nThe initialization process involves beginning communication with all components. The process involves the following steps:\n\n\n\n\nInitializing communication to the Path Manager via SPI and DMA\n\n\nVN 100 is initialized\n\n\nVN 100 is offset according to a rotation matrix\n\n\nVN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes\n\n\nPWM input and output is specified according to the used channels\n\n\n\n\nThis can be found in the \nattitudeInit()\n function in the \nAttitudeManager.c\n file.\n\n\nAggregation of Data\n\n\nUsing the initialized sensors from the prior section, the vehicle can now collect data systematically.\n\n\nEvery loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.\n\n\nNext, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.\n\n\nFinally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the \nVN100_SPI_GetRates(0, (float*) &imuData)\n function call. The roll, pitch, and yaw angles can be determined via the \nVN100_SPI_GetYPR(0, &imuData[YAW], &imuData[PITCH], &imuData[ROLL])\n function call.\n\n\nThis concludes all data acquisition. The next step involves analyzing the error.\n\n\nError Analysis (PID control)\n\n\nPID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.\n\n\nAll the PID loop code can be found in the \nOrientationControl.c\n file. It is called from the AttitudeManager.c code.\n\n\nAltitude\n\n\nThe altitude is controlled through a standard PID loop. This can be found in the code:\n\n\n    sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle > MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle < -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;\n\n\n\nLogically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".\n\n\nThrottle\n\n\nLike the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:\n\n\n    control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle > MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle < MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }\n\n\n\nLogically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the \nsp_ThrottleRate\n variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).\n\n\nHeading\n\n\nThe heading control code looks as such:\n\n\n    while (sp_Heading > 360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading < 0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle > MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle < -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;\n\n\n\nAs you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.\n\n\nThe first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.\n\n\nOnce again the roll value is limited to a reasonable value, to prevent excessive maneuvers.\n\n\nAngles\n\n\nThe code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):\n\n\nsp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));\n\n\n\nNote that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.\n\n\nAngular Rate\n\n\nThe result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.\n\n\ncontrol_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);\n\n\n\nThe output of this function completes the PID pipeline. The value of \ncontrol_Roll\n, or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).\n\n\nOutput Corrections\n\n\nOnce the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.\n\n\nThis involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:\n\n\nsetPWM(1, control_Roll + rollTrim);\n\n\n\nAs long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.\n\n\nControl Levels\n\n\nThe control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.\n\n\nFor instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.\n\n\nAs it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different \ncontrol level.\n As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.\n\n\nFor instance, take this scenario:\n\n\nif ((controlLevel & ROLL_CONTROL_SOURCE) == 0 && (controlLevel & HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));\n\n\n\nThis snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The \nif\n statement contains two bit masks. Note that the \ncontrolLevel\n variable has a \nbitwise AND \n(&) applied to it.\n\n\nTherefore, if the controlLevel is (in binary):\n\n\n0b00000000 00010011\n\n\nThe code above will run, because a \nAND\n bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.\n\n\nThis type of logic is applied to multiple sections of the attitude manager code.",
            "title": "Attitude Control"
        },
        {
            "location": "/picpilot/attitude-control/#attitude-control",
            "text": "Attitude Control is very similar regardless of the aircraft which is being used. The end goal is to be able to keep the aircraft stable and in control. The way in which this is achieved is always very similar.  In the PICpilot, we use PID loops to manage our system. Although there are other types of controllers available, PID controllers are the best option due to their reliability, accuracy, and simplicity. The section on PID loops has a detailed explanation of how they work, and how they work together.  This section mostly deals with the  AttitudeManager.c  file, as the name implies.  The attitude manager has the 3 main goals, as well as a side task. The 3 main goals include the aggregation of status data (inputs, sensors, etc.), error analysis on the status of the aircraft, and corrections to the aircraft. The side task involves sending all this data to the ground station, as well as receiving from the ground station.",
            "title": "Attitude Control"
        },
        {
            "location": "/picpilot/attitude-control/#initialization",
            "text": "The initialization process involves beginning communication with all components. The process involves the following steps:   Initializing communication to the Path Manager via SPI and DMA  VN 100 is initialized  VN 100 is offset according to a rotation matrix  VN 100 is then calibrated with confidence parameters for the X/Y/Z magnetometers, accelerometers, and gyroscopes  PWM input and output is specified according to the used channels   This can be found in the  attitudeInit()  function in the  AttitudeManager.c  file.",
            "title": "Initialization"
        },
        {
            "location": "/picpilot/attitude-control/#aggregation-of-data",
            "text": "Using the initialized sensors from the prior section, the vehicle can now collect data systematically.  Every loop, new data is acquired from the DMA/SPI interface connected to the Path Manager chip. Data acquired from this chip includes the time, heading, speed, longitude, latitude, altitude, number of satellites, position fix, battery level, waypoint index, set point altitude, and set point heading.  Next, data is acquired from the PWM inputs. This includes stick positions, which determine the roll, pitch, yaw, and throttle of the aircraft. These inputs are scaled to values ranging from -1024 to 1024.  Finally, the VectorNav is polled for the latest rotational data. The roll, pitch, and yaw rate data is acquired through the  VN100_SPI_GetRates(0, (float*) &imuData)  function call. The roll, pitch, and yaw angles can be determined via the  VN100_SPI_GetYPR(0, &imuData[YAW], &imuData[PITCH], &imuData[ROLL])  function call.  This concludes all data acquisition. The next step involves analyzing the error.",
            "title": "Aggregation of Data"
        },
        {
            "location": "/picpilot/attitude-control/#error-analysis-pid-control",
            "text": "PID control works on the basis of minimizing error. The majority of the attitude manager involves consecutive PID loops correcting specific portions of flying an aircraft.  All the PID loop code can be found in the  OrientationControl.c  file. It is called from the AttitudeManager.c code.",
            "title": "Error Analysis (PID control)"
        },
        {
            "location": "/picpilot/attitude-control/#altitude",
            "text": "The altitude is controlled through a standard PID loop. This can be found in the code:      sp_PitchAngle = controlSignalAltitude(sp_Altitude,(int)gps_Altitude);\n\n    if (sp_PitchAngle > MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = MAX_PITCH_ANGLE;\n\n    if (sp_PitchAngle < -MAX_PITCH_ANGLE)\n\n        sp_PitchAngle = -MAX_PITCH_ANGLE;  Logically, the pitch angle is determined from the desired altitude. If the plane is too low, the pitch angle will be positive (up). If the plane is too high, the pitch angle will be negative (down). The pitch angle is then checked to be within \"safety limits\".",
            "title": "Altitude"
        },
        {
            "location": "/picpilot/attitude-control/#throttle",
            "text": "Like the altitude PID loop, the throttle also has PID loop, which is also based on the altitude:      control_Throttle = sp_ThrottleRate + controlSignalThrottle(sp_Altitude, (int)gps_Altitude);\n\n    if (control_Throttle > MAX_PWM){\n\n        control_Throttle = MAX_PWM;\n\n    }\n\n    else if (control_Throttle < MIN_PWM){\n\n        control_Throttle = MIN_PWM;\n\n    }  Logically, if the plane needs to climb, you need to increase the throttle (otherwise it will stall due to low airspeed). Likewise, if the plane needs to reduce its altitude, to prevent high airspeeds, the plane decreases the throttle. If the plane is perfectly positioned, a constant throttle is maintained as per the  sp_ThrottleRate  variable. Once again, the throttle is limited within the legal limits of the throttle (to ensure the throttle doesn't become negative or larger than 100%).",
            "title": "Throttle"
        },
        {
            "location": "/picpilot/attitude-control/#heading",
            "text": "The heading control code looks as such:      while (sp_Heading > 360)\n\n        sp_Heading -=360;\n\n    while (sp_Heading < 0)\n\n        sp_Heading +=360;\n\n        sp_HeadingRate = controlSignalHeading(sp_Heading, gps_PositionFix==2?gps_Heading:(int)imu_YawAngle);\n\n        //Approximating Roll angle from Heading\n\n        sp_RollAngle = sp_HeadingRate;//(int)(atan((float)(sp_HeadingRate)) * PI/180.0);\n\n    if (sp_RollAngle > MAX_ROLL_ANGLE)\n\n        sp_RollAngle = MAX_ROLL_ANGLE;\n\n    if (sp_RollAngle < -MAX_ROLL_ANGLE)\n\n        sp_RollAngle = -MAX_ROLL_ANGLE;  As you can see, the input is the heading and the resulting output is a roll angle. In other words, if there is a greater error in the heading, a larger roll angle is established to correct for the heading error.  The first two while loops take into account any angle overflow or underflow, in other words, if the value is above 360 or negative, it is scaled to be between 0 and 360.  Once again the roll value is limited to a reasonable value, to prevent excessive maneuvers.",
            "title": "Heading"
        },
        {
            "location": "/picpilot/attitude-control/#angles",
            "text": "The code to maintain the angular roll and pitch of the aircraft look as such (one statement for each):  sp_ComputedRollRate = controlSignalAngles(sp_RollAngle,  imu_RollAngle, ROLL, -(SP_RANGE) / (MAX_ROLL_ANGLE));  Note that depending on the on the input angles, the output is a \"rate\". It is an angular rate. In other words, if the difference between the setpoint and the output is large, the angular rate will also be large.",
            "title": "Angles"
        },
        {
            "location": "/picpilot/attitude-control/#angular-rate",
            "text": "The result from the angular PID loop gives rise to the angular rate PID loop. This loop is often acknowledged as a stabilizing system, where small quick vibrations are accounted for.  control_Roll = controlSignal((sp_ComputedRollRate / SERVO_SCALE_FACTOR), imu_RollRate, ROLL);  The output of this function completes the PID pipeline. The value of  control_Roll , or the equivalent variable for the pitch for that matter, is then directly applied to the PWM module, in order to create a correction to the system (using the flaps, elevators, rudder, or what not).",
            "title": "Angular Rate"
        },
        {
            "location": "/picpilot/attitude-control/#output-corrections",
            "text": "Once the calculations have been made to determine what corrections should be made to the system, it is then time to physically alter the system based on the calculations.  This involves output to the PWM module. After a series of checks, to ensure that all values are within the maximum and minimum parameters for the PWM signal, a PWM call is made to the appropriate channel:  setPWM(1, control_Roll + rollTrim);  As long as the PWM module was initialized, there shouldn't be any problem. The vehicle should move its servos appropriately.",
            "title": "Output Corrections"
        },
        {
            "location": "/picpilot/attitude-control/#control-levels",
            "text": "The control levels implemented in the attitude manager are an important part of the testing process. These levels determine which input sources have primary control over the aircraft, as well as how the input translates into flight.  For instance, when testing, one may wish to have control of the throttle, while the roll and pitch is controlled by the autopilot. Such control is implemented in the code.  As it is evident above, there a separate sections of code, which control individual PID loops. The control levels change the source of the input to the PIDs using a simple bit mask. The control level is actually determined by a single integer. Each value of the integer represents a different  control level.  As a result, a bit mask is placed within an, if statement to determine whether or not a specific element of control is enabled or disabled.  For instance, take this scenario:  if ((controlLevel & ROLL_CONTROL_SOURCE) == 0 && (controlLevel & HEADING_CONTROL_ON) == 0)\n\n    sp_RollAngle = (int)((-sp_RollRate / ((float)SP\\_RANGE / MAX_ROLL_ANGLE) ));  This snippet of code, converts the controller input into a roll angle. For instance, if the stick is centered, the plane will be at a 0\u00b0 roll angle. If the pilot steers left, the plane will angle itself left at that same angle. The  if  statement contains two bit masks. Note that the  controlLevel  variable has a  bitwise AND  (&) applied to it.  Therefore, if the controlLevel is (in binary):  0b00000000 00010011  The code above will run, because a  AND  bit mask of 0b00001000, will return a value of zero, just as well as 0b00000010 00000000 will also return a logical value of zero.  This type of logic is applied to multiple sections of the attitude manager code.",
            "title": "Control Levels"
        },
        {
            "location": "/picpilot/path-management/",
            "text": "Path Management\n\n\nPath management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.\n\n\nStraight Line Path Following\n\n\nStraight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.\n\n\nThe principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its \ncross-track error\n. Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:\n\n\n\n\nThe equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the \nHaversine Formula\n in order to get the XY coordinates.\n\n\nOnce you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the \narctan\n function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.\n\n\nNow the path error (or cross-track error) is calculated. This is calculated as:\n\n\ncos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)\n\n\n\nOn a map, the _cross-track error _looks like this:\n\n\n\n\nUsing trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.\n\n\nThe cross track error is then useful to determine the heading of the aircraft. Once again, using the \narctan\n function is suitable to do so:\n\n\n\n\n90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))\n\n\n\nNote, as the atan term increases, the heading approaches the \n(courseAngle -__MAX_PATH_APPROACH_ANGLE)\n.\n\n\nNote, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the \ncourseAngle\n from 90 degrees.\n\n\nOrbit Following\n\n\nUnlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).\n\n\n\n\nIn order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:\n\n\nfloat orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));\n\n\n\nThis value is then used to determine the equivalent of \ncross-track _error, but for an orbit. This is done very easily. The term _d\n (Euclidean distance) subtracted by the \n\u03c1\n (desired radius) provides the relative error, which must be minimized.\n\n\n\n\n90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))\n\n\n\nThis equation is actually very similar to the equation governing straight line path following. The \narctan\n function forces the heading to converge onto the orbit. The direction of travel (\n\u03bb\n) which can be either \n1\n or \n-1\n, reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.\n\n\nThe course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:\n\n\nfloat courseAngle = atan2(position[1] - center[1], position[0] - center[0]);\n\n\n\nPutting it all together\n\n\nThe orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.\n\n\nIn order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:\n\n\n\n\nFiguring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:\n\n\n\n\nWhere nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.\n\n\nThe turning angle can be calculated via the following equation:\n\n\nfloat turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));\n\n\n\nThis is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the \narccos\n function to determine the angle between the two lines.\n\n\nAt these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.\n\n\nIn order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.\n\n\nThe dot product is:\n\n\n\n\nBoth vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.\n\n\nNote that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.\n\n\nFor every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.\n\n\nManaging Path Data\n\n\nPath data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:\n\n\ntypedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;\n\n\n\nThis structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.\n\n\nThe included functions are:\n\n\nPathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);\n\n\n\nThese functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.",
            "title": "Path Management"
        },
        {
            "location": "/picpilot/path-management/#path-management",
            "text": "Path management can be broken up into 3 sections. The straight parts, the parts where you turn, and the way you put them together. There is not much more to it than that.",
            "title": "Path Management"
        },
        {
            "location": "/picpilot/path-management/#straight-line-path-following",
            "text": "Straight line path following, also known as, following a line, is the most rudimentary part of any unmanned system. It is mostly a mathematical construct applied to a digital system. The mathematics will be described here, which can be easily compared to the code.  The principle is simple. Given two points, and the location of your vehicle, determine what heading it should follow. Now imagine the plane is directly on the path. The heading would follow the line exactly. Now imagine the plane is slightly off the path. What should happen is that the plane should face slightly towards the path, to minimize its  cross-track error . Now imagine the plane is an infinite distance away. The plane should head at a heading perpendicular to the line, in order to regain distance. This is the premise of the straight line path following algorithm. As a result, a heading vector field would look as such:   The equations that govern this behaviour are not complicated. There are only a few things required to make this calculation. Firstly, you must know the heading of the path. If you have the XY coordinates of the path endpoints, you can easily determine that through simple trigonometry. If you only have the GPS coordinates, you should use the  Haversine Formula  in order to get the XY coordinates.  Once you have the coordinates, subtracting them will give you the direction of travel (in an XY plane). Furthermore, by applying the  arctan  function on the direction of travel, one will determine the path heading. In addition, the value should be between \u2013PI and +PI. Thus, any 2PI corrections that need to be made can be made at this point.  Now the path error (or cross-track error) is calculated. This is calculated as:  cos(courseAngle) * (positionY - targetWaypointY) \u2013 sin(courseAngle)*(positionX \u2013 targetWaypointX)  On a map, the _cross-track error _looks like this:   Using trigonometry you can easily derive the formula (as above) for cross-track error to encompass any situation.  The cross track error is then useful to determine the heading of the aircraft. Once again, using the  arctan  function is suitable to do so:   90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError))  Note, as the atan term increases, the heading approaches the  (courseAngle -__MAX_PATH_APPROACH_ANGLE) .  Note, that the courseAngle is calculated with respect to the x-axis, on the x-y plane. In other words, a path going from West to East would have a courseAngle of 0 degrees. This would be 90 degrees in terms of a true heading. Therefore, to get the true heading, you must subtract the  courseAngle  from 90 degrees.",
            "title": "Straight Line Path Following"
        },
        {
            "location": "/picpilot/path-management/#orbit-following",
            "text": "Unlike straight line path following, orbit following involves following a curve of a certain radius. An orbit is depicted by a radius, a center location, and the direction of travel (clockwise or anti-clockwise).   In order to maintain a certain radius, the Euclidean distance needs to be calculated between the center of the orbit and the plane itself. The goal of this function is to maintain this Euclidean distance constant. The Euclidean distance can be calculated as such:  float orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));  This value is then used to determine the equivalent of  cross-track _error, but for an orbit. This is done very easily. The term _d  (Euclidean distance) subtracted by the  \u03c1  (desired radius) provides the relative error, which must be minimized.   90 - rad2deg(courseAngle + direction \\* (PI/2 + atan(k\\_gain[ORBIT] \\* (orbitDistance - radius)/radius)))  This equation is actually very similar to the equation governing straight line path following. The  arctan  function forces the heading to converge onto the orbit. The direction of travel ( \u03bb ) which can be either  1  or  -1 , reverses the effect of the heading perturbations. This is then added onto the course angle as a perturbation. Once again, a gain value needs to be tuned to determine the rate of convergence.  The course angle can be determined easily based on the location of the curve. For instance, if the vehicle is in the first quadrant of the circle/orbit, the heading will range between 270\u00b0 and 0\u00b0, assuming a counter-clockwise rotation. This course angle can be calculated using this equation:  float courseAngle = atan2(position[1] - center[1], position[0] - center[0]);",
            "title": "Orbit Following"
        },
        {
            "location": "/picpilot/path-management/#putting-it-all-together",
            "text": "The orbit following and straight path following algorithms are used in combination in order to assemble a path. Both algorithms alternate in usage. Every corner uses the orbit following algorithm. Every straight line uses the straight path following algorithm.  In order to put the two together, you must draw in orbits between each set of points. The additional restriction is that they must be tangent to both lines, as depicted in this diagram:   Figuring out where the tangent will touch requires some basic trigonometry. The derivation won't be explained here, however, the coordinates at which this occurs can be calculated using:   Where nextX/Y/Z refer to the coordinates of the point Wi+1 and targetX/Y/Z refer to the coordinates of the point Wi.  The turning angle can be calculated via the following equation:  float turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));  This is simply the dot product of the (Wi - Wi-1) vector and the (Wi+1 - Wi) vector. Given the dot product formula, you can use the  arccos  function to determine the angle between the two lines.  At these calculated points, there is a checkpoint. Imagine a giant plane perpendicular to the path. As soon as the plane crosses this boundary, the next step is executed. For instance, if the vehicle is travelling straight along a path, then passes the plane, it will initiate a turn (orbiting algorithm). Once it passes the next plane, it will initiate the straight line path following algorithm once again.  In order to detect if a vehicle passes the boundary, the dot product of two vectors must be taken. If the value is positive, it is an indicator that the vehicle has crossed the boundary.  The dot product is:   Both vectors have X, Y, and Z components. Likewise, equations that depict the half plane are stated above.  Note that in the code, all \"direction vectors\" such as Wi \u2013 Wi-1 are normalized.  For every pair of \"checkpoints\" the path index is incremented once they are passed. The index is used to identify the data in a linked list through the wireless communications.",
            "title": "Putting it all together"
        },
        {
            "location": "/picpilot/path-management/#managing-path-data",
            "text": "Path data is stored in a structure, which contains all necessary information for a single path (line) segment. The construct looks as follows:  typedef struct _PathData{\n\n    struct _PathData* next;\n\n    struct _PathData* previous;\n\n    long double longitude;  //TODO: Longitude and Latitude is bulky. Use cartesian 2D approximations\n\n    long double latitude;\n\n    float altitude;\n\n    float radius; //Radius of turn\n\n    char id;    //Array ID\n\n    char index;\n\n} PathData;  This structure is a doubly linked list element. It links to the previous node and the next node. This makes it easy to traverse from one element to another. As a result, it is easy to add, insert, delete, and clear all waypoint nodes.  The included functions are:  PathData* initializePathNode(void);\n\nunsigned int destroyPathNode(PathData* node);\n\nPathData* initializePathNodeAndNext(void);\n\nunsigned int appendPathNode(PathData* node);\n\nunsigned int removePathNode(unsigned int ID);\n\nvoid clearPathNodes(void);\n\nunsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID);  These functions are all executed in the _checkAMData() _function. This function polls input over the DMA/SPI bus. When a new input is detected (via the WaypointWrapper structure), a corresponding function is executed.",
            "title": "Managing Path Data"
        },
        {
            "location": "/picpilot/resources/",
            "text": "Additional Readings and Resources\n\n\n\n\nInformation on Model Aircraft\n\n\nGeneral Aerodynamic Principles\n\n\nGit Help\n\n\n\n\nMicrochip Important Documentation\n\n\nReference Manuals\n\n\nThese reference manuals apply to the entire dsPIC33/PIC24 family of devices, and also\napply to the microchip the picpilot uses. These are useful if you want to learn more\nabout the actual functionalities of the chip. It also contains some code examples.\n\n\n\n\nSection 1- Introduction\n\n\nSection 2- CPU\n\n\nSection 3- Data Memory\n\n\nSection 4- Program Memory\n\n\nSection 5- Flash Programming\n\n\nSection 6- Interrupts\n\n\nSection 7- Oscillator\n\n\nSection 8- Reset\n\n\nSection 9- Watchdog Timer and Powersaving Mdoes\n\n\nSection 10- IO Ports\n\n\nSection 11- Timers\n\n\nSection 12- Input Capture\n\n\nSection 16- Analog to Digital Converter (ADC)\n\n\nSection 20- Data Converter Interface (DCI)\n\n\nSection 22- Direct Memory Access (DMA)\n\n\nSection 25- Device Configuration\n\n\n\n\nOther Useful Application Notes\n\n\n\n\nI2C\n\n\nOutput Compare\n\n\nSPI\n\n\nUART\n\n\n\n\nDatasheet\n\n\nThis datasheet contains the hardware documentation for how the chip works. Still useful\nfor software if you want to know what certain registers are used for and such.\n\n\ndsPIC33FJ Datasheet",
            "title": "Resources"
        },
        {
            "location": "/picpilot/resources/#additional-readings-and-resources",
            "text": "Information on Model Aircraft  General Aerodynamic Principles  Git Help",
            "title": "Additional Readings and Resources"
        },
        {
            "location": "/picpilot/resources/#microchip-important-documentation",
            "text": "",
            "title": "Microchip Important Documentation"
        },
        {
            "location": "/picpilot/resources/#reference-manuals",
            "text": "These reference manuals apply to the entire dsPIC33/PIC24 family of devices, and also\napply to the microchip the picpilot uses. These are useful if you want to learn more\nabout the actual functionalities of the chip. It also contains some code examples.   Section 1- Introduction  Section 2- CPU  Section 3- Data Memory  Section 4- Program Memory  Section 5- Flash Programming  Section 6- Interrupts  Section 7- Oscillator  Section 8- Reset  Section 9- Watchdog Timer and Powersaving Mdoes  Section 10- IO Ports  Section 11- Timers  Section 12- Input Capture  Section 16- Analog to Digital Converter (ADC)  Section 20- Data Converter Interface (DCI)  Section 22- Direct Memory Access (DMA)  Section 25- Device Configuration",
            "title": "Reference Manuals"
        },
        {
            "location": "/picpilot/resources/#other-useful-application-notes",
            "text": "I2C  Output Compare  SPI  UART",
            "title": "Other Useful Application Notes"
        },
        {
            "location": "/picpilot/resources/#datasheet",
            "text": "This datasheet contains the hardware documentation for how the chip works. Still useful\nfor software if you want to know what certain registers are used for and such.  dsPIC33FJ Datasheet",
            "title": "Datasheet"
        },
        {
            "location": "/picpilot/faq/",
            "text": "FAQ\n\n\nNo questions here yet.",
            "title": "FAQ"
        },
        {
            "location": "/picpilot/faq/#faq",
            "text": "No questions here yet.",
            "title": "FAQ"
        }
    ]
}